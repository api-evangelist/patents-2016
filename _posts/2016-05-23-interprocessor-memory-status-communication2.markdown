---

title: Interprocessor memory status communication
abstract: In a transactional memory environment including a first processor and one or more additional processors, a computer-implemented method includes identifying a memory location and sending a probe request from the first processor to the additional processors. The probe request includes the memory location. The computer implemented method further includes generating, by each additional processor, an indication including whether the memory location is in use for a transaction by the additional processor. The computer-implemented method further includes sending the indication from each additional processor to the first processor and proceeding, by the first processor, based on the indication.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09563468&OS=09563468&RS=09563468
owner: International Business Machines Corporation
number: 09563468
owner_city: Armonk
owner_country: US
publication_date: 20160523
---
This disclosure relates generally to interprocessor communication in a multiprocessor computing environment with transactional memory and more specifically to communicating memory usage status between processors in such an environment.

The number of central processing unit CPU cores on a chip and the number of CPU cores connected to a shared memory continues to grow significantly to support growing workload capacity demand. The increasing number of CPUs cooperating to process the same workloads puts a significant burden on software scalability for example shared queues or data structures protected by traditional semaphores become hot spots and lead to sub linear n way scaling curves. Traditionally this has been countered by implementing finer grained locking in software and with lower latency higher bandwidth interconnects in hardware. Implementing fine grained locking to improve software scalability can be very complicated and error prone and at today s CPU frequencies the latencies of hardware interconnects are limited by the physical dimension of the chips and systems and by the speed of light.

Implementations of hardware Transactional Memory TM have been introduced wherein a group of instructions called a transaction operate atomically and in isolation sometimes called serializability on a data structure in memory. The transaction executes optimistically without obtaining a lock but may need to abort and retry the transaction execution if an operation of the executing transaction on a memory location conflicts with another operation on the same memory location. Previously software transactional memory implementations have been proposed to support software Transactional Memory TM . However hardware TM can provide improved performance aspects and ease of use over software TM.

U.S. Pat. No. 8 250 331 titled Operating system virtual memory management for hardware transactional memory issued Aug. 21 2012 teaches 

U.S. Patent Application Publication No. US2012 0005530 titled System and Method for Communication Between Concurrent Transactions Using Transaction Communicator Objects issued Jan. 5 2012 teaches 

In a transactional memory environment including a first processor and one or more additional processors a computer implemented method includes identifying a memory location and sending a probe request from the first processor to the additional processors. The probe request includes the memory location. The computer implemented method further includes generating by each additional processor an indication including whether the memory location is in use for a transaction by the additional processor. The computer implemented method further includes sending the indication from each additional processor to the first processor and proceeding by the first processor based on the indication.

Historically a computer system or processor had only a single processor aka processing unit or central processing unit . The processor included an instruction processing unit IPU a branch unit a memory control unit and the like. Such processors were capable of executing a single thread of a program at a time. Operating systems were developed that could time share a processor by dispatching a program to be executed on the processor for a period of time and then dispatching another program to be executed on the processor for another period of time. As technology evolved memory subsystem caches were often added to the processor as well as complex dynamic address translation including translation lookaside buffers TLBs . The IPU itself was often referred to as a processor. As technology continued to evolve an entire processor could be packaged on a single semiconductor chip or die such a processor was referred to as a microprocessor. Then processors were developed that incorporated multiple IPUs such processors were often referred to as multi processors. Each such processor of a multi processor computer system processor may include individual or shared caches memory interfaces system bus address translation mechanism and the like. Virtual machine and instruction set architecture ISA emulators added a layer of software to a processor that provided the virtual machine with multiple virtual processors aka processors by time slice usage of a single IPU in a single hardware processor. As technology further evolved multi threaded processors were developed enabling a single hardware processor having a single multi thread IPU to provide a capability of simultaneously executing threads of different programs thus each thread of a multi threaded processor appeared to the operating system as a processor. As technology further evolved it was possible to put multiple processors each having an IPU on a single semiconductor chip or die. These processors were referred to processor cores or just cores. Thus the terms such as processor central processing unit processing unit microprocessor core processor core processor thread and thread for example are often used interchangeably. Aspects of embodiments herein may be practiced by any or all processors including those shown supra without departing from the teachings herein. Wherein the term thread or processor thread is used herein it is expected that particular advantage of the embodiment may be had in a processor thread implementation.

In Intel Architecture Instruction Set Extensions Programming Reference 319433 012A February 2012 incorporated herein by reference in its entirety Chapter 8 teaches in part that multithreaded applications may take advantage of increasing numbers of CPU cores to achieve higher performance. However the writing of multi threaded applications requires programmers to understand and take into account data sharing among the multiple threads. Access to shared data typically requires synchronization mechanisms. These synchronization mechanisms are used to ensure that multiple threads update shared data by serializing operations that are applied to the shared data often through the use of a critical section that is protected by a lock. Since serialization limits concurrency programmers try to limit the overhead due to synchronization.

Intel Transactional Synchronization Extensions Intel TSX allow a processor to dynamically determine whether threads need to be serialized through lock protected critical sections and to perform that serialization only when required. This allows the processor to expose and exploit concurrency that is hidden in an application because of dynamically unnecessary synchronization.

With Intel TSX programmer specified code regions also referred to as transactional regions or just transactions are executed transactionally. If the transactional execution completes successfully then all memory operations performed within the transactional region will appear to have occurred instantaneously when viewed from other processors. A processor makes the memory operations of the executed transaction performed within the transactional region visible to other processors only when a successful commit occurs i.e. when the transaction successfully completes execution. This process is often referred to as an atomic commit.

Intel TSX provides two software interfaces to specify regions of code for transactional execution. Hardware Lock Elision HLE is a legacy compatible instruction set extension comprising the XACQUIRE and XRELEASE prefixes to specify transactional regions. Restricted Transactional Memory RTM is a new instruction set interface comprising the XBEGIN XEND and XABORT instructions for programmers to define transactional regions in a more flexible manner than that possible with HLE. HLE is for programmers who prefer the backward compatibility of the conventional mutual exclusion programming model and would like to run HLE enabled software on legacy hardware but would also like to take advantage of the new lock elision capabilities on hardware with HLE support. RTM is for programmers who prefer a flexible interface to the transactional execution hardware. In addition Intel TSX also provides an XTEST instruction. This instruction allows software to query whether the logical processor is transactionally executing in a transactional region identified by either HLE or RTM.

Since a successful transactional execution ensures an atomic commit the processor executes the code region optimistically without explicit synchronization. If synchronization was unnecessary for that specific execution execution can commit without any cross thread serialization. If the processor cannot commit atomically then the optimistic execution fails. When this happens the processor will roll back the execution a process referred to as a transactional abort. On a transactional abort the processor will discard all updates performed in the memory region used by the transaction restore architectural state to appear as if the optimistic execution never occurred and resume execution non transactionally.

A processor can perform a transactional abort for numerous reasons. A primary reason to abort a transaction is due to conflicting memory accesses between the transactionally executing logical processor and another logical processor. Such conflicting memory accesses may prevent a successful transactional execution. Memory addresses read from within a transactional region constitute the read set of the transactional region and addresses written to within the transactional region constitute the write set of the transactional region. Intel TSX maintains the read and write sets at the granularity of a cache line. A conflicting memory access occurs if another logical processor either reads a location that is part of the transactional region s write set or writes a location that is a part of either the read or write set of the transactional region. A conflicting access typically means that serialization is required for this code region. Since Intel TSX detects data conflicts at the granularity of a cache line unrelated data locations placed in the same cache line will be detected as conflicts that result in transactional aborts. Transactional aborts may also occur due to limited transactional resources. For example the amount of data accessed in the region may exceed an implementation specific capacity. Additionally some instructions and system events may cause transactional aborts. Frequent transactional aborts result in wasted cycles and increased inefficiency.

Hardware Lock Elision HLE provides a legacy compatible instruction set interface for programmers to use transactional execution. HLE provides two new instruction prefix hints XACQUIRE and XRELEASE.

With HLE a programmer adds the XACQUIRE prefix to the front of the instruction that is used to acquire the lock that is protecting the critical section. The processor treats the prefix as a hint to elide the write associated with the lock acquire operation. Even though the lock acquire has an associated write operation to the lock the processor does not add the address of the lock to the transactional region s write set nor does it issue any write requests to the lock. Instead the address of the lock is added to the read set. The logical processor enters transactional execution. If the lock was available before the XACQUIRE prefixed instruction then all other processors will continue to see the lock as available afterwards. Since the transactionally executing logical processor neither added the address of the lock to its write set nor performed externally visible write operations to the lock other logical processors can read the lock without causing a data conflict. This allows other logical processors to also enter and concurrently execute the critical section protected by the lock. The processor automatically detects any data conflicts that occur during the transactional execution and will perform a transactional abort if necessary.

Even though the eliding processor did not perform any external write operations to the lock the hardware ensures program order of operations on the lock. If the eliding processor itself reads the value of the lock in the critical section it will appear as if the processor had acquired the lock i.e. the read will return the non elided value. This behavior allows an HLE execution to be functionally equivalent to an execution without the HLE prefixes.

An XRELEASE prefix can be added in front of an instruction that is used to release the lock protecting a critical section. Releasing the lock involves a write to the lock. If the instruction is to restore the value of the lock to the value the lock had prior to the XACQUIRE prefixed lock acquire operation on the same lock then the processor elides the external write request associated with the release of the lock and does not add the address of the lock to the write set. The processor then attempts to commit the transactional execution.

With HLE if multiple threads execute critical sections protected by the same lock but they do not perform any conflicting operations on each other s data then the threads can execute concurrently and without serialization. Even though the software uses lock acquisition operations on a common lock the hardware recognizes this elides the lock and executes the critical sections on the two threads without requiring any communication through the lock if such communication was dynamically unnecessary.

If the processor is unable to execute the region transactionally then the processor will execute the region non transactionally and without elision. HLE enabled software has the same forward progress guarantees as the underlying non HLE lock based execution. For successful HLE execution the lock and the critical section code must follow certain guidelines. These guidelines only affect performance and failure to follow these guidelines will not result in a functional failure. Hardware without HLE support will ignore the XACQUIRE and XRELEASE prefix hints and will not perform any elision since these prefixes correspond to the REPNE REPE IA 32 prefixes which are ignored on the instructions where XACQUIRE and XRELEASE are valid. Importantly HLE is compatible with the existing lock based programming model. Improper use of hints will not cause functional bugs though it may expose latent bugs already in the code.

Restricted Transactional Memory RTM provides a flexible software interface for transactional execution. RTM provides three new instructions XBEGIN XEND and XABORT for programmers to start commit and abort a transactional execution.

The programmer uses the XBEGIN instruction to specify the start of a transactional code region and the XEND instruction to specify the end of the transactional code region. If the RTM region could not be successfully executed transactionally then the XBEGIN instruction takes an operand that provides a relative offset to the fallback instruction address.

A processor may abort RTM transactional execution for many reasons. In many instances the hardware automatically detects transactional abort conditions and restarts execution from the fallback instruction address with the architectural state corresponding to that present at the start of the XBEGIN instruction and the EAX register updated to describe the abort status.

The XABORT instruction allows programmers to abort the execution of an RTM region explicitly. The XABORT instruction takes an 8 bit immediate argument that is loaded into the EAX register and will thus be available to software following an RTM abort. RTM instructions do not have any data memory location associated with them. While the hardware provides no guarantees as to whether an RTM region will ever successfully commit transactionally most transactions that follow the recommended guidelines are expected to successfully commit transactionally. However programmers must always provide an alternative code sequence in the fallback path to guarantee forward progress. This may be as simple as acquiring a lock and executing the specified code region non transactionally. Further a transaction that always aborts on a given implementation may complete transactionally on a future implementation. Therefore programmers must ensure the code paths for the transactional region and the alternative code sequence are functionally tested.

A processor supports HLE execution if CPUID.07H.EBX.HLE bit 1. However an application can use the HLE prefixes XACQUIRE and XRELEASE without checking whether the processor supports HLE. Processors without HLE support ignore these prefixes and will execute the code without entering transactional execution.

A processor supports RTM execution if CPUID.07H.EBX.RTM bit 1. An application must check if the processor supports RTM before it uses the RTM instructions XBEGIN XEND XABORT . These instructions will generate a UD exception when used on a processor that does not support RTM.

A processor supports the XTEST instruction if it supports either HLE or RTM. An application must check either of these feature flags before using the XTEST instruction. This instruction will generate a UD exception when used on a processor that does not support either HLE or RTM.

The XTEST instruction can be used to determine the transactional status of a transactional region specified by HLE or RTM. Note while the HLE prefixes are ignored on processors that do not support HLE the XTEST instruction will generate a UD exception when used on processors that do not support either HLE or RTM.

For HLE execution to successfully commit transactionally the lock must satisfy certain properties and access to the lock must follow certain guidelines.

An XRELEASE prefixed instruction must restore the value of the elided lock to the value it had before the lock acquisition. This allows hardware to safely elide locks by not adding them to the write set. The data size and data address of the lock release XRELEASE prefixed instruction must match that of the lock acquire XACQUIRE prefixed and the lock must not cross a cache line boundary.

Software should not write to the elided lock inside a transactional HLE region with any instruction other than an XRELEASE prefixed instruction otherwise such a write may cause a transactional abort. In addition recursive locks where a thread acquires the same lock multiple times without first releasing the lock may also cause a transactional abort. Note that software can observe the result of the elided lock acquire inside the critical section. Such a read operation will return the value of the write to the lock.

The processor automatically detects violations to these guidelines and safely transitions to a non transactional execution without elision. Since Intel TSX detects conflicts at the granularity of a cache line writes to data collocated on the same cache line as the elided lock may be detected as data conflicts by other logical processors eliding the same lock.

Both HLE and RTM support nested transactional regions. However a transactional abort restores state to the operation that started transactional execution either the outermost XACQUIRE prefixed HLE eligible instruction or the outermost XBEGIN instruction. The processor treats all nested transactions as one transaction.

Programmers can nest HLE regions up to an implementation specific depth of MAX HLE NEST COUNT. Each logical processor tracks the nesting count internally but this count is not available to software. An XACQUIRE prefixed HLE eligible instruction increments the nesting count and an XRELEASE prefixed HLE eligible instruction decrements it. The logical processor enters transactional execution when the nesting count goes from zero to one. The logical processor attempts to commit only when the nesting count becomes zero. A transactional abort may occur if the nesting count exceeds MAX HLE NEST COUNT.

In addition to supporting nested HLE regions the processor can also elide multiple nested locks. The processor tracks a lock for elision beginning with the XACQUIRE prefixed HLE eligible instruction for that lock and ending with the XRELEASE prefixed HLE eligible instruction for that same lock. The processor can at any one time track up to a MAX HLE ELIDED LOCKS number of locks. For example if the implementation supports a MAX HLE ELIDED LOCKS value of two and if the programmer nests three HLE identified critical sections by performing XACQUIRE prefixed HLE eligible instructions on three distinct locks without performing an intervening XRELEASE prefixed HLE eligible instruction on any one of the locks then the first two locks will be elided but the third won t be elided but will be added to the transaction s writeset . However the execution will still continue transactionally. Once an XRELEASE for one of the two elided locks is encountered a subsequent lock acquired through the XACQUIRE prefixed HLE eligible instruction will be elided.

The processor attempts to commit the HLE execution when all elided XACQUIRE and XRELEASE pairs have been matched the nesting count goes to zero and the locks have satisfied requirements. If execution cannot commit atomically then execution transitions to a non transactional execution without elision as if the first instruction did not have an XACQUIRE prefix.

Programmers can nest RTM regions up to an implementation specific MAX RTM NEST COUNT. The logical processor tracks the nesting count internally but this count is not available to software. An XBEGIN instruction increments the nesting count and an XEND instruction decrements the nesting count. The logical processor attempts to commit only if the nesting count becomes zero. A transactional abort occurs if the nesting count exceeds MAX RTM NEST COUNT.

HLE and RTM provide two alternative software interfaces to a common transactional execution capability. Transactional processing behavior is implementation specific when HLE and RTM are nested together e.g. HLE is inside RTM or RTM is inside HLE. However in all cases the implementation will maintain HLE and RTM semantics. An implementation may choose to ignore HLE hints when used inside RTM regions and may cause a transactional abort when RTM instructions are used inside HLE regions. In the latter case the transition from transactional to non transactional execution occurs seamlessly since the processor will re execute the HLE region without actually doing elision and then execute the RTM instructions.

RTM uses the EAX register to communicate abort status to software. Following an RTM abort the EAX register has the following definition.

The EAX abort status for RTM only provides causes for aborts. It does not by itself encode whether an abort or commit occurred for the RTM region. The value of EAX can be 0 following an RTM abort. For example a CPUID instruction when used inside an RTM region causes a transactional abort and may not satisfy the requirements for setting any of the EAX bits. This may result in an EAX value of 0.

A successful RTM commit causes all memory operations in the RTM region to appear to execute atomically. A successfully committed RTM region consisting of an XBEGIN followed by an XEND even with no memory operations in the RTM region has the same ordering semantics as a LOCK prefixed instruction.

The XBEGIN instruction does not have fencing semantics. However if an RTM execution aborts then all memory updates from within the RTM region are discarded and are not made visible to any other logical processor.

By default any debug exception inside an RTM region will cause a transactional abort and will redirect control flow to the fallback instruction address with architectural state recovered and bit in EAX set. However to allow software debuggers to intercept execution on debug exceptions the RTM architecture provides additional capability.

If bit of DR7 and bit of the IA32 DEBUGCTL MSR are both 1 any RTM abort due to a debug exception DB or breakpoint exception BP causes execution to roll back and restart from the XBEGIN instruction instead of the fallback address. In this scenario the EAX register will also be restored back to the point of the XBEGIN instruction.

Typical programmer identified regions are expected to transactionally execute and commit successfully. However Intel TSX does not provide any such guarantee. A transactional execution may abort for many reasons. To take full advantage of the transactional capabilities programmers should follow certain guidelines to increase the probability of their transactional execution committing successfully.

This section discusses various events that may cause transactional aborts. The architecture ensures that updates performed within a transaction that subsequently aborts execution will never become visible. Only committed transactional executions initiate an update to the architectural state. Transactional aborts never cause functional failures and only affect performance.

Programmers can use any instruction safely inside a transaction HLE or RTM and can use transactions at any privilege level. However some instructions will always abort the transactional execution and cause execution to seamlessly and safely transition to a non transactional path.

Intel TSX allows for most common instructions to be used inside transactions without causing aborts. The following operations inside a transaction do not typically cause an abort 

However programmers must be careful when intermixing SSE and AVX operations inside a transactional region. Intermixing SSE instructions accessing XMM registers and AVX instructions accessing YMM registers may cause transactions to abort. Programmers may use REP REPNE prefixed string operations inside transactions. However long strings may cause aborts. Further the use of CLD and STD instructions may cause aborts if they change the value of the DF flag. However if DF is 1 the STD instruction will not cause an abort. Similarly if DF is 0 then the CLD instruction will not cause an abort.

Instructions not enumerated here as causing abort when used inside a transaction will typically not cause a transaction to abort examples include but are not limited to MFENCE LFENCE SFENCE RDTSC RDTSCP etc. .

In addition in some implementations the following instructions may always cause transactional aborts. These instructions are not expected to be commonly used inside typical transactional regions. However programmers must not rely on these instructions to force a transactional abort since whether they cause transactional aborts is implementation dependent.

In addition to the instruction based considerations runtime events may cause transactional execution to abort. These may be due to data access patterns or micro architectural implementation features. The following list is not a comprehensive discussion of all abort causes.

Any fault or trap in a transaction that must be exposed to software will be suppressed. Transactional execution will abort and execution will transition to a non transactional execution as if the fault or trap had never occurred. If an exception is not masked then that un masked exception will result in a transactional abort and the state will appear as if the exception had never occurred.

Synchronous exception events DE OF NP SS GP BR UD AC XF PF NM TS MF DB BP INT3 that occur during transactional execution may cause an execution not to commit transactionally and require a non transactional execution. These events are suppressed as if they had never occurred. With HLE since the non transactional code path is identical to the transactional code path these events will typically re appear when the instruction that caused the exception is re executed non transactionally causing the associated synchronous events to be delivered appropriately in the non transactional execution. Asynchronous events NMI SMI INTR IPI PMI etc. occurring during transactional execution may cause the transactional execution to abort and transition to a non transactional execution. The asynchronous events will be pended and handled after the transactional abort is processed.

Transactions only support write back cacheable memory type operations. A transaction may always abort if the transaction includes operations on any other memory type. This includes instruction fetches to UC memory type.

Memory accesses within a transactional region may require the processor to set the Accessed and Dirty flags of the referenced page table entry. The behavior of how the processor handles this is implementation specific. Some implementations may allow the updates to these flags to become externally visible even if the transactional region subsequently aborts. Some Intel TSX implementations may choose to abort the transactional execution if these flags need to be updated. Further a processor s page table walk may generate accesses to its own transactionally written but uncommitted state. Some Intel TSX implementations may choose to abort the execution of a transactional region in such situations. Regardless the architecture ensures that if the transactional region aborts then the transactionally written state will not be made architecturally visible through the behavior of structures such as TLBs.

Executing self modifying code transactionally may also cause transactional aborts. Programmers must continue to follow the Intel recommended guidelines for writing self modifying and cross modifying code even when employing HLE and RTM. While an implementation of RTM and HLE will typically provide sufficient resources for executing common transactional regions implementation constraints and excessive sizes for transactional regions may cause a transactional execution to abort and transition to a non transactional execution. The architecture provides no guarantee of the amount of resources available to do transactional execution and does not guarantee that a transactional execution will ever succeed.

Conflicting requests to a cache line accessed within a transactional region may prevent the transaction from executing successfully. For example if logical processor P reads line A in a transactional region and another logical processor P1 writes line A either inside or outside a transactional region then logical processor P0 may abort if logical processor P1 s write interferes with processor P0 s ability to execute transactionally.

Similarly if P0 writes line A in a transactional region and P1 reads or writes line A either inside or outside a transactional region then P0 may abort if P1 s access to line A interferes with P0 s ability to execute transactionally. In addition other coherence traffic may at times appear as conflicting requests and may cause aborts. While these false conflicts may happen they are expected to be uncommon. The conflict resolution policy to determine whether P0 or P1 aborts in the above scenarios is implementation specific.

According to ARCHITECTURES FOR TRANSACTIONAL MEMORY a dissertation submitted to the Department of Computer Science and the Committee on Graduate Studies of Stanford University in partial fulfillment of the requirements for the Degree of Doctor of Philosophy by Austen McDonald June 2009 incorporated by reference herein in its entirety fundamentally there are three mechanisms needed to implement an atomic and isolated transactional region versioning conflict detection and contention management.

To make a transactional code region appear atomic all the modifications performed by that transactional code region must be stored and kept isolated from other transactions until commit time. The system does this by implementing a versioning policy. Two versioning paradigms exist eager and lazy. An eager versioning system stores newly generated transactional values in place and stores previous memory values on the side in what is called an undo log. A lazy versioning system stores new values temporarily in what is called a write buffer copying them to memory only on commit. In either system the cache is used to optimize storage of new versions.

To ensure that transactions appear to be performed atomically conflicts must be detected and resolved. The two systems i.e. the eager and lazy versioning systems detect conflicts by implementing a conflict detection policy either optimistic or pessimistic. An optimistic system executes transactions in parallel checking for conflicts only when a transaction commits. A pessimistic system checks for conflicts at each load and store. Similar to versioning conflict detection also uses the cache marking each line as either part of the read set part of the write set or both. The two systems resolve conflicts by implementing a contention management policy. Many contention management policies exist some are more appropriate for optimistic conflict detection and some are more appropriate for pessimistic. Described below are some example policies.

Since each transactional memory TM system needs both versioning detection and conflict detection these options give rise to four distinct TM designs Eager Pessimistic EP Eager Optimistic EO Lazy Pessimistic LP and Lazy Optimistic LO . Table 2 briefly describes all four distinct TM designs.

A key detail for programmers in any TM system is how non transactional accesses interact with transactions. By design transactional accesses are screened from each other using the mechanisms above. However the interaction between a regular non transactional load with a transaction containing a new value for that address must still be considered. In addition the interaction between a non transactional store with a transaction that has read that address must also be explored. These are issues of the database concept isolation.

A TM system is said to implement strong isolation sometimes called strong atomicity when every non transactional load and store acts like an atomic transaction. Therefore non transactional loads cannot see uncommitted data and non transactional stores cause atomicity violations in any transactions that have read that address. A system where this is not the case is said to implement weak isolation sometimes called weak atomicity.

Strong isolation is often more desirable than weak isolation due to the relative ease of conceptualization and implementation of strong isolation. Additionally if a programmer has forgotten to surround some shared memory references with transactions causing bugs then with strong isolation the programmer will often detect that oversight using a simple debug interface because the programmer will see a non transactional region causing atomicity violations. Also programs written in one model may work differently on another model.

Further strong isolation is often easier to support in hardware TM than weak isolation. With strong isolation since the coherence protocol already manages load and store communication between processors transactions can detect non transactional loads and stores and act appropriately. To implement strong isolation in software Transactional Memory TM non transactional code must be modified to include read and write barriers potentially crippling performance. Although great effort has been expended to remove many un needed barriers such techniques are often complex and performance is typically far lower than that of HTMs.

Table 2 illustrates the fundamental design space of transactional memory versioning and conflict detection .

This first TM design described below is known as Eager Pessimistic. An EP system stores its write set in place hence the name eager and to support rollback stores the old values of overwritten lines in an undo log . Processors use the W and R cache bits to track read and write sets and detect conflicts when receiving snooped load requests. Perhaps the most notable examples of EP systems in known literature are Log TM and UTM.

Beginning a transaction in an EP system is much like beginning a transaction in other systems tm begin takes a register checkpoint and initializes any status registers. An EP system also requires initializing the undo log the details of which are dependent on the log format but often involve initializing a log base pointer to a region of pre allocated thread private memory and clearing a log bounds register.

Versioning In EP due to the way eager versioning is designed to function the MESI 130 state transitions cache line indicators corresponding to Modified Exclusive Shared and Invalid code states are left mostly unchanged. Outside of a transaction the MESI 130 state transitions are left completely unchanged. When reading a line inside a transaction the standard coherence transitions apply S Shared S I Invalid S or I E Exclusive issuing a load miss as needed but the R bit is also set. Likewise writing a line applies the standard transitions S M E I I M issuing a miss as needed but also sets the W Written bit. The first time a line is written the old version of the entire line is loaded then written to the undo log to preserve it in case the current transaction aborts. The newly written data is then stored in place over the old data.

Conflict Detection Pessimistic conflict detection uses coherence messages exchanged on misses or upgrades to look for conflicts between transactions. When a read miss occurs within a transaction other processors receive a load request but they ignore the request if they do not have the needed line. If the other processors have the needed line non speculatively or have the line R Read they downgrade that line to S and in certain cases issue a cache to cache transfer if they have the line in MESI s M or E state. However if the cache has the line W then a conflict is detected between the two transactions and additional action s must be taken.

Similarly when a transaction seeks to upgrade a line from shared to modified on a first write the transaction issues an exclusive load request which is also used to detect conflicts. If a receiving cache has the line non speculatively then the line is invalidated and in certain cases a cache to cache transfer M or E states is issued. But if the line is R or W a conflict is detected.

Validation Because conflict detection is performed on every load a transaction always has exclusive access to its own write set. Therefore validation does not require any additional work.

Commit Since eager versioning stores the new version of data items in place the commit process simply clears the W and R bits and discards the undo log.

Abort When a transaction rolls back the original version of each cache line in the undo log must be restored a process called unrolling or applying the log. This is done during tm discard and must be atomic with regard to other transactions. Specifically the write set must still be used to detect conflicts this transaction has the only correct version of lines in its undo log and requesting transactions must wait for the correct version to be restored from that log. Such a log can be applied using a hardware state machine or software abort handler.

Eager Pessimistic has the characteristics of Commit is simple and since it is in place very fast. Similarly validation is a no op. Pessimistic conflict detection detects conflicts early thereby reducing the number of doomed transactions. For example if two transactions are involved in a Write After Read dependency then that dependency is detected immediately in pessimistic conflict detection. However in optimistic conflict detection such conflicts are not detected until the writer commits.

Eager Pessimistic also has the characteristics of As described above the first time a cache line is written the old value must be written to the log incurring extra cache accesses. Aborts are expensive as they require undoing the log. For each cache line in the log a load must be issued perhaps going as far as main memory before continuing to the next line. Pessimistic conflict detection also prevents certain serializable schedules from existing.

Additionally because conflicts are handled as they occur there is a potential for livelock and careful contention management mechanisms must be employed to guarantee forward progress.

Another popular TM design is Lazy Optimistic LO which stores its write set in a write buffer or redo log and detects conflicts at commit time still using the R and W bits .

Versioning Just as in the EP system the MESI protocol of the LO design is enforced outside of the transactions. Once inside a transaction reading a line incurs the standard MESI transitions but also sets the R bit. Likewise writing a line sets the W bit of the line but handling the MESI transitions of the LO design is different from that of the EP design. First with lazy versioning the new versions of written data are stored in the cache hierarchy until commit while other transactions have access to old versions available in memory or other caches. To make available the old versions dirty lines M lines must be evicted when first written by a transaction. Second no upgrade misses are needed because of the optimistic conflict detection feature if a transaction has a line in the S state it can simply write to it and upgrade that line to an M state without communicating the changes with other transactions because conflict detection is done at commit time.

Conflict Detection and Validation To validate a transaction and detect conflicts LO communicates the addresses of speculatively modified lines to other transactions only when it is preparing to commit. On validation the processor sends one potentially large network packet containing all the addresses in the write set. Data is not sent but left in the cache of the committer and marked dirty M . To build this packet without searching the cache for lines marked W a simple bit vector is used called a store buffer with one bit per cache line to track these speculatively modified lines. Other transactions use this address packet to detect conflicts if an address is found in the cache and the R and or W bits are set then a conflict is initiated. If the line is found but neither R nor W is set then the line is simply invalidated which is similar to processing an exclusive load.

To support transaction atomicity these address packets must be handled atomically i.e. no two address packets may exist at once with the same addresses. In an LO system this can be achieved by simply acquiring a global commit token before sending the address packet. However a two phase commit scheme could be employed by first sending out the address packet collecting responses enforcing an ordering protocol perhaps oldest transaction first and committing once all responses are satisfactory.

Commit Once validation has occurred commit needs no special treatment simply clear W and R bits and the store buffer. The transaction s writes are already marked dirty in the cache and other caches copies of these lines have been invalidated via the address packet. Other processors can then access the committed data through the regular coherence protocol.

Abort Rollback is equally easy because the write set is contained within the local caches these lines can be invalidated then clear W and R bits and the store buffer. The store buffer allows W lines to be found to invalidate without the need to search the cache.

Lazy Optimistic has the characteristics of Aborts are very fast requiring no additional loads or stores and making only local changes. More serializable schedules can exist than found in EP which allows an LO system to more aggressively speculate that transactions are independent which can yield higher performance. Finally the late detection of conflicts can increase the likelihood of forward progress.

Lazy Optimistic also has the characteristics of Validation takes global communication time proportional to size of write set. Doomed transactions can waste work since conflicts are detected only at commit time.

Lazy Pessimistic LP represents a third TM design option sitting somewhere between EP and LO storing newly written lines in a write buffer but detecting conflicts on a per access basis.

Versioning Versioning is similar but not identical to that of LO reading a line sets its R bit writing a line sets its W bit and a store buffer is used to track W lines in the cache. Also dirty M lines must be evicted when first written by a transaction just as in LO. However since conflict detection is pessimistic load exclusives must be performed when upgrading a transactional line from I S M which is unlike LO.

Conflict Detection LP s conflict detection operates the same as EP s using coherence messages to look for conflicts between transactions.

Validation Like in EP pessimistic conflict detection ensures that at any point a running transaction has no conflicts with any other running transaction so validation is a no op.

Abort Rollback is also like that of LO simply invalidate the write set using the store buffer and clear the W and R bits and the store buffer.

The LP has the characteristics of Like LO aborts are very fast. Like EP the use of pessimistic conflict detection reduces the number of doomed transactions Like EP some serializable schedules are not allowed and conflict detection must be performed on each cache miss.

The final combination of versioning and conflict detection is Eager Optimistic EO . EO may be a less than optimal choice for HTM systems since new transactional versions are written in place other transactions have no choice but to notice conflicts as they occur i.e. as cache misses occur . But since EO waits until commit time to detect conflicts those transactions become zombies continuing to execute wasting resources yet are doomed to abort.

EO has proven to be useful in STMs and is implemented by Bartok STM and McRT. A lazy versioning STM needs to check its write buffer on each read to ensure that it is reading the most recent value. Since the write buffer is not a hardware structure this is expensive hence the preference for write in place eager versioning. Additionally since checking for conflicts is also expensive in an STM optimistic conflict detection offers the advantage of performing this operation in bulk.

How a transaction rolls back once the system has decided to abort that transaction has been described above but since a conflict involves two transactions the topics of which transaction should abort how that abort should be initiated and when should the aborted transaction be retried need to be explored. These are topics that are addressed by Contention Management CM a key component of transactional memory. Described below are policies regarding how the systems initiate aborts and the various established methods of managing which transactions should abort in a conflict.

A Contention Management CM Policy is a mechanism that determines which transaction involved in a conflict should abort and when the aborted transaction should be retried. For example it is often the case that retrying an aborted transaction immediately does not lead to the best performance. Conversely employing a back off mechanism which delays the retrying of an aborted transaction can yield better performance. STMs first grappled with finding the best contention management policies and many of the policies outlined below were originally developed for STMs.

CM Policies draw on a number of measures to make decisions including ages of the transactions size of read and write sets the number of previous aborts etc. The combinations of measures to make such decisions are endless but certain combinations are described below roughly in order of increasing complexity.

To establish some nomenclature first note that in a conflict there are two sides the attacker and the defender. The attacker is the transaction requesting access to a shared memory location. In pessimistic conflict detection the attacker is the transaction issuing the load or load exclusive. In optimistic the attacker is the transaction attempting to validate. The defender in both cases is the transaction receiving the attacker s request.

An Aggressive CM Policy immediately and always retries either the attacker or the defender. In LO Aggressive means that the attacker always wins and so Aggressive is sometimes called committer wins. Such a policy was used for the earliest LO systems. In the case of EP Aggressive can be either defender wins or attacker wins.

Restarting a conflicting transaction that will immediately experience another conflict is bound to waste work namely interconnect bandwidth refilling cache misses. A Polite CM Policy employs exponential backoff but linear could also be used before restarting conflicts. To prevent starvation a situation where a process does not have resources allocated to it by the scheduler the exponential backoff greatly increases the odds of transaction success after some n retries.

Another approach to conflict resolution is to randomly abort the attacker or defender a policy called Randomized . Such a policy may be combined with a randomized backoff scheme to avoid unneeded contention.

However making random choices when selecting a transaction to abort can result in aborting transactions that have completed a lot of work which can waste resources. To avoid such waste the amount of work completed on the transaction can be taken into account when determining which transaction to abort. One measure of work could be a transaction s age. Other methods include Oldest Bulk TM Size Matters Karma and Polka. Oldest is a simple timestamp method that aborts the younger transaction in a conflict. Bulk TM uses this scheme. Size Matters is like Oldest but instead of transaction age the number of read written words is used as the priority reverting to Oldest after a fixed number of aborts. Karma is similar using the size of the write set as priority. Rollback then proceeds after backing off a fixed amount of time. Aborted transactions keep their priorities after being aborted hence the name Karma . Polka works like Karma but instead of backing off a predefined amount of time it backs off exponentially more each time.

Since aborting wastes work it is logical to argue that stalling an attacker until the defender has finished their transaction would lead to better performance. Unfortunately such a simple scheme easily leads to deadlock.

Deadlock avoidance techniques can be used to solve this problem. Greedy uses two rules to avoid deadlock. The first rule is if a first transaction T1 has lower priority than a second transaction T0 or if T1 is waiting for another transaction then T1 aborts when conflicting with T0. The second rule is if T1 has higher priority than T0 and is not waiting then T0 waits until T1 commits aborts or starts waiting in which case the first rule is applied . Greedy provides some guarantees about time bounds for executing a set of transactions. One EP design Log TM uses a CM policy similar to Greedy to achieve stalling with conservative deadlock avoidance.

Example MESI coherency rules provide for four possible states in which a cache line of a multiprocessor cache system may reside M E S and I defined as follows 

Modified M The cache line is present only in the current cache and is dirty it has been modified from the value in main memory. The cache is required to write the data back to main memory at some time in the future before permitting any other read of the no longer valid main memory state. The write back changes the line to the Exclusive state.

Exclusive E The cache line is present only in the current cache but is clean it matches main memory. It may be changed to the Shared state at any time in response to a read request. Alternatively it may be changed to the Modified state when writing to it.

Shared S Indicates that this cache line may be stored in other caches of the machine and is clean it matches the main memory. The line may be discarded changed to the Invalid state at any time.

TM coherency status indicators R W may be provided for each cache line in addition to or encoded in the MESI coherency bits. An R indicator indicates the current transaction has read from the data of the cache line and a W indicator indicates the current transaction has written to the data of the cache line.

In another aspect of TM design a system is designed using transactional store buffers. U.S. Pat. No. 6 349 361 titled Methods and Apparatus for Reordering and Renaming Memory References in a Multiprocessor Computer System filed Mar. 31 2000 and incorporated by reference herein in its entirety teaches a method for reordering and renaming memory references in a multiprocessor computer system having at least a first and a second processor. The first processor has a first private cache and a first buffer and the second processor has a second private cache and a second buffer. The method includes the steps of for each of a plurality of gated store requests received by the first processor to store a datum exclusively acquiring a cache line that contains the datum by the first private cache and storing the datum in the first buffer. Upon the first buffer receiving a load request from the first processor to load a particular datum the particular datum is provided to the first processor from among the data stored in the first buffer based on an in order sequence of load and store operations. Upon the first cache receiving a load request from the second cache for a given datum an error condition is indicated and a current state of at least one of the processors is reset to an earlier state when the load request for the given datum corresponds to the data stored in the first buffer.

The main implementation components of one such transactional memory facility are a transaction backup register file for holding pre transaction GR general register content a cache directory to track the cache lines accessed during the transaction a store cache to buffer stores until the transaction ends and firmware routines to perform various complex functions. In this section a detailed implementation is described.

The IBM zEnterprise EC12 enterprise server introduces transactional execution TX in transactional memory and is described in part in a paper Transactional Memory Architecture and Implementation for IBM System z of Proceedings Pages 25 36 presented at MICRO 45 1 5 Dec. 2012 Vancouver British Columbia Canada available from IEEE Computer Society Conference Publishing Services CPS which is incorporated by reference herein in its entirety.

Table 3 shows an example transaction. Transactions started with TBEGIN are not assured to ever successfully complete with TEND since they can experience an aborting condition at every attempted execution e.g. due to repeating conflicts with other CPUs. This requires that the program support a fallback path to perform the same operation non transactionally e.g. by using traditional locking schemes. This puts significant burden on the programming and software verification teams especially where the fallback path is not automatically generated by a reliable compiler.

The requirement of providing a fallback path for aborted Transaction Execution TX transactions can be onerous. Many transactions operating on shared data structures are expected to be short touch only a few distinct memory locations and use simple instructions only. For those transactions the IBM zEnterprise EC12 introduces the concept of constrained transactions under normal conditions the CPU assures that constrained transactions eventually end successfully albeit without giving a strict limit on the number of necessary retries. A constrained transaction starts with a TBEGINC instruction and ends with a regular TEND. Implementing a task as a constrained or non constrained transaction typically results in very comparable performance but constrained transactions simplify software development by removing the need for a fallback path. IBM s Transactional Execution architecture is further described in z Architecture Principles of Operation Tenth Edition SA22 7832 09 published September 2012 from IBM incorporated by reference herein in its entirety.

A constrained transaction starts with the TBEGINC instruction. A transaction initiated with TBEGINC must follow a list of programming constraints otherwise the program takes a non filterable constraint violation interruption. Exemplary constraints may include but not be limited to the transaction can execute a maximum of 32 instructions all instruction text must be within 256 consecutive bytes of memory the transaction contains only forward pointing relative branches i.e. no loops or subroutine calls the transaction can access a maximum of 4 aligned octowords an octoword is 32 bytes of memory and restriction of the instruction set to exclude complex instructions like decimal or floating point operations. The constraints are chosen such that many common operations like doubly linked list insert delete operations can be performed including the very powerful concept of atomic compare and swap targeting up to 4 aligned octowords. At the same time the constraints were chosen conservatively such that future CPU implementations can assure transaction success without needing to adjust the constraints since that would otherwise lead to software incompatibility.

TBEGINC mostly behaves like XBEGIN in TSX or TBEGIN on IBM s zEC12 servers except that the floating point register FPR control and the program interruption filtering fields do not exist and the controls are considered to be zero. On a transaction abort the instruction address is set back directly to the TBEGINC instead of to the instruction after reflecting the immediate retry and absence of an abort path for constrained transactions.

Nested transactions are not allowed within constrained transactions but if a TBEGINC occurs within a non constrained transaction it is treated as opening a new non constrained nesting level just like TBEGIN would. This can occur e.g. if a non constrained transaction calls a subroutine that uses a constrained transaction internally.

Since interruption filtering is implicitly off all exceptions during a constrained transaction lead to an interruption into the operating system OS . Eventual successful finishing of the transaction relies on the capability of the OS to page in the at most 4 pages touched by any constrained transaction. The OS must also ensure time slices long enough to allow the transaction to complete.

Table 4 shows the constrained transactional implementation of the code in Table 3 assuming that the constrained transactions do not interact with other locking based code. No lock testing is shown therefore but could be added if constrained transactions and lock based code were mixed.

When failure occurs repeatedly software emulation is performed using millicode as part of system firmware. Advantageously constrained transactions have desirable properties because of the burden removed from programmers.

With reference to the IBM zEnterprise EC12 processor introduced the transactional execution facility. The processor can decode 3 instructions per clock cycle simple instructions are dispatched as single micro ops and more complex instructions are cracked into multiple micro ops. The micro ops Uops are written into a unified issue queue from where they can be issued out of order. Up to two fixed point one floating point two load store and two branch instructions can execute every cycle. A Global Completion Table GCT holds every micro op and a transaction nesting depth TND . The GCT is written in order at decode time tracks the execution status of each micro op and completes instructions when all micro ops of the oldest instruction group have successfully executed.

The level 1 L1 data cache is a 96 KB kilo byte 6 way associative cache with 256 byte cache lines and 4 cycle use latency coupled to a private 1 MB mega byte 8 way associative 2nd level L2 data cache with 7 cycles use latency penalty for L1 misses. L1 cache is the cache closest to a processor and Ln cache is a cache at the nth level of caching. Both L1 and L2 caches are store through. Six cores on each central processor CP chip share a 48 MB 3rd level store in cache and six CP chips are connected to an off chip 384 MB L4 cache packaged together on a glass ceramic multi chip module MCM . Up to 4 multi chip modules MCMs can be connected to a coherent symmetric multi processor SMP system with up to 144 cores not all cores are available to run customer workload .

Coherency is managed with a variant of the MESI protocol. Cache lines can be owned read only shared or exclusive the L1 and L2 are store through and thus do not contain dirty lines. The L3 and L4 caches are store in and track dirty states. Each cache is inclusive of all its connected lower level caches.

Coherency requests are called cross interrogates XIs and may be sent hierarchically from higher level to lower level caches and between the L4s . In embodiments implementing the L4s when one core misses the L1 and L2 and requests the cache line from its local L3 the L3 checks whether it owns the line and if necessary sends an XI to the currently owning L2 L1 under that L3 to ensure coherency before it returns the cache line to the requestor. If the request also misses the L3 the L3 sends a request to the L4 which enforces coherency by sending XIs to all necessary L3s under that L4 and to the neighboring L4s. Then the L4 responds to the requesting L3 which forwards the response to the L2 L1 . More generally XIs may be transmitted from higher to lower cache levels in systems with more or fewer levels. For example various embodiments may lack an L4 entirely and in such embodiments XIs may be communicated between L3s or between the lowest level caches that are implemented on the system. Even more generally XIs may be understood as a hardware mechanism for communicating messages between processors whether through the caches main memory or otherwise.

Note that due to the inclusivity rule of the cache hierarchy sometimes cache lines are XI ed from lower level caches due to evictions on higher level caches caused by associativity overflows from requests to other cache lines. These XIs can be called LRU XIs where LRU stands for least recently used.

Making reference to yet another type of XI requests Demote XIs transition cache ownership from exclusive into read only state and Exclusive XIs transition cache ownership from exclusive into invalid state. Demote XIs and Exclusive XIs need a response back to the XI sender. The target cache can accept the XI or send a reject response if it first needs to evict dirty data before accepting the XI. The L1 L2 caches are store through but may reject demote XIs and exclusive XIs if they have stores in their store queues that need to be sent to L3 before downgrading the exclusive state. A rejected XI will be repeated by the sender. Read only XIs are sent to caches that own the line read only no response is needed for such XIs since they cannot be rejected. The details of the SMP protocol are similar to those described for the IBM z10 by P. Mak C. Walters and G. Strait in IBM System z10 processor cache subsystem microarchitecture IBM Journal of Research and Development Vol 53 1 2009 which is incorporated by reference herein in its entirety.

Similar to the nesting depth the IDU GCT collaboratively track the access register floating point register AR FPR modification masks through the transaction nest the IDU can place an abort request into the GCT when an AR FPR modifying instruction is decoded and the modification mask blocks that. When the instruction becomes next to complete completion is blocked and the transaction aborts. Other restricted instructions are handled similarly including TBEGIN if decoded while in a constrained transaction or exceeding the maximum nesting depth.

An outermost TBEGIN is cracked into multiple micro ops depending on the GR Save Mask each micro op including for example uop 0 uop 1 and uop2 will be executed by one of the two fixed point units FXUs to save a pair of GRs into a special transaction backup register file that is used to later restore the GR content in case of a transaction abort. Also the TBEGIN spawns micro ops to perform an accessibility test for the TDB if one is specified the address is saved in a special purpose register for later usage in the abort case. At the decoding of an outermost TBEGIN the instruction address and the instruction text of the TBEGIN are also saved in special purpose registers for a potential abort processing later on.

TEND and NTSTG are single micro op instructions NTSTG non transactional store is handled like a normal store except that it is marked as non transactional in the issue queue so that the LSU can treat it appropriately. TEND is a no op at execution time the ending of the transaction is performed when TEND completes.

As mentioned instructions that are within a transaction are marked as such in the issue queue but otherwise execute mostly unchanged the LSU performs isolation tracking as described in the next section.

Since decoding is in order and since the IDU keeps track of the current transactional state and writes it into the issue queue along with every instruction from the transaction execution of TBEGIN TEND and instructions before within and after the transaction can be performed out of order. It is even possible though unlikely that TEND is executed first then the entire transaction and lastly the TBEGIN executes. Program order is restored through the GCT at completion time. The length of transactions is not limited by the size of the GCT since general purpose registers GRs can be restored from the backup register file .

During execution the program event recording PER events are filtered based on the Event Suppression Control and a PER TEND event is detected if enabled. Similarly while in transactional mode a pseudo random generator may be causing the random aborts as enabled by the Transaction Diagnostics Control.

The Load Store Unit tracks cache lines that were accessed during transactional execution and triggers an abort if an XI from another CPU or an LRU XI conflicts with the footprint. If the conflicting XI is an exclusive or demote XI the LSU rejects the XI back to the L3 in the hope of finishing the transaction before the L3 repeats the XI. This stiff arming is very efficient in highly contended transactions. In order to prevent hangs when two CPUs stiff arm each other a XI reject counter is implemented which triggers a transaction abort when a threshold is met.

The L1 cache directory is traditionally implemented with static random access memories SRAMs . For the transactional memory implementation the valid bits 64 rows 6 ways of the directory have been moved into normal logic latches and are supplemented with two more bits per cache line the TX read and TX dirty bits.

The TX read bits are reset when a new outermost TBEGIN is decoded which is interlocked against a prior still pending transaction . The TX read bit is set at execution time by every load instruction that is marked transactional in the issue queue. Note that this can lead to over marking if speculative loads are executed for example on a mispredicted branch path. The alternative of setting the TX read bit at load completion time was too expensive for silicon area since multiple loads can complete at the same time requiring many read ports on the load queue.

Stores execute the same way as in non transactional mode but a transaction mark is placed in the store queue STQ entry of the store instruction. At write back time when the data from the STQ is written into the L1 the TX dirty bit in the L1 directory is set for the written cache line. Store write back into the L1 occurs only after the store instruction has completed and at most one store is written back per cycle. Before completion and write back loads can access the data from the STQ by means of store forwarding after write back the CPU can access the speculatively updated data in the L1 . If the transaction ends successfully the TX dirty bits of all cache lines are cleared and also the TX marks of not yet written stores are cleared in the STQ effectively turning the pending stores into normal stores.

On a transaction abort all pending transactional stores are invalidated from the STQ even those already completed. All cache lines that were modified by the transaction in the L1 that is have the TX dirty bit on have their valid bits turned off effectively removing them from the L1 cache instantaneously.

The architecture requires that before completing a new instruction the isolation of the transaction read and write set is maintained. This isolation is ensured by stalling instruction completion at appropriate times when XIs are pending speculative out of order execution is allowed optimistically assuming that the pending XIs are to different addresses and not actually cause a transaction conflict. This design fits very naturally with the XI vs completion interlocks that are implemented on prior systems to ensure the strong memory ordering that the architecture requires.

When the L1 receives an XI L1 accesses the directory to check validity of the XI ed address in the L1 and if the TX read bit is active on the XI ed line and the XI is not rejected the LSU triggers an abort. When a cache line with active TX read bit is LRU ed from the L1 a special LRU extension vector remembers for each of the 64 rows of the L1 that a TX read line existed on that row. Since no precise address tracking exists for the LRU extensions any non rejected XI that hits a valid extension row the LSU triggers an abort. Providing the LRU extension effectively increases the read footprint capability from the L1 size to the L2 size and associativity provided no conflicts with other CPUs against the non precise LRU extension tracking causes aborts.

The store footprint is limited by the store cache size the store cache is discussed in more detail below and thus implicitly by the L2 size and associativity. No LRU extension action needs to be performed when a TX dirty cache line is LRU ed from the L1 .

In prior systems since the L1 and L2 are store through caches every store instruction causes an L3 store access with now 6 cores per L3 and further improved performance of each core the store rate for the L3 and to a lesser extent for the L2 becomes problematic for certain workloads. In order to avoid store queuing delays a gathering store cache had to be added that combines stores to neighboring addresses before sending them to the L3 .

For transactional memory performance it is acceptable to invalidate every TX dirty cache line from the L1 on transaction aborts because the L2 cache is very close 7 cycles L1 miss penalty to bring back the clean lines. However it would be unacceptable for performance and silicon area for tracking to have transactional stores write the L2 before the transaction ends and then invalidate all dirty L2 cache lines on abort or even worse on the shared L3 .

The two problems of store bandwidth and transactional memory store handling can both be addressed with the gathering store cache . The cache is a circular queue of 64 entries each entry holding 128 bytes of data with byte precise valid bits. In non transactional operation when a store is received from the LSU the store cache checks whether an entry exists for the same address and if so gathers the new store into the existing entry. If no entry exists a new entry is written into the queue and if the number of free entries falls under a threshold the oldest entries are written back to the L2 and L3 caches.

When a new outermost transaction begins all existing entries in the store cache are marked closed so that no new stores can be gathered into them and eviction of those entries to L2 and L3 is started. From that point on the transactional stores coming out of the LSU STQ allocate new entries or gather into existing transactional entries. The write back of those stores into L2 and L3 is blocked until the transaction ends successfully at that point subsequent post transaction stores can continue to gather into existing entries until the next transaction closes those entries again.

The store cache is queried on every exclusive or demote XI and causes an XI reject if the XI compares to any active entry. If the core is not completing further instructions while continuously rejecting XIs the transaction is aborted at a certain threshold to avoid hangs.

The LSU requests a transaction abort when the store cache overflows. The LSU detects this condition when it tries to send a new store that cannot merge into an existing entry and the entire store cache is filled with stores from the current transaction. The store cache is managed as a subset of the L2 while transactionally dirty lines can be evicted from the L1 they have to stay resident in the L2 throughout the transaction. The maximum store footprint is thus limited to the store cache size of 64 128 bytes and it is also limited by the associativity of the L2 . Since the L2 is 8 way associative and has 512 rows it is typically large enough to not cause transaction aborts.

If a transaction aborts the store cache is notified and all entries holding transactional data are invalidated. The store cache also has a mark per doubleword 8 bytes whether the entry was written by a NTSTG instruction those doublewords stay valid across transaction aborts.

Traditionally IBM mainframe server processors contain a layer of firmware called millicode which performs complex functions like certain CISC instruction executions interruption handling system synchronization and RAS. Millicode includes machine dependent instructions as well as instructions of the instruction set architecture ISA that are fetched and executed from memory similarly to instructions of application programs and the operating system OS . Firmware resides in a restricted area of main memory that customer programs cannot access. When hardware detects a situation that needs to invoke millicode the instruction fetching unit switches into millicode mode and starts fetching at the appropriate location in the millicode memory area. Millicode may be fetched and executed in the same way as instructions of the instruction set architecture ISA and may include ISA instructions.

For transactional memory millicode is involved in various complex situations. Every transaction abort invokes a dedicated millicode sub routine to perform the necessary abort steps. The transaction abort millicode starts by reading special purpose registers SPRs holding the hardware internal abort reason potential exception reasons and the aborted instruction address which millicode then uses to store a TDB if one is specified. The TBEGIN instruction text is loaded from an SPR to obtain the GR save mask which is needed for millicode to know which GRs to restore.

The CPU supports a special millicode only instruction to read out the backup GRs and copy them into the main GRs . The TBEGIN instruction address is also loaded from an SPR to set the new instruction address in the PSW to continue execution after the TBEGIN once the millicode abort sub routine finishes. That PSW may later be saved as program old PSW in case the abort is caused by a non filtered program interruption.

The TABORT instruction may be millicode implemented when the IDU decodes TABORT it instructs the instruction fetch unit to branch into TABORT s millicode from which millicode branches into the common abort sub routine.

The Extract Transaction Nesting Depth ETND instruction may also be millicoded since it is not performance critical millicode loads the current nesting depth out of a special hardware register and places it into a GR . The PPA instruction is millicoded it performs the optimal delay based on the current abort count provided by software as an operand to PPA and also based on other hardware internal state.

For constrained transactions millicode may keep track of the number of aborts. The counter is reset to 0 on successful TEND completion or if an interruption into the OS occurs since it is not known if or when the OS will return to the program . Depending on the current abort count millicode can invoke certain mechanisms to improve the chance of success for the subsequent transaction retry. The mechanisms involve for example successively increasing random delays between retries and reducing the amount of speculative execution to avoid encountering aborts caused by speculative accesses to data that the transaction is not actually using. As a last resort millicode can broadcast to other CPUs to stop all conflicting work retry the local transaction before releasing the other CPUs to continue normal processing. Multiple CPUs must be coordinated to not cause deadlocks so some serialization between millicode instances on different CPUs is required.

In various embodiments the present invention introduces into the hardware TM environment a suite of machine instructions for communicating between processors as to the transactional memory status of the various processors. Broadly a TPROBE instruction provides a mechanism by which any processor in the system can check the transactional status of a given memory location. Complementarily a TSPROBE instruction provides a mechanism by which a processor may determine if any other processors have within a given predetermined period before present issued a TPROBE. At a coarser level of granularity a TQUERY instruction provides a mechanism by which a processor may determine whether there are any transactions going on in the system or in a given subset of processors within the system. Additionally XI Probe is disclosed as a cross interrogate XI that may in some embodiments implement TPROBE and TSPROBE.

Referring still to the embodiment depicted in the probe request may optionally include an argument by which the probe request includes a memory location within the memory . The argument may be omitted in various implementations that do not require one or more specific memory locations to be identified. The memory in the depicted embodiment may be understood as shared cache main memory shared memory general memory or more broadly any memory region device or article that may be accessed by the first processor and the additional processors such that the potential for a conflict exists. In one contemplated embodiment the memory location i.e. the contents of one more addresses in main memory is stored in one or more cache lines of shared cache subject to the hardware TM s coherence protocol such that any processor of the computer system may operate on the memory location with full coherence support in accordance with the modified MESI protocol or another coherence protocol and with the assurance that no load or store operation on any processor may access the location that corresponds to the cache line in main memory or another resource. As described above various contemplated implementations of hardware TM treat memory access conflicts as a transaction abort conditions and thus preventing memory access conflicts may directly lead to reduced aborts and improved performance of the computer system . In particularly contemplated embodiments the memory location is stored in one or more cache lines.

Referring still to the embodiment depicted in the additional processors respond to the TPROBE by sending an indication back to the first processor . Transmission of the indication may be accomplished by any available path or mechanism. The content of the indication may be whether the receiving processor is using the referenced memory location .

In the depicted embodiment the first processor may initialize and store a time record at various times. The time record may represent a real world time value and may be a system timestamp relative to a fixed time such as the UNIX epoch or relative to a variable time reference such as system start time or other event. The time record may be of nanosecond precision or other timescale suitable for measuring cycles or instructions of the one or more processors of the computer system . Alternatively the time reference may include a count of cycles or instructions of the computer system or its processors without reference to real world time. The first processor may initialize or reset the time record at various times as described in further detail below for example when initiating a new transaction with a TBEGIN instruction or when executing a TSPROBE instruction again thus referring to the time since last executing a TSPROBE.

Referring still to the embodiment of the TSPROBE program depicted in the first processor may maintain a probe log . The probe log may be implemented in main memory cache registers or a dedicated private storage circuit. The first processor may record in the probe log each instance of TPROBE or other probe request that it receives. At a minimum the TSPROBE program may maintain in the probe log a count of probe requests that are received. In other embodiments the probe log may include records of the memory location s referenced in each probe request when each probe request occurred and or which additional processor each probe request originated from.

Thus the TSPROBE program may generate based on the probe log a probe report indication which may be returned as the result of executing the TSPROBE instruction. The probe report indication includes in more generic embodiments whether any TPROBEs have been received from other processors. In alternative embodiments the probe report indication includes also based on the probe log whether any TPROBEs have been received that were directed to any memory location of a current transaction read set or write set. In additional alternative embodiments the probe report indication includes also based on the probe log whether any TPROBES have been received that were directed to an arbitrary memory location. Such an arbitrary memory location may be included as an argument to the TSPROBE instruction.

In some embodiments LPARs may be implemented with strong separation on interprocessor communication such that the various processors may only communicate with and access shared resources for their own LPAR. Similarly LPARs may be created by software convention in systems that do not otherwise implement them. As to such implementations discloses a case where the transaction query is sent from P to the processor set but where the processor set is limited to LPARA which includes P along with PA and PB. Thus the processor set may include all processors sharing a logical partition A with the first processor . Similarly the processor set may include more than one LPAR but fewer than all of the LPARs. PC PD up to PE belong to different LPARs and thus do not receive the transaction query .

Referring still to the embodiment depicted in a transaction category scheme generally includes allowing an argument to a TBEGIN instruction whereby a label for example a numeric value may be assigned to the transaction that is started. The labels may be may be accessed and assigned at the software layer. The transaction category scheme may be maintained by at least one mechanism selected from the group consisting of a a software convention b an operating system application programming interface and c a hypervisor application programming interface. In an exemplary usage each category identifier may be associated with a data structure . The data structure may generally be any software data structure that is created at the software level and exists in memory more specifically the data structure may include at least one data structure selected from the group consisting of a a lock b a semaphore c a queue a stack e a linked list and f a hash table. Software may be configured to assign to any transactions that operate on the data structure s underlying memory locations a given category Category X . In some embodiments the TQUERY program may accept a wildcard variable or expression as an argument such that more than one category may be matched by the same TQUERY.

Referring still to the embodiment depicted in the transaction query includes a query category identifier which may be specified as an argument to the TQUERY program. In the depicted embodiment the content of the indication is whether the particular processor PA PE is engaged in a transaction of Category X . Thus via TQUERY it is possible to expose to the software layer whether the memory underlying the data structure is in use from which a developer may infer that the data structure itself is in use and thus accessing it should be delayed.

In some embodiments the transactional memory environment may have as a feature the behavior described above that transactions are aborted in response to detected attempts to access a shared resource via an XI. Distinctly in various embodiments of TPROBE TSPROBE and TQUERY as well as embodiments of XI Probe the additional processors do not detect any access to the memory location . Specifically the additional processors do not interpret the probe request or the transaction query as an abort condition.

Referring now to is a flowchart diagram depicting the operational steps of a TPROBE program in accordance with at least one embodiment of the invention. At step the TPROBE program identifies a memory location. The memory location may be identified in the execution request to TPROBE and may be generally understood as a memory location that is of interest at the software layer. At step the TPROBE program sends the probe request from the first processor to the one or more additional processors including at step the memory location via the argument .

The TPROBE program may but need not be implemented by an embodiment of the XI Probe program. Thus the probe request may include a cross interrogate. In such embodiments the TPROBE program may execute step sending an XI Probe by calling the XI Probe program either as a micro op millicode invoking dedicated hardware or otherwise.

Referring still to the flowchart for an embodiment of the TPROBE program of at step the TPROBE program generates the indication by each of the one or more additional processors . The indication includes whether the memory location is in use for a transaction on the particular responding additional processor . At step each additional processor determines whether the memory location is in use for a transaction by that processor .

At step the additional processors do not detect any access to the memory location . Equivalently the additional processors do not interpret the probe request as an abort condition.

The current transaction may have associated therewith a read set and a write set. The indication may include whether the memory location is in use for the current transaction read set write set or both with at least one of the read set or the write set each including one or more memory locations. Each of the one or more memory locations may include one or more cache lines. In some embodiments the indication may include at least one communication mechanism selected from the group consisting of a status code a condition code and a flag setting. Where the indication includes a status code the status code may be represented by two bits and which each additional processor may set at step . displays a table of exemplary two bit status codes for use in a TPROBE program. The two bits may be in any one state selected from the group consisting of state 00 state 01 state 10 and state 11. As shown in the table of state 00 may denote that the memory location is not in use for the transaction. State 01 may denote that the memory location is in use for the read set. State 10 may denote that the memory location is in use for the write set. State 11 may denote that the memory location is in use for both the read set and the write set.

At step the TPROBE program sends the indication from the one or more additional processors to the first processor . At step the first processor proceeds based on the indication . In particular the first processor may combine the status codes and make them available to the software layer or the first process may be instructed to branch based on the indication . displays a segment of assembly language like pseudocode which shows how a TPROBE program may be executed as a machine instruction.

In the pseudocode program of the TPROBE instruction is executed as to two memory locations A and B. After each TPROBE statement a BRNZ Break if Not Zero instruction is executed as to the result of TPROBE with a reference back to a label PROBE AGAIN. In the above described status code scheme the state 00 denotes that the memory location is not in use and any nonzero status indicates that the memory location is in use. The TPROBEs are followed by a simple transaction that swaps the contents of memory locations A and B by loading each into registers 1 and 2 respectively and storing back in reverse order. The effect of the BRNZ instructions with respect to the TPROBEs is to check whether first memory location A and then memory location B are in use by other processors on the system and to repeatedly check until the memory locations become available and then to conduct the transaction. The example memory location swapping transaction is simple and short however the TPROBE program may be understood as of relatively greater utility the more complex and lengthy the planned transaction is because preventing an abort condition is of greater value for more complex longer transactions.

Referring now to is a flowchart diagram depicting the operational steps of a TSPROBE program in accordance with at least one embodiment of the invention. At step the first processor initializes the time record . At step the first processor listens for one or more probe requests such as TPROBES that originate from the one or more additional processors . The TSPROBE program may be understood as implemented by an embodiment of the XI Probe cross interrogate. Specifically TSPROBE may be understood as listening for TPROBEs which are implemented in hardware as XI Probe cross interrogates.

At step the first processor responds to each probe request of the one or more probe requests such as TPROBEs that it receives. At step the first processor sends the indication as in TPROBE or it otherwise replies appropriately to another probe request . At step the first processor logs each TPROBE or other probe request of the zero or more TRPOBEs or other probe requests as they are received to yield the probe log . In the depicted embodiment of TSPROBE the first processor continues listening for probe requests until at step the first processor receives e.g. from software a probe report directive. The probe report directive may be the execution of the TSPROBE instruction another instruction or other indication from the software layer to return data based on the probe log . Responsive to the probe report directive the first processor may generate the probe report indication . At step the probe report indication includes whether since the time record the first processor has received any probe request such as a TPROBE as indicated in the probe log . In various embodiments the probe report indication may include at least one communication mechanism selected from the group consisting of a status code a condition code and a flag setting. At step the first processor may end the time record a new time record may be initialized immediately or at a later time such that subsequent executions of TSPROBE may refer to the newly initialized time record. The time record may be understood as the moment in time at which the relevant interval for embodiments of the TSPROBE program begins. Ending the time record at step may be understood as actively closing the relevant interval for embodiments of the TSPROBE program. Ending the time record need not be equivalent to resetting or re initializing the time record .

With regard to embodiments of the TSPROBE program generally it should be noted that the contemplated probe request is a TPROBE from another processor and in the claims a TPROBE and a generic probe request are referred to as probes . Specifically each of the one or more probes received by the first processor in TSPROBE may include the execution of a TPROBE in the claims t probe by one of the one or more additional processors .

Referring now to is a flowchart diagram depicting the operational steps of a TSPROBE program as used in the context of a transaction on the first processor in accordance with at least one embodiment of the invention. At step the first processor initializes the time record by initiating a transaction with TBEGIN step and recording when the transaction is initiated by setting the time record to the time of TBEGIN for the transaction. At step the first processor proceeds with the transaction assigning memory locations to the read set and write set associated therewith. At least one of the read set or the write set includes one or more memory locations. At step analogous to step the first processor listens for TPROBEs or other probe requests from the additional processors .

At step similar to step the first processor acts responsively to each TPROBE received. At step similar to step the first processor replies appropriately to each TPROBE or other probe request . At step similar to step the first processor logs the probe requests in the probe log as they are received. The first processor continues listening for probe requests until at step similar to step the first processor receives a probe report directive such as a TSPROBE instruction.

Referring still to the flowchart for an embodiment of the TSPROBE program of at step the probe report indication denotes whether since the time record the first processor has received any TPROBE or other probe request that was directed to any memory location in the read set write set or both the read set and the write set for the transaction on the first processor . Where as depicted TSPROBE is executed in the context of a transaction on the first processor the period since the time record may include the period since initiating the transaction on the first processor . At step the first processor ends the time record which may include terminating the current transaction with a TEND instruction.

In some embodiments of TSPROBE the probe report indication may include a status code. The status code may be represented by two bits. displays a table of exemplary two bit status codes for use in a TPROBE program. The two bits may be in any one state selected from the group consisting of state 00 state 01 state 10 and state 11. As shown in the table of state 00 may denote that none or the zero or more TPROBEs or other probe requests received by the first processor since the time record were directed to any memory location in the read set or the write set for the current transaction. State 01 may denote that at least one of the zero or more TPROBEs or other probe requests received by the first processor since the time record was directed to at least one memory location of the read set for the current transaction. State 10 may denote that at least one of the zero or more TPROBEs or other probe requests received by the first processor since the time record was directed to at least one memory location of the write set for the current transaction. State 11 may denote that at least one of the zero or more TPROBEs or other probe requests received by the first processor since the time record was directed to at least one memory location of the write set for the current transaction.

At step the TSPROBE program returns the probe report indication which may be made available to the software layer. In particular presents a segment of C like pseudocode that demonstrates how an embodiment TSPROBE may be executed from the software layer. It should be noted that TSPROBE may be embodied as a machine instruction not normally directly accessible to high level code such as the C like pseudocode of however for purposes of the presented pseudocode the TSPROBE instructions as well as other instructions from the transactional instruction set architecture TBEGIN TEND and TABORT may be understood as wrapped in corresponding functions or otherwise made available at the software level.

The pseudocode of may be understood as part of a thread to be executed on the first processor . At line 01 a transaction with TBEGIN. From line 02 the program iterates over a list searching for a defined Element line 04 the current element represented by the variable p initialized at line 01 . The program keeps a variable count lines 02 09 of the number of iterations and each iteration it applies a test to p data to determine whether p is equal to the Element of interest line 04 . If p is the correct Element then some processing occurs and the program ends the transaction with TEND and branches out of loop lines 05 06 .

Referring still to the pseudocode of if count grows to exceed a given value in this case ten line 10 then TSPROBE is executed. The inference represented by line 10 is that if the Element is not found quickly then the transaction is likely to take a long time and the program should attempt to ascertain whether the list iterated over by the variable p is wanted for another perhaps faster transaction. If other probes are detected line 11 for example by a nonzero return value from TSBROBE then the transaction is ended with TABORT line 12 and the program handles the abort condition as appropriate line 13 . If no probes are detected then the transaction can proceed through the next iteration. If the Element is neither found p NULL line 03 nor any probe detected then the transaction exits normally with TEND line 17 .

Referring now to displays a flowchart diagram for a TSPROBE program configured for execution outside of a transaction and as to a specific memory location in accordance with at least one embodiment of the invention. For the embodiment depicted in the intended usage of TSPROBE is broadly to test whether any probe has been issued as to one or more specified memory locations before accessing them whether in the context of a transaction or not. The corresponding inference is that if a probe has been issued as to the one or more memory locations then the one or more memory locations are likely to soon or already be in use for a transaction on one of the additional processors .

Referring still to the embodiment depicted in at step the first processor initializes the time record . At step the TSPROBE program identifies one or more memory locations. At step analogous to step the first processor listens for TPROBEs or other probe requests from the additional processors . At step similar to step the first processor acts responsively to each TPROBE received. At step similar to step the first processor replies appropriately to each TPROBE or other probe request . At step similar to step the first processor logs the probe requests in the probe log as they are received. The first processor continues listening for probe requests until at step similar to step the first processor receives a probe report directive such as a TSPROBE instruction.

At step the TSPROBE program generates the probe report indication . The probe report indication denotes whether since the time record the first processor has received any of the zero or more TPROBEs or other probe requests directed to the one or more memory locations. At step analogous to step the first processor ends the time record .

Referring now to the XI Probe program the XI Probe program may implement TPROBE and TSPROBE in accordance with some embodiments of the present invention. As an XI XI Probe may be executed within a machine instruction as a micro op millicode instruction or other sub instruction operation. General embodiments of XI Probe may communicate between processors via the L4 cache A C and in general additional processors when receiving an XI Probe may respond without aborting any current transaction or otherwise detecting a read on the current transaction read set or write set regardless of what memory locations are referenced by the XI Probe.

Referring still to the embodiment of XI Probe depicted in the XI Probe program receives by the one or more additional processors the cross interrogate . At step the XI Probe program generates by each of the additional processors the indication . At step and as per the XI Probe program includes not aborting by the one or more additional processors any current transaction based on the cross interrogate . At step each additional processor determines whether the memory location is in use for a current transaction such that each indication includes whether the memory location is in use for the current transaction by that of the one or more additional processors .

Each indication may be represented by two bits. The two bits may be in any one state selected from the group consisting of state 00 state 01 state 10 and state 11. displays a table of exemplary two bit codes that may represent the indication for a single additional processor in an embodiment of XI Probe. In the exemplary code scheme of a current transaction on the particular additional processor has associated therewith a read set and write set and at least one of the read set and the write set includes one or more memory locations. As shown in the table of state 00 may denote that the memory location is not in use by that of the one or more processors for the current transaction. State 01 may denote that the memory location is in use by that of the one or more additional processors for the read set of the current transaction. State 10 may denote that the memory location is in use by that of the one or more additional processors for the write set of the current transaction. State 11 may denote that the memory location is in use by that of the one or more additional processors for both the read set and the write set of the current transaction.

Referring still to the embodiment of XI Probe depicted in the XI Probe program at step sends the indication from each of the one or more additional processors to the first processor. At step the XI Probe program may combine by the first processor each indication from the one or more additional processors to yield a status code. The XI Probe program may return the status code to the calling machine instruction or otherwise make the status code available. In one embodiment the status code may be determined by applying a boolean or operation to the two bits of the indication for each of the one or more additional processors . Thus the combined status code may capture any transaction in the computer system that uses the memory location .

The XI Probe program may also implement TSPROBE as depicted in the flowchart diagram of . The depiction may be extended to embodiments of TSPROBE that identify one or more memory locations including both arbitrary memory locations and memory locations associated with the read set or write set of a transaction as well as embodiments that do not identify any memory location. In the embodiment of each additional processor initializes a time record at step . As discussed above the time record may mark the start of a current transaction the time of last executing TSPROBE or an arbitrary time. Each additional processor receives a cross interrogate at step by receiving a directive via L4 cache at step . Each additional processor identifies the memory location passed by the XI from the directive in L4 cache at step .

Referring still to the flowchart for an embodiment of XI Probe of at step each additional processor responds to the XI. At step each of the one or more additional processors generate the indication which includes whether the particular additional processor has the XI identified memory location in use for a transaction. At step the additional processor does not cause an abort of any current transaction in response to the XI . At step each additional processor records the cross interrogate in its probe log. At step the indication may be sent from each additional processor to the first processor completing each additional processor s response to the XI. At step each additional processor waits for and responds to a probe report directive e.g. a TSPROBE instruction . Responding to the probe report directive may include returning by that of the one or more additional processors a probe report indication. The probe report indication includes whether since the time record that of the one or more additional processors has received at least one instance of the cross interrogate.

Referring now to displays a flowchart diagram for a TQUERY program in accordance with at least one embodiment of the invention. The TQUERY program may operate in a hardware TM environment including a plurality of processors. The transactional memory environment may support one or more transactions by the first processor and the processor set. The plurality of processors may be understood as including the first processor and a processor set. The processor set includes one or more additional processors A E. As above the processor set may include all processor in the computer system all processors on the same LPAR LPARA as the first processor or a differently defined subset.

In embodiments wherein the transactional memory environment supports a transaction category scheme at step the TQUERY program may identify a query category identifier which may be received from the software layer as an argument to the TQUERY machine instruction. At step the TQUERY program may send the transaction query from the first processor to the processor set. For embodiments with transaction category support the transaction query may include the query category identifier this may be achieved by reference at step .

Referring still to the embodiment depicted in the TQUERY program generates by each additional processor A E in the processor set the indication . The indication includes whether the additional processor A E is executing a transaction. The TQUERY program determines this at step . For embodiments that support a transaction category scheme at step each additional processor A E determines whether the category identifier of the current transaction matches the query category identifier . Thus the indication may include whether the category identifier of the current transaction matches the query category identifier .

Referring still to the embodiment depicted in the TQUERY program at step sends the indication from each additional processor A E in the processor set to the first processor . The indications may be combined at the first processor into a status code denoting whether any transaction anywhere on the computer system was detected by the TQUERY which may be made available to the software layer. More generally at step the first processor may proceed based on the indication .

Depicted within the processor is the transactional instruction set architecture ISA . The transactional ISA may be understood as including all of the machine instructions provided for the operation of the computer system with its transactional memory environment including LOAD and STORE instructions arithmetic instructions TBEGIN and TEND. Included within the Transactional ISA may be one or more of the methods of the present invention to be executed as a machine instruction including a TPROBE machine instruction a TSPROBE machine instruction and a TQUERY machine instruction .

Also depicted within the processor are the cross interrogates XIs including XI Probe which as defined above may be sub instruction operations of the processor embodied for example as millicode procedures micro ops or directly in circuitry that enable communications between cache levels or between processors. In some embodiments as above interprocessor XIs communicate via one or more L4 caches of the various processors or between different L4 caches of the same processor . In particular the XI Probe XI may be executed as a micro op or otherwise. The XI Probe XI may be further configured to implement various machine instructions including the TPROBE machine instruction the TSPROBE machine instruction and the TQUERY instruction .

As depicted the computer operates over a communications fabric which provides communications between the computer processor s memory persistent storage communications unit and input output I O interface s . The communications fabric may be implemented with any architecture suitable for passing data or control information between the processors e.g. microprocessors communications processors and network processors the memory the external devices and any other hardware components within a system. For example the communications fabric may be implemented with one or more buses.

The memory and persistent storage are computer readable storage media. In the depicted embodiment the memory comprises a random access memory RAM and a cache . In general the memory may comprise any suitable volatile or non volatile one or more computer readable storage media.

Program instructions for the disclosed programs may be stored in the persistent storage or more generally any computer readable storage media for execution by one or more of the respective computer processors via one or more memories of the memory . The persistent storage may be a magnetic hard disk drive a solid state disk drive a semiconductor storage device read only memory ROM electronically erasable programmable read only memory EEPROM flash memory or any other computer readable storage media that is capable of storing program instructions or digital information.

The media used by the persistent storage may also be removable. For example a removable hard drive may be used for persistent storage . Other examples include optical and magnetic disks thumb drives and smart cards that are inserted into a drive for transfer onto another computer readable storage medium that is also part of the persistent storage .

The communications unit in these examples provides for communications with other data processing systems or devices. In these examples the communications unit may comprise one or more network interface cards. The communications unit may provide communications through the use of either or both physical and wireless communications links. In the context of some embodiments of the present invention the source of the various input data may be physically remote to the computer such that the input data may be received and the output similarly transmitted via the communications unit .

The I O interface s allow for input and output of data with other devices that may operate in conjunction with the computer . For example the I O interface may provide a connection to the external devices which may be as a keyboard keypad a touch screen or other suitable input devices. External devices may also include portable computer readable storage media for example thumb drives portable optical or magnetic disks and memory cards. Software and data used to practice embodiments of the present invention may be stored on such portable computer readable storage media and may be loaded onto the persistent storage via the I O interface s . The I O interface s may similarly connect to a display . The display provides a mechanism to display data to a user and may be for example a computer monitor.

A computer system suitable for executing the TPROBE program TSPROBE program XI Probe program TQUERY program or category TQUERY program according to at least one embodiment of this invention comprises a processing circuit comprising one or more processors including one or more computer processors one or more computer readable storage media and communications mechanisms between those and other parts of the computer. The possible forms of computer readable storage media comprise persistent storage components such as the hard disks main memory components cache components registers and other storage media components in the processing circuit online storage components and offline bulk storage components.

The computer implemented method computer program product and computer system that embody the present invention as described herein may be implemented in machine hardware using logic circuits processing circuits millicode firmware and other machine level computing elements. Those skilled in the art of designing computing machines and machine elements will be able to generate machine components designs and machine components that implement the program instructions disclosed herein.

In some embodiments transactional memory environment in which the invention is implemented is characterized by a behavior that a transactional abort is triggered by a conflict trigger action as to a conflict transaction. The conflict transaction may be any transaction on any of the several processors of the system and may include a conflict read set and a conflict write set. Various conflict trigger actions may be configured to cause an abort including at least where the conflict trigger action is selected from the group consisting of a when one or more processors load from the conflict write set of the conflict transaction or store to the conflict read set or conflict write set of the conflict trigger transaction.

Various embodiments of the invention may be implemented in a data processing system suitable for storing and or executing program code that includes at least one processor including at least one computer processor coupled directly or indirectly to memory elements through a system bus. The memory elements include for instance local memory employed during actual execution of the program code bulk storage and cache memory which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input Output or I O devices including but not limited to keyboards displays pointing devices DASD tape CDs DVDs thumb drives and other memory media etc. can be coupled to the system either directly or through intervening I O controllers. Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modems and Ethernet cards are just a few of the available types of network adapters.

One or more aspects of the present invention can be included in an article of manufacture e.g. a computer program product or combination of two or more computer program products having for instance computer usable media or computer readable storage media. The media has therein for instance computer readable program code means or logic e.g. instructions code commands etc. to provide and facilitate the capabilities of the present invention. The computer readable storage media store instructions including program instructions or computer program instructions. The article of manufacture can be included as a part of a system e.g. computer system or sold separately.

One example of an article of manufacture or a computer program product incorporating one or more aspects of the present invention includes for instance one or more computer usable media to store computer readable program code means or logic thereon to provide and facilitate one or more aspects of the present invention. The computer readable storage medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

A sequence of program instructions or a logical assembly of one or more interrelated modules defined by one or more computer readable program code means or logic direct the performance of one or more aspects of the present invention.

Although one or more examples have been provided herein these are only examples. Many variations are possible without departing from the spirit of the present invention. For instance processing environments other than the examples provided herein may include and or benefit from one or more aspects of the present invention. Further the environment need not be based on the z Architecture but instead can be based on other architectures offered by for instance IBM Intel Sun Microsystems as well as others. Yet further the environment can include multiple processors be partitioned and or be coupled to other systems as examples.

As used herein the term obtaining includes but is not limited to fetching receiving having providing being provided creating developing etc.

The capabilities of one or more aspects of the present invention can be implemented in software firmware hardware or some combination thereof. At least one program storage device readable by a machine embodying at least one program of instructions executable by the machine to perform the capabilities of the present invention can be provided.

The flow diagrams depicted herein are just examples. There may be many variations to these diagrams or the steps or operations described therein without departing from the spirit of the invention. For instance the steps may be performed in a differing order or steps may be added deleted or modified. All of these variations are considered a part of the claimed invention.

Although preferred embodiments have been depicted and described in detail herein it will be apparent to those skilled in the relevant art that various modifications additions substitutions and the like can be made without departing from the spirit of the invention and these are therefore considered to be within the scope of the invention as defined in the following claims.

