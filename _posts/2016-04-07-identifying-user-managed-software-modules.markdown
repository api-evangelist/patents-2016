---

title: Identifying user managed software modules
abstract: A method for identifying user managed software modules includes: receiving a request for a directed load of a software module into memory, wherein the request includes an address for storing the software module; storing the software module at the address in the received request; adding a name and an address range of the stored software module to a data structure identifying software modules that have been loaded into memory via directed loads; receiving a query that includes an input module name or an input address range; and responsive to determining that the input module name or input address range of the received query is not stored in one or more data structures identifying one or more software modules that have been loaded into memory without directed loads, searching the data structure identifying software modules that have been loaded into memory via directed loads for the respective query.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09495149&OS=09495149&RS=09495149
owner: International Business Machines Corporation
number: 09495149
owner_city: Armonk
owner_country: US
publication_date: 20160407
---
The present invention relates generally to the field of memory management and more particularly to user managed or directed loading of software modules.

There are a plurality of known ways for computer operating systems to load software modules into storage for example persistent storage and or memory . For example during a normal load process a system decides where and how to allocate the dynamic storage to fetch the module into from disk. On the other hand during a directed load process a caller of the module provides the location of the storage for the module to be loaded into i.e. the caller directs the system where to put the module once the module is fetched from disk.

Embodiments of the present invention disclose a method computer program product and system for identifying user managed software modules. The method includes receiving a request for a directed load of a software module into memory wherein the request for the directed load includes an address for storing the software module. The method further includes storing the software module at the address in the received request. The method further includes adding a name and an address range of the stored software module to a data structure identifying software modules that have been loaded into memory via directed loads. The method further includes receiving a query that includes an input module name or an input address range. The method further includes responsive to determining that the input module name or input address range of the received query is not stored in one or more data structures identifying one or more software modules that have been loaded into memory without directed loads searching the data structure identifying software modules that have been loaded into memory via directed loads for the respective input module name or input address range.

Embodiments in accordance with the present invention recognize that operating systems may provide users with the ability to manage the storage of software modules after they are loaded. This is sometimes referred to as a directed load or a load with address . When a directed load is used because the system does not track the module as much as it does for a non directed load in situations for which it may be helpful to find the name of the module in which a given address resides it may be difficult to determine that module name without manually examining storage. Embodiments of the present invention improve the functionality of the operating system in this area by taking advantage of data that the operating system may already keep to facilitate the determination of the module name. In cases where system services may be used to correlate a given address to a module tracked by one or more system control blocks embodiments of the present invention enhance system services so that when the module cannot be found via the system control blocks the system services optionally attempt to use the directed load results to locate the information.

Embodiments in accordance with the present invention will now be described in detail with reference to the Figures. is a functional block diagram generally designated illustrating a directed load environment in an embodiment in accordance with the present invention.

Directed load environment includes server and other computing devices not shown all interconnected over network . Server includes random access memory RAM central processing unit CPU and persistent storage . Server may be a Web server or any other electronic device or computing system capable of processing program instructions and receiving and sending data. In some embodiments server may be a laptop computer a tablet computer a netbook computer a personal computer PC a desktop computer a personal digital assistant PDA a smart phone or any programmable electronic device capable of communicating over a data connection to network . In other embodiments server may represent server computing systems utilizing multiple computers as a server system such as in a distributed computing environment. In general server is representative of any electronic devices or combinations of electronic devices capable of executing machine readable program instructions and communicating with service provider via network and with various components and devices not shown within directed load environment .

Server includes persistent storage . Persistent storage may for example be a hard disk drive. Alternatively or in addition to a magnetic hard disk drive persistent storage may include a solid state hard drive a semiconductor storage device read only memory ROM erasable programmable read only memory EPROM flash memory or any other computer readable storage medium that is capable of storing program instructions or digital information. Load software and query software are stored in persistent storage which also includes operating system software not shown as well as software that enables server to load and query modules on the system also referred to as server by users e.g. calling programs and communicate with other computing devices not shown of directed load environment over a data connection on network . In other example embodiments load software and query software may be components of an operating system software.

Load software and query software are computer programs or sets of computer programs that are stored in persistent storage . Load software enables a user to load modules during server runtime and tracks directed loads via directed load table and one or more normal module entries NMEs . Query software may retrieve for an input module name the address range for that module. In computing an address range also referred to as an address space may define a range of discrete addresses each of which may correspond to a network host peripheral device disk sector a memory cell or other logical or physical entity. In other words the address range corresponds to the module s location in storage where the storage can comprise any medium by which software can be stored for example persistent storage volatile memory and or network storage . For applications that use query software if the module cannot be found in NME query software may additionally examine the information in directed load table . If an entry is found for which the queried address lies within the module e.g. using the starting and ending addresses then the module name for that entry may be returned. In other example embodiments query software may allow a user to determine a module s address range using the module name as an input.

Directed load table and one or more data structures called NMEs exist in RAM during system runtime when one or more modules are loaded either by the system or directed loaded by a user i.e. calling program . In an example where NMEs are used a calling program asks server to load a module. Server allocates storage for the module loads the module into the allocated storage then creates an NME to track the allocated storage for the module to allow server to free the storage once the module is no longer needed. Directed load table is used to track the name of a loaded module and the starting and ending addresses also referred to as an address range of the loaded module. In an example where a directed load table is used a calling program allocates storage for a module then the calling program requests server to load the module into the allocated storage. Server then stores the address range of the module in directed load table . The calling program frees the allocated storage once the calling program is done with the module.

Server may include internal and external hardware components as depicted and described in further detail with respect to .

In network is shown as the interconnecting fabric between server and with various components and devices not shown within directed load environment . In practice the connection may be any viable data transport network such as for example a LAN or WAN. Network can be for example a local area network LAN a wide area network WAN such as the Internet or a combination of the two and include wired wireless or fiber optic connections. In general network can be any combination of connections and protocols that will support communications between server and with various components and devices not shown within directed load environment .

Load software receives a request from a calling program to load module X as depicted in step . For example load software may receive the load module request through a set of application programming interfaces APIs used by calling programs executing on sever or from calling programs executing on other computing devices not shown within directed load environment . In computer programming an application programming interface API is a set of routines protocols and tools for building software applications. An API expresses a software component in terms of its operations inputs outputs and underlying types. An API defines functionalities that are independent of their respective implementations which allows definitions and implementations to vary without compromising the interface.

Load software allocates storage and loads module X into that storage in step . For example load software allocates storage via a new operation in RAM to contain module X and then loads module X in the allocated storage. In other example embodiments allocated storage in RAM may be performed using any dynamic memory allocation technique.

Load software builds a control structure to track the load and the address range of module X in step . For example load software allocates storage to create a new NME control block to track the load and address range of module X . In other example embodiments load software may create a NME prior to creating the storage space for module X then store the address range of module X upon the load of module X .

In decision step load software determines if the calling program is ready to free module X . For example load software either determines or is told by the calling program that the address range for module X is ready to be freed. Upon determining the calling program no longer requires module X load software may free the allocated storage so that the address range or address range of module X may be reused as depicted in step .

A calling program allocates storage in RAM to load module x as depicted in step . The calling program may use any known or yet to be known allocation method including those described in relation to step .

Upon allocating the address range for module X load software receives a request from the calling program indicating to load module X into the allocated storage as depicted in step . In other example embodiments load software may receive the load module request from a queue monitored by load software . In computer science a queue is a particular kind of abstract data type or collection in which the entities in the collection are kept in order and the principal or only operations on the collection are the addition and removal of entities from the queue. In an example embodiment the queue is a First In First Out FIFO data structure. In a FIFO data structure the first element added to the queue will be the first one to be removed. In another example embodiment load software may receive the load module request from a stack that uses a Last In First Out LIFO data structure. In a LIFO data structure the last element added to the stack will be the first one to be removed.

In step load software then loads module X into that storage. Load software may take for example the following as inputs i the address of the allocated storage ii the size of module X iii a function or subroutine and or iv a return code or return status of the module load.

Load software then stores the module s address range in a directed load table as depicted in step . Upon loading module X into the address range provided by the calling program load software stores the address range of module X in directed load table to track the storage and allow a calling program to query the module name. If directed load table does not exist load software may create a new instance of directed load table . In some example embodiments directed load table may be created during system initialization. In another example embodiment directed load table may be a table that uses a wrapping feature so that older entries may be replaced when space for newer entries is needed. In other example embodiments directed load table may be a queue of individual elements or a stack or an array.

In decision step the calling program determines if module X is ready to be freed. For example upon determining module X is no longer required the calling program may issue a request to load software to unload module X . Load software may then unload module X and use a previously stored function provided by the calling program to initiate the freeing of the storage or load software may just return a return code or status code indicating whether the unloading of module X was successful or unsuccessful.

In step query software searches one or more NME s to find a match for the corresponding input address of the module provided by the calling program. For example query software searches each NME and compares the stored address range in the NME to the input address provided by the calling program.

In decision step query software determines if the corresponding input address was found in NME . If the corresponding input address was found in NME Yes branch decision query software returns the name of the module stored in NME as depicted in step . If the corresponding input address was not found in NME No branch decision query software checks to see if there is a next NME as depicted in decision step .

In decision step query software determines if there is a next NME in the queue. If there is a next NME in the queue Yes branch decision query software gets the next NME to examine as depicted in step . If there is not a next NME in the queue No branch decision query software returns an indication that no match has been found e.g. module not found to the calling program as depicted in step . In one example embodiment query software may return an error code in the form of a string or in a numerical form. In other example embodiments query software may return additional information in the error messages such as the supplied address range or supplied module name.

In step query software searches NME s as described in for the module using the input address. In decision step query software determines if the corresponding input address was found in NME . If the corresponding input address was found in NME Yes branch decision query software returns the name of the module stored in NME as depicted in step . If the corresponding input address was not found in NME No branch decision query software searches directed load table for the corresponding input address as depicted in step .

In decision step query software determines if the corresponding input address was found in the entry of directed load table . If the corresponding input address was found in the entry of directed load table Yes branch decision query software returns the name of the module stored in the table entry as depicted in step . If the corresponding input address was not found in the entry of directed load table No branch decision query software determines if there is a next entry in directed load table to examine as depicted in decision step . In some cases the directed load table matching may also include a time related element. For example the directed load table might have two entries that cover the same address range an older entry and a newer entry because the table entries are never deleted and the table wraps . In the present embodiment the rule is to use the newer entry.

In decision step query software determines if there is a next entry in directed load table . If there is a next entry in directed load table Yes branch decision query software gets the next entry in directed load table to examine as depicted in step . If there is not a next entry in directed load table No branch decision query software returns module not found to the calling program as depicted in step .

In step query software searches one or more NME s to find a match for the corresponding module name of the input module name provided by the calling program. For example query software searches each NME and compares the stored module name of the NME to the input module name provided by the calling program.

In decision step query software determines if the corresponding input module name was found in NME . If the corresponding input module name was found in NME Yes branch decision query software returns the address range associated with the software module matching the input module name stored in NME as depicted in step . If the corresponding input module name was not found in NME No branch decision query software checks to see if there is a next NME as depicted in decision step .

In decision step query software determines if there is a next NME in the queue. If there is a next NME in the queue Yes branch decision query software gets the next NME to examine as depicted in step . If there is not a next NME in the queue No branch decision query software returns address range not found to the calling program as depicted in step .

In step query software searches NME s as described in for the module. In decision step query software determines if the corresponding input module name was found in NME . If the corresponding module name was found in NME Yes branch decision query software returns the address range of the module stored in NME as depicted in step . If the corresponding input module name was not found in NME No branch decision query software searches directed load table for the corresponding input module name as depicted in step .

In decision step query software determines if the corresponding module name was found in the entry of directed load table . If the corresponding input module name was found in the entry of directed load table Yes branch decision query software returns the address range of the module stored in the table entry as depicted in step . If the corresponding input module name was not found in the entry of directed load table No branch decision query software determines if there is a next entry in directed load table to examine as depicted in decision step .

In decision step query software determines if there is a next entry in directed load table . If there is a next entry in directed load table Yes branch decision query software gets the next entry in directed load table to examine as depicted in step . If there is not a next entry in directed load table No branch decision query software returns address range not found to the calling program as depicted in step .

Server includes communications fabric which provides communications between computer processor s memory persistent storage communications unit and input output I O interface s . Communications fabric can be implemented with any architecture designed for passing data and or control information between processors such as microprocessors communications and network processors etc. system memory peripheral devices and any other hardware components within a system. For example communications fabric can be implemented with one or more buses.

Memory and persistent storage are computer readable storage media. In this embodiment memory which may be similar to RAM includes random access memory RAM and cache memory . In general memory can include any suitable volatile or non volatile computer readable storage media.

Load software and query software are stored in persistent storage for execution and or access by one or more of the respective computer processors via one or more memories of memory . In this embodiment persistent storage includes a magnetic hard disk drive. Alternatively or in addition to a magnetic hard disk drive persistent storage can include a solid state hard drive a semiconductor storage device read only memory ROM erasable programmable read only memory EPROM flash memory or any other computer readable storage media that is capable of storing program instructions or digital information.

The media used by persistent storage may also be removable. For example a removable hard drive may be used for persistent storage . Other examples include optical and magnetic disks thumb drives and smart cards that are inserted into a drive for transfer onto another computer readable storage medium that is also part of persistent storage .

Communications unit in these examples provides for communications with other data processing systems or devices including resources of network not shown . In these examples communications unit includes one or more network interface cards. Communications unit may provide communications through the use of either or both physical and wireless communications links. Load software and query software may be downloaded to persistent storage through communications unit .

I O interface s allows for input and output of data with other devices that may be connected to server . For example I O interface may provide a connection to external devices such as a keyboard keypad a touch screen and or some other suitable input device. External devices can also include portable computer readable storage media such as for example thumb drives portable optical or magnetic disks and memory cards. Software and data used to practice embodiments of the present invention e.g. load software and query software can be stored on such portable computer readable storage media and can be loaded onto persistent storage via I O interface s . I O interface s also connect to a display .

The programs described herein are identified based upon the application for which they are implemented in a specific embodiment of the invention. However it should be appreciated that any particular program nomenclature herein is used merely for convenience and thus the invention should not be limited to use solely in any specific application identified and or implied by such nomenclature.

The present invention may be a system a method and or a computer program product at any possible technical detail level of integration. The computer program product may include a computer readable storage medium or media having computer readable program instructions thereon for causing a processor to carry out aspects of the present invention.

The computer readable storage medium can be a tangible device that can retain and store instructions for use by an instruction execution device. The computer readable storage medium may be for example but is not limited to an electronic storage device a magnetic storage device an optical storage device an electromagnetic storage device a semiconductor storage device or any suitable combination of the foregoing. A non exhaustive list of more specific examples of the computer readable storage medium includes the following a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory a static random access memory SRAM a portable compact disc read only memory CD ROM a digital versatile disk DVD a memory stick a floppy disk a mechanically encoded device such as punch cards or raised structures in a groove having instructions recorded thereon and any suitable combination of the foregoing. A computer readable storage medium as used herein is not to be construed as being transitory signals per se such as radio waves or other freely propagating electromagnetic waves electromagnetic waves propagating through a waveguide or other transmission media e.g. light pulses passing through a fiber optic cable or electrical signals transmitted through a wire.

Computer readable program instructions described herein can be downloaded to respective computing processing devices from a computer readable storage medium or to an external computer or external storage device via a network for example the Internet a local area network a wide area network and or a wireless network. The network may comprise copper transmission cables optical transmission fibers wireless transmission routers firewalls switches gateway computers and or edge servers. A network adapter card or network interface in each computing processing device receives computer readable program instructions from the network and forwards the computer readable program instructions for storage in a computer readable storage medium within the respective computing processing device.

Computer readable program instructions for carrying out operations of the present invention may be assembler instructions instruction set architecture ISA instructions machine instructions machine dependent instructions microcode firmware instructions state setting data configuration data for integrated circuitry or either source code or object code written in any combination of one or more programming languages including an object oriented programming language such as Smalltalk C or the like and procedural programming languages such as the C programming language or similar programming languages. The computer readable program instructions may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider . In some embodiments electronic circuitry including for example programmable logic circuitry field programmable gate arrays FPGA or programmable logic arrays PLA may execute the computer readable program instructions by utilizing state information of the computer readable program instructions to personalize the electronic circuitry in order to perform aspects of the present invention.

Aspects of the present invention are described herein with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer readable program instructions.

These computer readable program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks. These computer readable program instructions may also be stored in a computer readable storage medium that can direct a computer a programmable data processing apparatus and or other devices to function in a particular manner such that the computer readable storage medium having instructions stored therein comprises an article of manufacture including instructions which implement aspects of the function act specified in the flowchart and or block diagram block or blocks.

The computer readable program instructions may also be loaded onto a computer other programmable data processing apparatus or other device to cause a series of operational steps to be performed on the computer other programmable apparatus or other device to produce a computer implemented process such that the instructions which execute on the computer other programmable apparatus or other device implement the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of instructions which comprises one or more executable instructions for implementing the specified logical function s . In some alternative implementations the functions noted in the blocks may occur out of the order noted in the Figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or carry out combinations of special purpose hardware and computer instructions.

