---

title: Sharing and executing sensitive logic semantics
abstract: Obfuscating denotational logic in a source program. A non-rule-based object oriented source program is received. The source program is transformed into a rule-based source program that includes an object model and a ruleset. Attribute domains of the rule-based source program are characterized by a structure of their values in which the structure of the values is nominal, ordered, interval, or ratio. A minimum cardinality is calculated for each domain attribute. First domain attributes are randomly mapped to second domain attributes, each second domain attribute having the same value structure and a same or higher cardinality as the corresponding first domain attribute. For each randomly mapped pair a domain range of the first domain attribute is mapped to a domain range of the second domain attribute. In the rule-based source program first domain input fields and values are replaced with the respective second domain input fields and values.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09626492&OS=09626492&RS=09626492
owner: International Business Machines Corporation
number: 09626492
owner_city: Armonk
owner_country: US
publication_date: 20160720
---
This invention relates to a method and apparatus for sharing and executing sensitive logic semantics.

The invention operates in the general environment of software support and maintenance. In this context it is frequent that a software defect has been spotted and can be reproduced. However the particular data instance and program logic involved cannot be communicated to the person responsible for analyzing the issue and solving it for confidentiality reasons.

In computer system tools for managing processes and decisions some sensitive parts of decision and process logic referred to henceforth as sensitive decision logic and sensitive process logic are written by high level users and should not be made available to administrators technical support or developers. For instance technical support personnel in charge of maintaining the whole program may be from a different company and or not have the proper clearance for the sensitive decision logic and or sensitive process logic.

A significant evolution of the past 10 years in software systems is the distribution of enterprise applications and the separation of concerns between software infrastructure and the decision and process logic that structure it. Exemplified by process and decision management tools enterprise applications are deployed in cloud environments or a variety of software systems and embed or access decision services which contain some specific subprograms that describe the sensitive decision and process logic. The sensitive logic may often be critical to the operation of the organization. It is condensed in relatively isolated and easily identifiable segments which is convenient for maintenance and evolution but represents a serious vulnerability should it be made accessible beyond a contained perimeter.

The embodiments pertain to the situation where the decision logic is described as a rule based program. A rule based program in its simplest form is a collection of independent rules. A rule is composed of two program statements a guard that describes a set of conditions involving the state of the working memory and an execution statement which describes a set of state changes over the working memory.

Embodiments of the present invention disclose a method computer program product and system for obfuscating denotational logic in a source program. A non rule based object oriented source program is received. The non rule based source program is transformed into a rule based source program that includes an object model and a ruleset. Attribute domains of the rule based source program are characterized by a structure of their respective values in which the structure of the values is a structure selected from nominal ordered interval and ratio. A minimum cardinality is calculated for each domain attribute using static analysis of the ruleset and the object model. One or more first domain attributes are randomly mapped to one or more second domain attributes respectively where each second domain attribute has the same value structure and a same or higher cardinality as the corresponding first domain attribute. For each randomly mapped pair of a first domain attribute to a second domain attribute a domain range of the first domain attribute is mapped to a domain range of the second domain attribute. For the ruleset in the rule based source program in which an input field is in one of the one or more first domains the input field in the ruleset is replaced with the respective input field from the respective second domain and replacing each input field value is replaced with the corresponding mapped second field value.

Preserving the value characteristics provides for leaving underlying operational logic structure intact when denotational logic structure is removed from the source program.

The embodiments apply equally well to other contexts such as applications that implement part of their logic as structured query language SQL statements or contain embedded scripting features in which denotational logic exists in the scripts that configure the application.

The embodiments aim not at preserving the original meaning of the denotational logic but to the contrary to make it unintelligible while preserving the technical behavior of underlying decision and process operational logic. This way it becomes possible to assess the malfunction or performance issue without being able to reconstruct the actual meaning of the denotational logic.

Systems that include high level sensitive information would benefit from removing denotational logic and replacing it with some usable sensible but fake logic that lets the system run as expected on the surface yet does not reveal the high level sensitive information. One typical need is quality assurance and performance testing that need to setup test systems to verify and benchmark the systems yet have no need for the actual sensitive logic. For instance in the context of maintenance of decision management tools there have been frequent occasions wherein a customer could reproduce a problem but would not authorize the technical person in charge to access the needed information to reproduce it. Sometimes a technical support would have to travel to the customer site other times the technical support would spend considerable amount of time trying to reproduce the problem without access to a test case through partial information given by the customer.

To this achieve this effect the embodiments provide transformation logic for transforming decision logic presented as a program such that such logic keeps some useful properties it is still executable outputs results share similar properties with the original program but examination of this fake logic shall not provide actual information on the details and critical aspects of the real logic.

The base principle involves creating a random permutation of the object model s attributes and classes mapping each attribute to another one or a combination of other attributes and then creating a mapping between the domains of the source and target attributes that preserves the boundary conditions of the business logic.

The obfuscation technique of the embodiments does not preserve the sensitive logic also known as denotational semantics or meaning of the whole program but only its operational logic and global structure so that the program remains executable and produces the same logic flow as the original program.

The embodiments are described in terms of a rule base programming paradigm but are not limited to this programming concept. Indeed this programming paradigm is Turing complete meaning any program may be transformed into a similar program expressed in this formalism and therefore the embodiments are not limited to rule based programs. Actual programs involve more complex concepts that can be reduced to concepts of working memory guards and guarded statements and there is no loss of generality in considering a rule program in this very simple form.

Working memory is a data structure made of objects and classes that are examined and manipulated by the program. A guard is made of a set of variable declarations which are bound to objects of the working memory and a conjunction of conditions. Each condition in the canonical form of rules is made of an attribute to be tested for instance the applicant s age an operator equals is less than is more than . . . and an operand that can be a constant another attribute or an expression involving both constants and attributes. A guarded statement is a statement in its simplest form is a side effect of the program print display . . . or the assignment of the result of an expression to an object of the working memory. For example 

Guard IF the applicant has been in the same company for less than 2 years AND the applicant is over 22 years old

Since a rule based program is a Turing complete programming paradigm then any other type of program can be converted into an equivalent rule based program with same functionality. Other embodiments are envisaged for other programming paradigms.

Preferably further comprising minimizing source program field domain cardinality and whereby a first field and second field mapped pair are chosen based on substantially similar field domain cardinality. Said minimization is determined using static analysis of the rule set. The embodiments uses carefully selected specific static analysis techniques that identify data structure accesses variable domains side effects conditions tests and constants so that they can be obfuscated or modified according to some structure preserving transformations. The cardinality of each target field should be equal to or more than the cardinality of source domain.

More preferably scanning the rules for an operation error between when the first field is replaced by the second field and mapping the first field to a different field if an error is found. Scanning for an operation error preserves the algebraic operators used in the program .

Yet more preferably further comprising simulating a function of first field values so that that output value characteristics are similar to that provided by the function and second field values. Such simulation of a source program function is usually for black box functions although any function can be simulated. The simulation process comprises memoization. Test calls are performed on the source function to collect the structure of the output.

Even more preferably whereby if a mapping cannot be performed then the mapping is noted and further input requested.

Still more preferably further comprising integrated development environment with an application programming interface that can inspect the modified target program without access to the underlying source program.

More advantageously further comprising transforming said source program into an input rule set based program including a data object model.

Still more advantageously wherein for a first field value characteristic having order then the order is reversed for the second field value characteristic structure. Such reversal of order of a value characteristic the value structure is for additional obfuscation.

The embodiments ensure that that transformation of the source program has no effect on the underlying operation of when the transformed source program is executed.

The computer program product comprises a series of computer readable instructions either fixed on a tangible medium such as a computer readable medium for example optical disk magnetic disk solid state drive or transmittable to a computer system using a modem or other interface device over either a tangible medium including but not limited to optical or analogue communications lines or intangibly using wireless techniques including but not limited to microwave infrared or other transmission techniques. The series of computer readable instructions embodies all or part of the functionality previously described.

Those skilled in the art will appreciate that such computer readable instructions can be written in a number of programming languages for use with many computer architectures or operating systems. Further such instructions may be stored using any memory technology present or future including but not limited to semiconductor magnetic or optical or transmitted using any communications technology present or future including but not limited to optical infrared or microwave. It is contemplated that such a computer program product may be distributed as a removable medium with accompanying printed or electronic documentation for example shrink wrapped software pre loaded with a computer system for example on a system ROM or fixed disk or distributed from a server or electronic bulletin board over a network for example the Internet or World Wide Web.

Referring to a high level deployment diagram of the preferred embodiment comprises a customer system and a test and debug system .

The customer system is a computer system and storage system comprising object model rule set test data and transformation engine . In operation an intermediate domain2domain table is created before creating final output data for the test and debug system . The test and debug system receives the final output data from the customer system of modified rule set modified test data and memoization table .

Rule set is a program a source program comprising a set of rules to be transformed into a modified rule set also known as the target program.

Transformation engine is for performing a transformation on rule set and test data to provide modified rule set modified test data and memoization table .

Intermediate domain2domain table is for storing a mapping from each of the source fields to a respective target field.

Memoization table is for storing the parameters that are used to simulate functions acting on target values so that the results returned from a simulated function of target values corresponds to results returned from the function and source values.

Referring to the deployment of a customer system is described. Customer system is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing processing systems environments and or configurations that may be suitable for use with customer system include but are not limited to personal computer systems server computer systems thin clients thick clients hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputer systems mainframe computer systems and distributed computing environments that include any of the above systems or devices. A distributed computer environment includes a cloud computing environment for example where a computer processing system is a third party service performed by one or more of a plurality computer processing systems. A distributed computer environment also includes an Internet of things computing environment for example where a computer processing systems are distributed in a network of objects that can interact with a computing service.

Customer system may be described in the general context of computer system executable instructions such as program modules being executed by a computer processor. Generally program modules may include routines programs objects components logic and data structures that perform particular tasks or implement particular abstract data types. Customer system may be embodied in distributed cloud computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed cloud computing environment program modules may be located in both local and remote computer system storage media including memory storage devices.

Customer system comprises general purpose computer server and one or more input devices and output devices directly attached to the computer server . Computer processing system is connected to a network . Computer processing system communicates with a user using input devices and output devices . Input devices include one or more of a keyboard a scanner a mouse trackball or another pointing device. Output devices include one or more of a display or a printer. Computer processing system communicates with network devices not shown over network . Network can be a local area network LAN a wide area network WAN or the Internet.

Computer server comprises central processing unit CPU network adapter device adapter bus and memory .

CPU loads machine instructions from memory and performs machine operations in response to the instructions. Such machine operations include incrementing or decrementing a value in a register transferring a value from memory to a register or vice versa branching to a different location in memory if a condition is true or false also known as a conditional branch instruction and adding or subtracting the values in two different registers and loading the result in another register. A typical CPU can perform many different machine operations. A set of machine instructions is called a machine code program the machine instructions are written in a machine code language which is referred to a low level language. A computer program written in a high level language needs to be compiled to a machine code program before it can be run. Alternatively a machine code program such as a virtual machine or an interpreter can interpret a high level language in terms of machine operations.

Network adapter is connected to bus and network for enabling communication between the computer server and network devices.

Device adapter is connected to bus and input devices and output devices for enabling communication between computer server and input devices and output devices .

Bus couples the main system components together including memory to CPU . Bus represents one or more of any of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnects PCI bus.

Memory includes computer system readable media in the form of volatile memory and non volatile or persistent memory . Examples of volatile memory are random access memory RAM and cache memory . Examples of persistent memory are read only memory ROM and erasable programmable read only memory EPROM . Generally volatile memory is used because it is faster and generally non volatile memory is used because it will hold the data for longer. Computer processing system may further include other removable and or non removable volatile and or non volatile computer system storage media. By way of example only persistent memory can be provided for reading from and writing to a non removable non volatile magnetic media not shown and typically a magnetic hard disk or solid state drive . Although not shown further storage media may be provided including an external port for removable non volatile solid state memory and an optical disk drive for reading from or writing to a removable non volatile optical disk such as a compact disk CD digital video disk DVD or Blu ray. In such instances each can be connected to bus by one or more data media interfaces. As will be further depicted and described below memory may include at least one program product having a set for example at least one of program modules that are configured to carry out the functions of embodiments of the invention.

The set of program modules configured to carry out the functions of the preferred embodiment comprises transformation engine object model rule set test data domain2domain table . Test and debug system is created as an intermediate image on the customer system before being sent to a remote test and debug system. Test and debug system comprises modified rule set modified test data and memoization table . Further program modules that support the preferred embodiment but are not shown include firmware boot strap program operating system and support applications. Each of the operating system support applications other program modules and program data or some combination thereof may include an implementation of a networking environment.

Referring to transformation engine comprises the following components rule set creation engine structure characterizing engine static analyzer A memoization engine B mapping engine rule set transformation engine transformation method .

Rule set creation engine is for transforming said source program into an input rule based program including an object model.

Structure characterizing engine is for characterizing two or more object model fields by respective value type and value structures.

Static analyzer A is for characterizing value structures by static analysis of the data fields and values.

Memoization engine B is for simulating a function of target fields and modified test data so that the results corresponds to the function of source field and test data.

Rule set transformation engine is for mapping with respect to the object model at least one characterized field a source field to another characterized field a target field that has the same value type and preferably substantially similar value structures.

Transformation method is for performing the method of the preferred embodiment using the components of transformation engine . The input of transformation method is object model rule set and test data as defined above. The output is domain2domain table modified rule set modified test data and memoization table .

Rule set fields are typed and for convenience the domain of each field may be provided to help preserve sensible semantics of the output. For example if salary is replaced by age in the output rule set then the range 0 . . . 10000 is mapped to the range 18 . . . 80. If the domain is not provided in the object model then the domains will be deduced from examination of the test data.

Transformation method outputs a rule set matching the same input data model executable in the same context but leaving no usable information in the denotational logic the meaning logic layer involved in program while preserving the operational logic execution flow .

Step . is for preprocessing an input non rule based program into an input rule based program. Hence if the input program is rule based already then this step is not required. This step is performed using known transformations. For instance turning an imperative program into a rule based program may be performed by creating a rule for each line of the input program with a guard that tests a current line number variable and effects which include incrementing the current line number and performing the expression described at the current line. Once the input program is described in the form rules made of guards and guard statements then the method can continue. This step is only performed if input program is non rule based.

Step . is for characterizing attribute domains by structure of the respective values. This step is necessary for a domain translation step for mapping values of a domain say string integer double . . . onto values of another domain in a consistent way according to the structure of respective values. The characterization step identifies the structure of the values of each domain which can be one of by increased order of complexity nominal values ordered values interval values and ratio values.

Nominal values have a characteristic whereby a domain has no particular value structure to respect for instance string or text types like hello world . Ordered values have a characteristic whereby a domain has an ordered or monoidal value for instance enumerations like 1 2 3 . . . n . Interval values have a characteristic whereby a domain has a semi group structure making the difference between values significant for instance a time or date dimension . Ratio values have a characteristic whereby a domain has a ring structure allowing ratios to be taken for instance a revenue or population attributes .

This characterization of variable domains is fairly well known in the area of descriptive statistics. Of note on computer types because all domains are ultimately made of sequences of bits it is always possible to raise or lower a domain characteristic by considering the raw bits that constitute a value in this domain as an integer which is a type that has a ratio characteristic.

The later mapping step comprises will choose a mapping between the input and output domain ranges. This mapping must preserve the value structure of the input range but if no proper substitute is available another available attribute is chosen and an artificial value structure of the proper type is created for the purpose of mapping. Next a mapping is created that projects values from the input domain to the target domain. This mapping shall respect the value structure of the domains but the order value structures may be reversed for additional obfuscation. For instance age can be mapped to revenue only high revenues are mapped to low age and vice versa.

Step .A is for calculating a minimum domain cardinality for each domain attribute using static analysis of the ruleset and the object model. Since the mapping should involve field domains of similar cardinality the domain s cardinalities can be further reduced by inspecting the ruleset for boundary conditions on all the attributes and thereby reduce the domain to only a single value for the each interval considered. However if a source domain is too large to fit the target domain then the source attribute is analyzed to determine a relevant subdomain made of ranges that will allow creating the mappings properly. Step .A comprises steps .A .A .A and .A.

Step .A is for reducing the effective cardinality for each field. In this step numeric values are used for numeric domains. For example. Revenue 10000 . . . 100000 Name Alfred . . . Zigomar map the string s bytes to an integer range possibly semi intelligent to preserve readability.

Step .B is for memoization of functions that cannot be statically analyzed like black box functions although any other functions may undergo memoization. Memoization simulates a function by creating algebraic structures when a function cannot be analyzed. For example if date of birth source is mapped to revenue target the function monthOf date must be turned into a function monthOf revenue and its values in the test data set must be consistent with values of revenue. Step .B comprises steps .B and .B

Step .B is for instrumentation of the functions using aspect oriented programming to enable collecting the arguments and the return values. In the input program the black box functions such as monthOf date are augmented to collect the output they provide to given input values.

Step .B is for execution of the modified rule set to create memoization table and define the set of input values. Argument values and the return values are collected in memoization table for the invoked methods. Memoization table is saved for further use. Continuing the former example all the pairs date of birth month are collected to build a corresponding table revenue month that will be used in the output program instead of the original monthOf date .

Step . is for mapping object model fields according to their characterizations. Step . is performed for each field in each sensitive class of the object model and fields that are not in sensitive classes do not need to be mapped. Some fields in sensitive classes are not mapped. Step . is for creating a random permutation of the fields mapping each field to another of similar value structure. In the preferred embodiment mapping further comprises mapping each field to another field of equal or superior cardinality. In another embodiment it is possible to map to a combination of lower cardinality attributes but that is not disclosed here. An input field is mapped onto a target field and stored in domain2domain table .

Step . is for transforming the rule set and replacing the occurrences of source field with the target field according to domain2domain table . Step . comprises steps .. .. and ...

Step .. is for checking that the operators used in the rule set preserve the mapping the direction respects the value mapping .

Step .. is for reporting to a user if an attribute cannot be mapped too high cardinality whereby the user is asked what to do.

Referring to is an example of the domain mapping of preferred embodiment comprises two different size domains domain and domain . Intervals as indicated by the black bars within the domain range as indicated by a box in domain are spaced differently from domain . Arrows between the domains show how intervals in one domain are mapped into the other domain. Operators preserve the directions.

IF the applicant is over 22 years old THEN raise the premium by 5 A premium becomes 126 B premium stays at 120

IF the applicant has less than 13529 revenue THEN raise the loan by 20 A loan becomes 14940 B loan stays at 20000

This new program and dataset preserve the execution properties of the rule set on its inputs but destroys the business logic it makes no sense to raise the requested loan in the present context of loan insurance premium computation in way that is unrecoverable for someone who does not know the chosen permutation.

Further embodiments of the invention are now described. It will be clear to one of ordinary skill in the art that all or part of the logical process steps of the preferred embodiment may be alternatively embodied in a logic apparatus or a plurality of logic apparatus comprising logic elements arranged to perform the logical process steps of the method and that such logic elements may comprise hardware components firmware components or a combination thereof.

It will be equally clear to one of skill in the art that all or part of the logic components of the preferred embodiment may be alternatively embodied in logic apparatus comprising logic elements to perform the steps of the method and that such logic elements may comprise components such as logic gates in for example a programmable logic array or application specific integrated circuit. Such a logic arrangement may further be embodied in enabling elements for temporarily or permanently establishing logic structures in such an array or circuit using for example a virtual hardware descriptor language which may be stored and transmitted using fixed or transmittable carrier media.

In a further alternative embodiment the present invention may be realized in the form of a computer implemented method of deploying a service comprising steps of deploying computer program code operable to when deployed into a computer infrastructure and executed thereon cause the computer system to perform all the steps of the method.

It will be appreciated that the method and components of the preferred embodiment may alternatively be embodied fully or partially in a parallel computing system comprising two or more processors for executing parallel software.

A further embodiment of the invention is a computer program product defined in terms of a system and method. The computer program product may include a computer readable storage medium or media having computer readable program instructions thereon for causing a processor to carry out aspects of the present invention.

The computer readable storage medium can be a tangible device that can retain and store instructions for use by an instruction execution device. The computer readable storage medium may be for example but is not limited to an electronic storage device a magnetic storage device an optical storage device an electromagnetic storage device a semiconductor storage device or any suitable combination of the foregoing. A non exhaustive list of more specific examples of the computer readable storage medium includes the following a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or flash memory a static random access memory SRAM a portable compact disc read only memory CD ROM a digital versatile disk DVD a memory stick a floppy disk a mechanically encoded device such as punch cards or raised structures in a groove having instructions recorded thereon and any suitable combination of the foregoing. A computer readable storage medium as used herein is not to be construed as being transitory signals per se such as radio waves or other freely propagating electromagnetic waves electromagnetic waves propagating through a waveguide or other transmission media for example light pulses passing through a fibre optic cable or electrical signals transmitted through a wire.

Computer readable program instructions described herein can be downloaded to respective computing processing devices from a computer readable storage medium or to an external computer or external storage device via a network for example the Internet a local area network a wide area network and or a wireless network. The network may comprise copper transmission cables optical transmission fibres wireless transmission routers firewalls switches gateway computers and or edge servers. A network adapter card or network interface in each computing processing device receives computer readable program instructions from the network and forwards the computer readable program instructions for storage in a computer readable storage medium within the respective computing processing device.

Computer readable program instructions for carrying out operations of the present invention may be assembler instructions instruction set architecture ISA instructions machine instructions machine dependent instructions microcode firmware instructions state setting data or either source code or object code written in any combination of one or more programming languages including an object oriented programming language such as Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The computer readable program instructions may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider . In some embodiments electronic circuitry including for example programmable logic circuitry field programmable gate arrays FPGA or programmable logic arrays PLA may execute the computer readable program instructions by utilizing state information of the computer readable program instructions to personalize the electronic circuitry in order to perform aspects of the present invention.

Aspects of the embodiments are described herein with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer readable program instructions.

These computer readable program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks. These computer readable program instructions may also be stored in a computer readable storage medium that can direct a computer a programmable data processing apparatus and or other devices to function in a particular manner such that the computer readable storage medium having instructions stored therein comprises an article of manufacture including instructions which implement aspects of the function act specified in the flowchart and or block diagram block or blocks.

The computer readable program instructions may also be loaded onto a computer other programmable data processing apparatus or other device to cause a series of operational steps to be performed on the computer other programmable apparatus or other device to produce a computer implemented process such that the instructions which execute on the computer other programmable apparatus or other device implement the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of instructions which comprises one or more executable instructions for implementing the specified logical function s . In some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or carry out combinations of special purpose hardware and computer instructions.

It will be clear to one skilled in the art that many improvements and modifications can be made to the foregoing exemplary embodiment without departing from the scope of the present invention.

