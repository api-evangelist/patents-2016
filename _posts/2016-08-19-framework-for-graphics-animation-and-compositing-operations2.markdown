---

title: Framework for graphics animation and compositing operations
abstract: A graphics animation and compositing operations framework has a layer tree for interfacing with the application and a render tree for interfacing with a render engine. Layers in the layer tree can be content, windows, views, video, images, text, media or other type of objects for an application's user interface. The application commits state changes of the layers of the layer tree. The application does not need to include explicit code for animating the changes to the layers. Instead, after a synchronization threshold has been met, an animation is determined for animating the change in state by the framework which can define a set of predetermined animations based on motion, visibility and transition. The determined animation is explicitly applied to the affected layers in the render tree. A render engine renders from the render tree into a frame buffer, synchronized with the display. Portions of the render tree changing relative to prior versions can be tracked to improve resource management.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09576388&OS=09576388&RS=09576388
owner: Apple Inc.
number: 09576388
owner_city: Cupertino
owner_country: US
publication_date: 20160819
---
This application is a Continuation of U.S. patent application Ser. No. 11 500 154 filed Aug. 4 2006 entitled FRAMEWORK FOR GRAPHICS ANIMATION AND COMPOSITING OPERATIONS the entire contents of which are hereby incorporated by reference as if fully set forth herein under 35 U.S.C. 120.

The subject matter of the present disclosure relates to a framework for handling graphics animation and compositing operations for a graphical user interface of a computer system application.

The following table shows 14 source code files of an application programming interface that are provided as computer program listing on a compact disc in read only format and are hereby incorporated by reference.

Mac OS X provides prior art graphics and imaging frameworks for developers to create views for graphical user interfaces GUIs of a computer application. MAC OS is a registered trademark of Apple Computer Inc. of Cupertino Calif. For example Cocoa is an object oriented application environment that developers can use to develop Mac OS X native applications. Apple s Cocoa Application Framework also referred to as Application Kit or AppKit is one of the core Cocoa frameworks. Application Kit provides functionality and associated Application Programming Interfaces APIs for applications including objects for graphical user interfaces event handling mechanisms application services and drawing and image composition facilities.

NSView is part of Cocoa s Objective C API and is an abstract class that defines basic drawing event handling and printing architecture of applications. With NSView each view of an application s GUI is dealt with using local coordinates and each view is positioned relative to its parent view in a hierarchical fashion. Using a view hierarchy is useful for building complex user interfaces out of modular parts. The Application Kit framework is used to develop NSView based applications. This framework contains objects needed to implement a graphical event driven user interface that includes windows dialogs buttons menus scrollers text fields etc. Application Kit framework handles the drawing of objects communicates with hardware devices and screen buffers clears areas of the screen before drawing and clips views.

GUIs for computer applications have increased in complexity and are usually designed to handle views animations videos windows frames events etc. Even with the increased complexity the goal of developers is to make the GUIs more tactile and natural in appearance. Accordingly developers must consider how to create and manage the GUIs for computer applications with this goal in mind.

Referring to a rendering process according to the prior art is schematically illustrated. In the rendering process an application which can be based on NSView as discussed above inputs GUI information into a backing store and issues rendering commands to the render engine . The render engine renders the GUI information from the backing store into a frame buffer . The render engine can use Apple s Core Image and Core Video. Core Image is an image processing framework and Core Video is a video processing framework. Scan out hardware then outputs the rendered information in the frame buffer to a display using a frame rate of the display .

This prior art rendering process has no built in framework for animating objects or views. Instead the NSView based application handles animation explicitly by moving views around resizing views etc. To provide animation most NSView based applications developed in the art resort to using snapshots of the views and compositing the snapshots using other facilities. In the application is show having a pseudo code loop for animating movement of an object or view for the application s GUI. In this simplified example the object or view is being moved from a start point A to an end point B e.g. the application may receive user input moving a view from a starting position on the display to an ending position . The typical developer of the application does not want the object to disappear from point A on the display and suddenly appear at point B on the display because users prefer a more gradual or natural movement.

To make the movement more gradual or natural the developer of the application typically animates the movement of the object from start point A to end point B using explicit code such as code segment or loop . In this simplified code the loop is used to animate the object by incrementally moving the object some distance X for each iteration of the loop . shows some resulting positions of an object or view as it would appear incrementally on displayed results as the application of performs the animation of the object with the iterative loop of . The number of steps or snapshots used to animate the movement of the object is decided by the developer. In addition to such an iterative loop for moving objects the developer must include explicit code in the application to implement any form of animation e.g. fade in fade out resize etc. for an object.

In addition to requiring explicit animation in the application the data structures and painting model for NSView present problems when the application has dynamic content. For example NSView makes no particular distinction between changes in content and layout and is not well tuned for continuous re layout. As an NSView object is moved for example it creates damage to content in its wake that requires other views to be redrawn. Redrawing a view typically invokes the model to view mapping code of NSView based application and requires expensive computations to be performed particularly if the model data needs to be retrieved over a network .

The timing of services for this form of application offers some additional difficulties for developers. Most animations are done using one or more timers e.g. the embedded loops or iterative steps in the main event loop of the application . Therefore the duty cycle of the timer for the animation is completely dependent on how fast the application services its main event loop. Although some events can be handled quickly other events may take much longer and may actually be subject to I O delays.

In addition the frame buffer and scan out hardware operate under a frame rate to output information to the display . The frame rate is typically about 60 Hz. To improve the handling of events developers attempt to operate the application in synchronization with the frame rate of the hardware. In this way the majority of events of the application can be timely handled within the main loop of the application and rendered to the display at the frame rate . However maintaining such a consistent frame rate of 60 Hz. in the main loop of the application can be difficult. Furthermore determining what actual frame rate to use and determining when to initiate the timer to keep it in sync with video blanking of the scan out hardware is not readily apparent in a given context because the application is not given intimate knowledge of the video display and its associated hardware .

In addition to presenting problems for developers with respect to animation and event handling the NSView based application may have problems related to layout of the GUI for the application . For example a number of constraints must typically be applied to views when they are resized for display. One of the views may have a fixed absolute size while other views may be designed to change size with the composition. Additionally many views e.g. text or web views must explicitly change how they are represented as a function of the actual size at which they are to be displayed. Consequently the text or web view may need to invoke its own layout techniques when it is resized. Developers of the NSView based application must explicitly handle these types of complex issues.

The subject matter of the present disclosure is directed to overcoming or at least reducing the effects of one or more of the problems set forth above.

A framework for performing graphics animation and compositing operations is disclosed. The framework is used as part of rendering process to render a user interface of an application for display on a computer system. The framework is divided into two processes. A layer tree process interfaces with the application and a render tree process interfaces with a render engine. The layer tree process has a first data structure or layer tree that contains object or layers associated with the user interface of the application. The layers can be content windows views video images text media or any other type of object for a user interface of an application. The render tree process is separate from the layer tree process and does not interface with the application. The render tree process has a second data structure or render tree that contains object or layers associated with the layer tree. The render engine renders from the render tree.

When the application changes or is manipulated to change a layer of the user interface e.g. a user moves a layer from a first position to a second position in a window of the user interface the layer tree process receives the changes from the application and implements the changes directly to the layer tree. The changes from the application change the state of one or more layers in the layer tree. For example if a layer has been moved in the application then attributes describing the position of the affected layer in the layer tree will change. From the change in state of the affected layer in the layer tree an animation and compositing process independent from the application determines what animation to use to animate the change of the affected layer. The animation and compositing process then implements the determined animation on the affected layer of the render tree. Then the render engine renders the layers in the render tree into a frame buffer of the computer system.

In one technique to improve resource usage the framework can focus on dirty regions of the render tree when rendering. A dirty region is one or more layers or objects of the render tree that have changed relative to their immediate prior versions. For example the dirty regions can be indicated by change objects added to the associated layers of the render tree that have been changed relative to their immediately prior version. The change objects are updated at each transaction of rendering the render tree. During rendering the render engine renders only those layers that have changed relative to their immediately prior version.

In another technique to improve resource usage user interface information from an application is stored to a first buffer. A buffer handler receives a first update region of the user interface information from the application. In response the buffer handler stores the user interface information from the first buffer into a second buffer except for the first update region. The render engine renders from the second buffer for display on the computer system and the buffer handler marks the first buffer as purgeable. During subsequent processing the buffer handler determines whether the first buffer has been reclaimed in response to receiving a second update region from the application. If the first buffer has not been reclaimed buffer handler can use the first buffer again.

The foregoing summary is not intended to summarize each potential embodiment or every aspect of the present disclosure.

While the subject matter of the present disclosure is susceptible to various modifications and alternative forms specific embodiments thereof have been shown by way of example in the drawings and are herein described in detail. The figures and written description are not intended to limit the scope of the inventive concepts in any manner. Rather the figures and written description are provided to illustrate the inventive concepts to a person skilled in the art by reference to particular embodiments as required by 35 U.S.C. 112.

Referring to one embodiment of a rendering process according to certain teachings of the present disclosure is schematically illustrated. In the rendering process an application inputs graphical user interface GUI information into a backing store not shown and a layer kit framework is used to process the GUI information in the backing store. Once the framework has processed the GUI information a render engine renders the processed information into a frame buffer . Although not shown in the render engine typically renders processed information into an assembly buffer that is then composited into the appropriate location of the frame buffer . When compositing is completed scan out hardware outputs the rendered information in the frame buffer to a display using a frame rate of the display .

The processing performed by the layer kit framework includes graphics animation and compositing operations for the application . To perform the operations the layer kit framework divides the processing into a layer tree and a render tree . In this two tree approach the layer tree is exposed to the application and is used for implicit animation and implicit layout of graphics objects also referred to herein as layers . On the other hand the render tree is manipulated and is traversed by the render engine .

As will be discussed in more detail later the layer tree includes a data structure that interfaces with the application . The data structure of the layer tree is configured to hold a hierarchy of layers. The layers are objects having various properties and attributes and are used to build the GUI of the application . The terms property and attribute may be used interchangeably in the present disclosure . In general for example the layers can include content windows views video images text media etc. The data structure of the layer tree is preferably as small and compact as possible. Therefore many of the attributes of the layers preferably have default values kept in an extended property dictionary such as NSDictionary of Apple s Cocoa application environment.

During operation the application interacts with the layer tree of the framework to manipulate the hierarchy of layers in the layer tree . The application can be any computer application or client process that manipulates or changes the layers being displayed. When the application commits an event or change to the layer tree the framework determines what events or changes are made at each layer by the application . These events or changes in the layer tree are then committed to an animation and compositing process of the framework . This process determines one or more implicit animation functions of the framework to use on the layer tree based on the committed events or changes for each layer of the layer tree .

The animation and compositing process then performs explicit animation of the events or changes and configures the layout of the layers in the render tree . The animation and layout of the render tree are then rendered by the render engine and output to the frame buffer . Any manipulations of layers made by the application to the layer tree are not evaluated at the frame rate of the display . Instead changes in the render tree are traversed and updated at the frame rate .

As alluded to above the framework separates the animation and compositing of layers from the application . For example when the application makes changes the affected layers in the layer tree are instantly changed from one state to another. State changes reflected in the layers of the layer tree are then percolated to the physical display by animating the changes and compositing the layers of the render tree from the initial state of the layers to their final or end state. This form of animation and composition is referred to herein as implicit animation and is part of the animation and compositing process of .

By using implicit animation in the framework the application does not have to include code for animating changes e.g. movement resizing etc. of layers to be displayed. Accordingly any code required for animating layers can be minimized in the application . As shown in simplified form in for example the application may not require an embedded loop for animating changes to the layers. Instead the application includes code that indicates a change in the state of a layer e.g. indicates a change in position of a layer . The framework determines from the changes made to the layers in the layer tree what implicit animation to perform on the layers and then the framework explicitly performs that animation on the layers using the render tree . Accordingly animations can be abstracted in such a way that the code of the application does not need to run at the frame rate . This allows the animation for objects layers to be decoupled from the logic of the application and allows the application and the animations to run on separate threads in the rendering process .

The animation and compositing process can perform a number of different types of animation on layers or objects. For example if the application operates on the layer tree to change a layer from start point A to end point B in the GUI for the application the animation and compositing process automatically manipulates i.e. without application input the representation of that layer in the render tree to animate its movement from point A to point B on the display . In another example if the application operates on the layer tree to add a new layer to the layer tree the animation and compositing process may automatically manipulate the render tree to fade in the new layer. In yet another example if the application operates on the layer tree to replace an existing layer with a new layer the animation and compositing process automatically manipulates the render tree to animate a transition from the existing layer to the new layer.

To help illustrate how the application changes the state of layers in the layer tree shows an example result of a layer of the layer tree of being changed from a start state to an end state by the application of . In this example the layer is schematically represented as an object in a layout boundary and is shown moved from a start state A to an end state B e.g. a user of the application s GUI has moved a window from one point A on the screen to another point B .

Returning to the state change of the layer made by the application are committed almost immediately to the layer tree . Once made the animation and compositing process obtains the change in state of the affected layer from the layer tree using a state based form of operation. The animation and compositing process then uses characteristics of the start state and end state of the layers to determine what animation to use to arrive at the end state of the layers for display. Finally the process explicitly applies the determined animation and associated layout of the layers to the data structure of the render tree in a procedural fashion.

To help illustrate the operation of the animation and compositing process shows example results of animation on an affected layer in a layout boundary . The layer is part of the render tree of and is associated with the changed layer of . In this example the layer is being moved in increments of a distance X over a period of time from point A on the display to another point B on the display as the animation and compositing process of applies the determined animation in a procedural fashion to the render tree of . It will be appreciated that several layers can be simultaneously changed and animated. By separating the animation and compositing from the application in the framework can better synchronize animation with the frame rate . In this way multiple and simultaneous changes made to the layers by the application can be committed in synchronization to the display .

Given the above overview of the rendering process and layer kit framework of the present disclosure we now turn to a more detailed discussion of an embodiment of a layer kit framework according to certain teachings of the present disclosure. In a rendering process is illustrated showing an embodiment of a layer kit framework for graphics animation and compositing operations. The framework includes a layer tree process a queue an implicit animation process an explicit animation process and a render tree process . The framework is part of an object oriented application environment such as Cocoa designed for developing Mac OS X native applications. Files of an Objective C API for the layer kit framework have been incorporated herein by reference in the computer program listing appendix. The framework can be used to build interactive user interfaces for applications. Preferably the framework is compatible with Apple s existing Application Kit framework by using an NSView subclass to host layers and other properties of the framework as discussed below.

The layer tree process has a data structure or layer tree that interfaces with an application . Like views of NSView a layer of the framework draws itself. When it draws itself the layer is given a CoreGraphics context CGContext . Unlike NSView however rendering commands from the application are not issued immediately but are instead captured into the retained data structure of the layer tree and are then eventually passed over to the render tree process for processing. The render tree process can then redraw layers in the render tree that are associated with the layers of the layer tree with no intervention by the application . This is one purpose for separating the layer tree process from the render tree process . The render tree process can always synthesize an up to date representation of the layers without needing to call back to the application .

The isolation mentioned above also allows the render tree process to be implemented in a number of ways including allowing the render tree process to reside in another thread or in another process via Interprocess Communication IPC . For example the render tree process can be implemented on an NSTimer on a separate thread from the layer tree process . The isolation between the layer tree process and the render tree process also allows the layer tree process to be implemented in an object language like Objective C while the render tree process can be coded entirely in a procedural language such as C if necessary for performance.

As shown in the layer tree is diagrammatically illustrated as a number of layers that are interconnected by dependencies with one another in a hierarchical fashion. It is understood that a computer system can store the layer tree in any format suitable for the computer. Several types of layers can be defined in the framework . Some possible types of layers include Image layers CoreGraphics layers Text layers Vector layers e.g. layers based on CGLayerRef Client drawable and display lists CoreVideoBuffer or Media layers e.g. autonomously animating content such as movie or Quark Composer and other more generic layers.

Before proceeding with the discussion of the rendering process of we first turn to a discussion of the layers in the layer tree of the framework . The layers are substantially similar to views of Apple s NSView. Like the views in NSView for example each layer is associated with a window in which it is displayed and the layers are related to one another in a hierarchical fashion of superlayers and sublayers because some layers are subregions of other layers in a window.

The framework can use the following classes NSArray NSDictionary NSEnumerator LKAnimation and CIFilter and the protocol LKAction. NSArray NSDictionary NSEnumerator and CIFilter are known and used in the art. LKAnimation and LKAction are defined for the disclosed framework of and are described in the incorporated files. The base layer class for layers in the framework is the NSObject class. However the base layer class has specific timing LKTiming and object LKObject protocols for the framework of the present disclosure.

The LKObject protocol for the layers extends the standard NSKeyValueCoding protocol known in the art by adding support for property introspection and customization. All objects implementing the LKObject protocol also implement the NSCoding protocol for object archiving. Each object implementing the LKObject protocol exposes a set of properties declared using the standard Objective C property syntax. These properties are also accessible via the NSKeyValueCoding protocol. When accessing properties whose values are not objects the standard Key Value Coding KVC wrapping conventions are used with extensions to support the following types CGPoint NSValue CGSize NSValue CGRect NSValue and CGAffineTransform NSAffineTransform .

Many more details of the layers are discussed herein and are included in the incorporated file LKLayer. Here we only briefly mention some of the geometrical and hierarchical properties for layers in the framework . Many of the properties are similar to those used in Core Graphics. Layers have bounds or a coordinate system that are defined by the property CGRect bounds. The position of a layer is defined by the property CGPoint position. The Z component of the position of a layer is defined by the property CGFloat zPosition.

The frame of a layer is defined by the property CGRect frame. Unlike NSView each layer in the layer hierarchy of the framework has an implicit frame rectangle that is defined as a function of the bounds transform and position properties. When setting the frame of the layer the position and bounds.size for the layer are changed to match the given frame. The frame and bounds model of the framework is similar to that used for Apple s Application Kit but only the bounds offset and matrix are stored. The frame can be computed using an instance of method CGRect frame. 

To help visualize the layers their hierarchy in the layer tree the frame and bounds of the layers and other details we turn briefly to . shows an example of a window of a graphical user interface. The window has three layers A B and C. Much like the view hierarchy used in Apple s NSView the layers A B and C in the window are linked together in a layer hierarchy which is also shown in . In general each layer can have another layer as its superlayer and can be the superlayer for any number of sublayers. As used herein a superlayer is the layer that is immediately above a given layer in the hierarchy and a sublayer is the layer that is contained either wholly or partially by the superlayer. In the example of the window s content layer is at the top of the hierarchy and layer A in the hierarchy is the superlayer for the sublayers B and C.

In for example the relationships for three example layers D E and F are shown where layer D is the superlayer of E and where layer E is the superlayer of F. Each layer D E and F is defined by a corresponding frame rectangle D E and F having its own coordinate system D E and F. The bounds attribute of the layers defines its coordinate system . In general the frame rectangle of each layer is positioned within the coordinate system of its superlayer. Thus the frame rectangle E for layer E is positioned within the coordinate system D of layer D and the frame rectangle F for layer F is positioned within the coordinate system E of layer E. When a given layer is moved or its coordinate system is transformed e.g. rotated flipped etc. all of its sublayers are moved or transformed along with it. Yet because each layer has its own coordinate system the drawing instructions for that layer can be consistent no matter where the layer is or where its superlayer moves to on a screen.

The frame rectangles essentially define the area of the layers i.e. the tablet on which the layers can draw. The frame rectangle of a given layer can lie within the frame rectangle of its superlayer. In addition the frame rectangle of a given layer can extend outside its superlayer s frame rectangle . For example the frame rectangle F lies entirely within the frame rectangle E of its superlayer D but the frame rectangle E for layer E extends outside the frame rectangle D of its superlayer D. In contrast to views in NSView the layers can place content outside the frame of their parent layers.

Given the above overview of layers we now return to a discussion in of how the layers are interrelated to one another to construct the layout of the layer tree of the disclosed framework . The layers in the layer tree are constrained by layer constraints not shown in . A constraint based layout manager adds a constraints layer property to the data structure for layers in the layer tree . The constraint based layout manager is defined in the incorporated file LKConstraintLayoutManager. The constraints layer property is an array of LKConstraint objects. Each LKConstraint object describes one geometrical relationship between two layers of the layer tree . Layout of the layers in the layer tree is performed by fetching the constraints of each sublayer and solving the resulting system of constraints for the frame of each sublayer starting from the bounds of the containing layer . The relationships between layers are linear equations of the form u m v c where u and v are scalar values representing geometrical attributes e.g. leftmost x position of the two layers and where m and c are constants. Sibling layers are referenced by name using a name property of each layer . A special name superlayer is used to refer to the superlayer of a given layer .

Now that we have an understanding of the layer tree and its layers we turn to a discussion of details related to the render tree process and render tree . As discussed previously the render tree process has a data structure or render tree that does not interface with the application . Instead explicit animation is made to the render tree by the explicit animation process and the render engine renders from the render tree . The render tree is similar to the layer tree in that it contains a description of the layer hierarchy of the layers found in the layer tree . Accordingly the render tree also includes a plurality of layers that are related in a hierarchical fashion and that are associated with the layers of the layer tree .

In contrast to the layer tree the render tree further includes animation objects added to the data structure of the layers in the render tree . For illustrative purposes the animation object for one of the layers is diagrammatically shown in as an appended element to a node D that has been changed in the layer tree by the application . During processing by the animation processes implicit and or explicit the animation object is added to a representation of the layer in the render tree associated with the changed layer in the layer tree . In typical operation of the framework adding the animation object is implicitly invoked through an action that is an LKAnimation object. Details related to LKAnimation object are discussed below and are incorporated file LKAnimation. 

The animation object has a key a duration property and other properties and details discussed herein. The key is used to identify the animation and the key may be any string such that only one animation per unique key is added per layer in the render tree . The special key transition is automatically used for transition animations of the layers . The duration property of the animation object defines the duration of the animation. If the duration property of the animation object is zero or negative it is given a default duration which can be either a particular value of a transaction property for the render process or can be a default value of 0.25 seconds for example.

Given the details of the framework discussed above we now turn to a discussion of how the framework is used in the rendering process . In the rendering process of is shown in flow chart form as process . For the sake of understanding the discussion that follows reference is concurrently made to reference numbers of components in the rendering process of and to blocks of the process of .

During operation the application obtains changes made to one or more layers of the application s GUI system Block . The application interfaces with the layer tree process and commits the changes to the layer tree Block . As discussed previously the changes to the layer tree are not immediately rendered by the render engine . Instead the layer tree process changes the state of one or more affected layers and sublayers in the hierarchy of the layer tree Block . In the example of a node D has had its state changed from X to Y e.g. the layer associated with node D has been moved from one position to another position has been resized from one size to another size etc. . The state change to the layer in the layer tree may not include any animation or compositing information and the state change may merely indicate to the layer tree process the start and end states of the affected layers and sublayers of the hierarchy in the layer tree .

The state change of the layers and sublayers is then queued in a queue of the framework Block . The queue is used to commit the state changes to the implicit animation process and periodically determines whether to commit the state changes Block . Preferably multiple state changes to layers in the layer tree are batched into atomic transactions that are committed together by the queue . If it is not time to commit then the process can return to obtaining additional state changes to the layer tree by the application at Blocks through .

If it is time to commit then the queue commits the state changes to the implicit animation process Block . The implicit animation process includes default animation operations but explicit overrides can be made. Explicit overrides can be implemented by an appropriately programmed application using the actions property of the layers. In addition explicit overrides can be implemented using a defaultActionForKey method for implementing a default action for a specified key on the layer and using a actionForKey method for implementing an action for a specified key on the layer

The implicit animation process determines what animation operations to perform based on the state changes of the affected layers in the layer tree Block . This determination depends on the context of the state change. The context is based on various variables such as the type of layer being changed the position of the changed layer in the hierarchy of the layer tree any sublayers of the changed layer the type of change etc. Details related to this determination are provided in more detail later.

Once the animations have been determined the explicit animation process then implements the determined animations on the associated layers in the render tree Block . In particular the explicit animation process implements the processes or steps of the animations on the associated layers in the hierarchy of the render tree in a transactional fashion. Eventually the explicit animations of the render tree are committed to the render engine for rendering and are eventually displayed Block .

As noted previously changes in the layers associated with the layer tree are percolated to the render tree . In other words the layer tree process and the render tree process interact in a transactional model. Changes to the data structure of the layer tree are explicitly flushed or committed to the render tree in order to have a visual effect. This is similar to window backing store flushing where a group of changes appears atomically. The difference in the framework is that some of the changes are not necessarily implemented immediately and might implicitly require animation.

If new changes are committed before the explicit animation and render tree processes and have completed animations of affected layers the processes and can still animate to the newly requested state smoothly from its current state again without the application being involved. If the root or a subtree of the hierarchy associated with the layer tree is changed to a completely new scene and committed to the render tree for example a default scene transition can be explicitly invoked e.g. 0.5 second dissolve or cube transition can be implicitly applied .

Transactions are the mechanism used by the framework for batching multiple operations to the layer tree into atomic updates to the render tree . Details related to the transactions are included in the incorporated file LKTransaction. Every modification to the layer tree requires a transaction to be part of it. The framework supports two kinds of transactions explicit transactions and implicit transactions. The application can call explicit transactions before modifying the layer tree and can commit the explicit transactions after modifying the layer tree . Implicit transactions are created automatically by the framework when the layer tree is modified by the application s thread without an active transaction. The implicit transactions are committed automatically when the thread s run loop next iterates. In some circumstances i.e. where there is no run loop or the run loop is blocked it may be necessary to use explicit transactions to get timely updates to the render tree .

To handle transactions the framework defines an LKTransaction which is an NSObject. Using the framework new transactions can be initiated all changes made during a current transaction can be committed to the render tree and any extant implicit transactions can be flushed. Preferably implicit transactions are not committed until any nested explicit transactions have been completed. Transaction properties can include animationDuration that defines a default duration in seconds for animations added to layers and can include disableActions that suppresses implicit actions for property changes.

Use of transactions and implicit animation in the framework offers a number of advantages in the rendering process of . In one advantage the separate layer and render trees and keep rendering and display operations clean. For example the application can provide an instruction for a layer at a start state X in the layer tree to be changed to an end state Y. The layer tree process implements that state change to the affected layer and the application can then immediately continue to operate as if the affected layer is at end state Y. Separately the explicit animation process and render tree process of the framework process the associated layer of the render tree to animate its change from start state X to end state Y. 

In the rendering process the application no longer performs the animation. Instead the framework performs the animation by first determining the animation to perform with the implicit animation process and then implementing the determined animation with the explicit animation process . Having the application assume the end state for the affected layer of the layer tree while having the framework animate the associated layer of the render tree to its end state allows multiple events and changes to be queued up with the layer tree process and queue without the application having to do graphical programming and animation.

As noted previously the framework determines what animations to use for layers changed by the application . The type of animation used can depend upon characteristics of a given context of the application s GUI currently being rendered for display. In the framework the animations between states are implicitly determined and it is assumed that animations will be gradual to some extent. If a new position for a layer tree layer is set for example the associated render tree layer is implicitly animated from its current position to its new position via a default animation or transition to gradually animate the change. Similarly when a new layer tree layer is added an associated render tree layer will have a default appearance animation or transition e.g. a 0.25 second materialize or dissolve .

Preferably animation behaviors are programmable in the framework by invoking a predefined name of the animation e.g. Push Left Swirl In etc. . The framework can define various forms of animation and can have a set of predetermined animations to be used. For example some animations in the framework can be defined in a manner similar to what is used in Synchronized Multimedia Integration Language. Synchronized Multimedia Integration Language is technology developed and distributed by the World Wide Web Consortium W3C . In addition animations in the framework can include animatable properties attributes and filters of layers and can include transitions between changes in the layers of the layer tree . Preferably the framework allows developers to make overrides of default values such as timing controls for animations.

For example the framework can define a transition animation subclass that contains various transition types such as fade moveIn push and reveal. Because some transitions of the animation model may be motion based the framework can further define a property subtype for these transitions. The property subtype can be used to specify the direction for the motion based transitions. For examples values for this property subtype can be fromLeft fromRight fromTop fromBottom and fromCorner. 

Because animations may occur over a period of time the framework can further define another property subtype for animations that specifies the amount of progress for the animation at which to begin and end execution. In one example a timing function can define the pacing of the animation. The timing function can define a general keyframe animation class to create an array of objects providing the value of the animation function for each keyframe. Typically a keyframe is a frame used to designate where changes occur in the animation. The framework can also define LKTimingFunction objects. If N number of keyframes are set for the animation there would typically be N 1 objects in the timingFunctions array. Each function in the array describes the pacing of one keyframe to keyframe segment of the animation.

In addition a path object can define the behavior of an animation. Each point in the path object except for moveto points defines a single keyframe for determining the timing and the interpolation of the animation. For constant velocity animations along a path the animation can be set to a calculated mode of paced. Other calculated modes can include linear and discrete. 

For basic i.e. single keyframe animations the framework can define a subclass for interpolation objects that define the property values between which an animation is to be interpolated. Preferably the object type of the interpolation objects matches the type of the property being animated using the standard rules described in incorporated file LKObject for example. Some supported modes for interpolating animation include 1 interpolating between a fromValue and a toValue 2 interpolating between a fromValue and a fromValue plus a byValue interpolating between a toValue minus a byValue and a toValue 3 interpolating between a fromValue and the current presentation value of a property 4 interpolating between the layer s current value of a property in the render tree and a toValue for that property 5 interpolating between the layer s current value of a property in the render tree and that value plus a byValue and 6 interpolating between the previous value of a property in the render tree and the current presentation value of that property.

To handle animations of multiple layers the framework can also define an animation subclass for grouped animations to create an array of LKAnimation objects. Each member of the array can be run concurrently in the time space defined for a parent animation.

In addition to motion transitions and other animations disclosed herein the framework can allow layer properties to be animated as well. For this the framework can include a set of ValueAnimation classes. In one example a FloatAnimation value may be defined in one of the ValueAnimation classes so that the X position of a layer in the GUI could be set to the FloatAnimation value that has been specified to oscillate between two values.

Furthermore the animations defined in the framework can include animatable filters for the layers. For example the framework can define additional attributes for CIFilter objects that can be accessible both via the NSKeyValueCoding protocol and through declared properties. These additional attributes can be used to construct keypaths to existing filters so that the framework can set an attribute of a filter attached to a layer and so that animations of the layers may access filter attributes via the key paths. In this way the filters for layers can be animatable within the framework .

As used herein a key is a string that identifies a specific property of an object. Typically a key corresponds to the name of an accessor method or instance variable in the receiving object. As used herein a key path is a string of keys separated by dots. The key path is used to specify a sequence of object properties to traverse. The property of the first key in the sequence is relative to the receiver and each subsequent key is evaluated relative to the value of the previous property. For example the key path address.street would get the value of the address property from the receiving object and then determine the street property relative to the address object.

In one example of animatable filters a generalized filtering model may include maskop mask compositeop layerop layer backgroundop background background . Here layerop can be a unary image operator that processes the foreground image. For example layerop could be used to add a glow to a layer. Backgroundop can be a unary image operator that processes the background image. For example backgroundop could be used to ripple the background. In addition compositeop can be a binary image operator that combines the foreground and background and it can default to source over or to source over with shadow if present. Finally maskop can be a ternary operator that takes a mask and two images and blends them together.

Although the framework preferably provides a number of default animations overrides can be made available to specify particular animation behaviors. In this way the GUI of the application can be essentially programmed for goal states and the framework can handle the details of animating the layers of the application s GUI towards those goal states. The application therefore can be developed as if the application is animating the layers of the GUI. However the application never truly animates the layers of the GUI when the implicit animations of the framework are used.

The framework defines a timing protocol called LKTiming that is implemented by layers and animations. Details related to this protocol are included in the incorporated file LKTiming. The timing protocol of the framework models a hierarchical timing system with each object describing the mapping from time values in the object s parent to local time. Absolute time is defined as mach time i.e. machine time converted to seconds. A LKCurrentTime function is provided as a convenience for querying the current absolute time. Conversions can also be made between different versions of time. The timing model of the framework can allow animations to repeat their basic duration multiple times and can optionally allow animations to play backwards before repeating.

Animations may use various timing functions defined in the framework . For example the timing functions in the framework can generally be represented by segments of functions describing timing curves. These functions can map input time normalized to a range such as between 0 1 to output time also in the range 0 1 . The timing functions for the framework can be used to define the pacing of an animation over its duration or over the duration of one keyframe . Common timing functions can also be created and used in the framework such as linear easeIn easeOut and easeInEaseOut. In addition timing functions can be created that are modeled on a cubic Bezier curve where the end points of the curve are at 0 0 and 1 1 and where the two points c1 and c2 defined by the class instance are the control points. Thus the points defining the Bezier curve can be 0 0 c1 c2 1 1 . 

Not all time varying images however can be modeled as state transitions of the layers from one state to another state. Some layers e.g. Video Flash or Quartz Composer are media layers in that these media layers have timing and other behaviors that are intrinsic to them. Because media layers may need to be representable as nodes in the layer tree the framework includes a MediaLayer abstraction for interacting with CoreVideo compliant media. The MediaLayer abstraction is used for the media layers of the layer tree that have intrinsic animation and that have their appearance change as a function of time. The media layers can reference a media file. The media can be abstract and needs to provide a compliant frame for time accessor for the render tree process to use and needs to provide a time mapping between the notion of time for the render tree process and the notion of time for the media in the media layer. All of the standard layer attributes Opacity transform shadow etc. can be applied in the render tree process for the media layer.

Other common objects for display in an application s GUI that have intrinsic timing include the pulsing button rotating gear progress bar animated GIF or other similar objects. These can be specified by a particular type of media layer that has its animation represented by a set of images. For this type of media layer the layer itself can provide a time varying method for drawing itself for each frame when rendered from the render tree . For example the framework samples this type of media layer at an appropriate number of times and provides the frames as an atomic set to the render tree process . The render tree process then plays out the animation either in a one shot fashion or more typically in a looped fashion so that the layer can be animated for display.

A layer can exhibit a number of behaviors when its frame rectangle is changed by the application . In a default mode the bounds i.e. the coordinate system are not changed and the layer s contents are merely scaled. Since a display list representing the content is resolution independent the display list just needs to be replayed through the new current transformation matrix CTM which is used to transform the bounds and frame of the layers. The other mode of resizing a layer is just to give the resized layer more or less real estate and not to change the size of any of its items. In this case any sublayers of the resized layer are resized according to their auto sizing information. This information relates how a sublayer s frame changes when its parent layer s bounds change. Because each layer retains its own drawing information resizing can occur without necessarily invoking drawing code of the application . The only cases where intervention by the application may be necessary is when a layer s representation is a function of its bounds such as text layout . In this case the application may defer computing the new representation for the text layer and can work with the old representation for the text layer until the resize is complete.

Below is a detailed discussion of various attributes for layers that can be defined in the framework . This discussion is not meant to be exhaustive of all of the attributes that can be used for layers and is merely intended to provide a number of example attributes that can be used. Each layer can have one or more of these various attributes. In general the framework can use many of the attributes associated with Quartz. As is known in the art Quartz is part of the Mac OS X graphics and windowing environment. In addition to the attributes associated with Quartz the framework can define other attributes discussed below. Some of the attributes discussed below are referenced in terms of Quartz.

A bounds attribute for a layer is a CGRect type of attribute which in Quartz is the data structure that represents the location and dimensions of a rectangle. The bounds attribute gives a layer s intrinsic bounds in the coordinate system of the layer. In the framework of the present disclosure it may be desirable to also define attributes for a filter and a shadow coordinate system that can be used if a layer is scaled.

A position attribute is a CGPoint type of attribute which in Quartz is the data structure that represents a point in a two dimensional coordinate system. The position attribute defines the position of a layer in parent layer s coordinate system. This is the center of the layer s bounds rectangle transformed to the parent layer s coordinate system.

A parent attribute defines a layer as a parent layer e.g. superlayer in relation to other layers in the hierarchy of the data structures. Similarly a children attribute is an NSArray type of attribute that defines sublayers. A contents attribute for a layer is a CGLayerRef type of attribute which defines an opaque attribute type that represents a Quartz layer. The contents attribute gives the results of the last draw captured as a display list. The contents attribute can also be set directly allowing the contents of a layer to be set from a CGLayerRef.

An hidden attribute for a layer is a Boolean type of attribute. The hidden attribute is TRUE if the layer and all of its sublayers is not to be displayed. This allows an object to stay in the layer tree but not necessarily be rendered for display. When the state of this attribute changes the appropriate implicit animation e.g. dissolve appear etc. is performed on the layer.

 Flag attributes for a layer are attributes that can be used for various purposes. For example flag attributes can be provided for autoresize mask content resize mask and redraw. An autoresize mask flag can indicate whether the mask should be autoresized. A content resize mask flag can be used to determine how to map content when a layer s bounds do not match its content s bounds. A needs redraw flag can indicate that a redraw is needed when bounds of a layer change. To a developer however these flag attributes will simply appear as normal attributes.

An extendedAttributes attribute for a layer is defined in Apple s NSDictionary class which declares an API for objects that manage immutable associations of keys and values. This attribute gives a dictionary of extra attributes that can be set by calling the method setValue forKey on a layer. When these extended attributes are set on a layer the render tree can preferably smoothly animate the value from one state to another. A developer using the framework to create an application however will not perceive any difference between attributes and extended attributes.

An actions attribute is also defined in NSDictionary. This attribute gives a dictionary of animation behaviors such as visibility animation durations etc. The dictionary maps property names to animation objects which is how implicit animations are overridden as discussed previously.

As noted above the framework can have a number of attributes defined in a dictionary for a layer. The dictionary contains additional appearance attributes. These attributes and all layer attributes can be set via Key Value Coding KVC which is a protocol of Apple s Cocoa for getting and setting values generically. The attributes are added to the dictionary when set using KVC and are searched for in the dictionary when the attributes are looked up. If the attribute is not present and the extended attribute dictionary has a style key discussed below the lookup continues recursively. If no value is found during the lookup process a default value is adopted. This allows extended attributes to exist in a styling hierarchy and allows attribute bundles to be efficiently shared among multiple layers. Because the layer tree is not traversed at the frame rate e.g. of the lookup operation for extended attributes may not be computationally expensive. An efficient render tree implementation would likely deal with flattened attributes exclusively.

The following Table 2 provides a number of attributes that can be used for layers in the framework . Additional attributes or properties are defined in the incorporated file LKLayer. 

In addition to the attributes discussed above the framework has a number of methods or functions some of which have already been discussed and some of which will now be discussed. A drawSelf function is used to draw a layer into a CGContext. In Quartz the CGContext defines an opaque type of graphics context that represents a Quartz 2D drawing environment and that functions to create manage and operate on the drawing environment. As is known in the art Quartz 2D is a two dimensional drawing API that allows developers to produce many of the visual effects e.g. translucency drop shadows etc. used in the user interface of Mac OS X. The render tree needs the complete description of layers in order to provide animation so the function is configured for the layer to draw itself. A layer that provides scrolling should just draw its entire contents. If an incremental update is to be performed on the scrollable view then some of the view can be left blank for update later. This function is similar to an NSView drawSelf function.

A setValue forKey function sets layer attributes to new values. This will usually result in an animation in the render tree . If a transaction is open the update will be appended to that transaction. If no transaction is open an implicit transaction is created and the update is added to that transaction so the update can be sent to the render tree for processing. A display function can send display instructions externally. It is only necessary to call the display function when the drawSelf function needs to compute a new state for the layer. A layoutSublayers function can be overridden by subclassers to be called when bounds of a layer change. If not overridden the layout of children layers will use auto resizing when bounds change because auto resizing is always used when bounds change.

To provide custom animations for certain events the method actionForKey can be overridden to return an LKAnimation object. For example the method actionForKey can be overriden when the hidden attribute changes to specify Swirl In as opposed to the default appearance animation. A setAutoResizeMask function is similar to NSView s autoresize mask and can be used to controls the constraints between a layer s frame and its superlayer s bounds.

An LKTransaction begin method can be used to open a transaction session for a layer and all of its sublayers . Transactions can nest. Only when the outermost transaction is closed is the data committed to the render tree . An LKTransaction commit method ends the current transaction. Only when the outermost transaction is closed is the data committed to the render tree . An additional method can be provided to abort a current transaction so that the layer tree can be reset to initial values.

The GUI for the application will typically have layers that incorporate interactive behavior for producing events. For example a layer of the application can represent a button of the GUI. Because a button in the framework is made up of many sublayers e.g. title left cap center right cap shadow the hierarchy for interacting with the button is likely to be much coarser grained than the layer tree . Accordingly the framework can provide a protocol implemented by the layers that provide interactive behaviors e.g. a mouse suite of methods a keyboard suite etc. . Alternatively the layers for the button or other interactive event can be aggregated into an interactive object defined in the framework so that the individual layers can be handled together as a group.

For example the framework can define action objects that respond to events via the LKAction protocol. The LKAction protocol which is included in the incorporated file LKAction may be used to trigger an event named as a path on a receiver function. The layer on which the event happened is identified in the protocol and arguments of the protocol can carry various parameters associated with the event. When an action object is invoked it receives three parameters the name of the event the layer on which the event happened and a dictionary of named arguments specific to each event kind. There are three types of events property changes externally defined events and layer defined events. Whenever a property of a layer is modified the event with the same name as the property is triggered. External events are determined by calling a key path and looking up the action associated with the event name.

As noted previously separating the layer tree process from the render tree process offers a number of benefits in the framework of the present disclosure. In addition to these benefits the framework of the present disclosure preferably improves resource management using a dirty regions technique and a buffer handling technique discussed below.

Preferably operation of the render tree process and render engine focuses on dirty regions of the render tree . The dirty regions includes those layers of the render tree that need to be rendered because changes have been made to those layers . During operation the render tree process determines which regions layer sublayer group of layers etc. have changed and appends the associated layers with a change object which is diagrammatically shown in as element . Change objects are added to the data structure of the render tree for the associated layers . The change objects are updated with each transaction of the render tree process to keep track of which layers of the render tree that have changed relative to their immediate prior version.

During rendering and compositing the marked layers are then stored in a cache. The storage of the marked layers accounts for the relationships of the layers in the render tree to one another and in addition accounts for changes to the layers due to animation. When a sublayer is changed for example it is marked as changed and any parent layer of it in the render tree is also marked as having something that has changed. The cache does not store the actual contents pixel information etc. of the layers . Rather each affected layer is stored. The cached layers are then made available to the render engine for rendering. By focusing on the dirty regions the render engine can operate more efficiently and reduce the amount of image that is updated via compositing to only those layers of the render tree that have been modified since the last composite operation.

Rendering processes may not necessarily use resources efficiently e.g. memory time etc. . Referring to one embodiment of a rendering process to improve resource management is schematically illustrated. The rendering process includes an application one or more buffers or backing stores a buffer handler a framework a render engine a frame buffer scan out hardware and a display .

In much the same manner as discussed in previous embodiments the framework includes a layer tree not shown and a render tree not shown which require buffers in memory. The render engine renders information from the framework and inputs the rendered information into the frame buffer and the scan out hardware outputs the information from the frame buffer to the display . To improve resource management the buffer handler operates in conjunction with the framework and controls the buffers used for the layer tree and or the render tree of the framework .

A process of how the buffer handler manages buffers for the layer tree of the framework is shown in flow chart form in . For the sake of understanding in the discussion that follows reference is concurrently made to elements in the rendering process of and to blocks of the process of . In general the buffer handler can handle a set of the buffers and for each layer of the application s GUI. In addition more than two buffers and can be used for each set.

Initially an application operating in the user space of a computer system writes GUI information to an initial buffer or backing store B allocated in memory Block . At some point the application may receive an update to a region e.g. one or more layers of the GUI information in the initial buffer B. For example a user may make a change in the application e.g. a layer may be moved resized etc. after the initial buffer B has been created. The buffer handler is notified by the application that a subregion of the initial buffer B is to be updated Block . For example as discussed above changes made to the GUI information of the application are committed to the layer tree not shown of the framework which can then provide notice to the buffer handler . In response the buffer handler creates a new buffer B and copies the entire contents from the initial buffer B to the new buffer B except for the subregion to be updated Block . The framework then uses the new buffer B for its graphics animation and compositing operations and the render engine renders from the new buffer B Block .

Subsequently the buffer handler notifies the kernel space to mark the initial buffer B as purgeable Block . Marking the initial buffer B as purgeable means that the memory associated the initial buffer B can be reclaimed by the kernel space if needed by the kernel during subsequent processing otherwise the initial buffer B will be left as it is.

During subsequent processing the application obtains a new update region and notifies the buffer handler Block . The buffer handler determines from the kernel space whether the initial buffer Bhas been reclaimed Blocks and . If it has been reclaimed i.e. the kernel space let the initial buffer B be purged during subsequent processing then buffer hander must get new memory and create a new initial buffer B Block . Then the application writes to this new initial buffer B Block and the process repeats. For example the buffer handler creates a new buffer B Block copies all of the initial buffer Binto the new buffer Bexcept of for the new update region Block . The framework can process on the new buffer Bto implement animations for example and the render engine renders from the new buffer B Block and the initial buffer Bis marked as purgeable Block until the next new update region is obtained.

Advantageously however the initial buffer B that was marked as purgeable at Block may not have been reclaimed. If it has not been reclaimed at Block after the application has received the new update region then the buffer handler may only need to update part of that old initial buffer B in order to use it again for processing. In this situation the buffer handler updates the old initial buffer B by copying into it the differences between it and the previous updated region Block . From this point the old initial buffer B can be reused for processing. Accordingly the buffer handler creates a new buffer B Block copies all of the old initial buffer B into the new buffer Bexcept of for the new update region Block . The framework process on and the render engine renders from the new buffer B Block and the old initial buffer B is again marked as purgeable Block until the next new update region is obtained.

The foregoing description of preferred and other embodiments is not intended to limit or restrict the scope or applicability of the inventive concepts conceived of by the Applicants. In exchange for disclosing the inventive concepts contained herein the Applicants desire all patent rights afforded by the appended claims. Therefore it is intended that the appended claims include all modifications and alterations to the full extent that they come within the scope of the following claims or the equivalents thereof.

