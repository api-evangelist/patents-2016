---

title: Profiling multiple virtual machines in a distributed system
abstract: A task comprising at least a first subtask on a computer system is analyzed. As part of the analysis, a profiler controller transmits a first profile instruction to a first profiler instance. The profiler controller transmits a second profile instruction to a second profiler instance. In response to the first profile instruction, the first profiler instances embeds a first task identifier into a first subtask request sent by a first virtual machine. In response to the second profile instruction, the second profiler instance captures the first task identifier from the first subtask request received by a second process virtual machine. The profiler controller identifies an execution instance of the task of the computer system based on the first copy and the second copy of the first task identifier received from the first profiler instance and the second profiler instance, respectively.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09619273&OS=09619273&RS=09619273
owner: International Business Machines Corporation
number: 09619273
owner_city: Armonk
owner_country: US
publication_date: 20160222
---
The present disclosure relates to profiling tasks performed in distributed systems and more specifically to tracing calls across virtual machines to enable profiling in a distributed computing system.

Distributed computing systems provide a seamless computing experience to end users from a variety of computer hardware and software. These systems may enable more complicated computing tasks with no more complexity to end users. The distributed computing systems may enable computing resources to solve more complex problems than those problems that can be solved on a singular computing device. The distributed computing systems may enable modularity and scalability of computing resources.

Embodiments of the disclosure may include a method computer program product and system of analyzing a task comprising at least a first subtask on a computer system. A profiler controller transmits a first profile instruction to a first profiler instance. The first profile instruction is to profile a first virtual machine. The profiler controller transmits a second profile instruction to a second profiler instance. The second profile instruction is to profile a second virtual machine. In response to the first profile instruction the first profiler instance embeds a first task identifier into a first subtask request sent by the first virtual machine. The profiler controller receives a first copy of the first task identifier from the first profiler instance. In response to the second profile instruction the second profiler instance captures the first task identifier from the first subtask request received by the second process virtual machine. The profiler controller receives a second copy of the first task identifier from the second profiler instance. The profiler controller identifies an execution instance of the task of the computer system based on the first copy and the second copy.

While the invention is amenable to various modifications and alternative forms specifics thereof have been shown by way of example in the drawings and will be described in detail. It should be understood however that the intention is not to limit the invention to the particular embodiments described. On the contrary the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the invention.

Aspects of the present disclosure relate to profiling tasks performed in distributed systems more particular aspects relate to tracing calls across virtual machines to enable profiling in a distributed computing system. While the present disclosure is not necessarily limited to such applications various aspects of the disclosure may be appreciated through a discussion of various examples using this context.

Computing resources are increasingly provided to users through layers of abstraction by distributed computing systems or environments herein distributed systems . These distributed systems may provide to users conventional computing resources such as processing memory and long term storage with increased scalability that a singular computing device cannot provide. Moreover distributed systems may provide advantages over installations of multiple computers at a single physical location such as redundancy and energy efficiency.

For these benefits and others distributed systems have been adopted in a variety of industries. In telecommunications services distributed systems provide the resources to run wireless and wired networks. Ubiquity of service nurtured through the telephone system demands that the Internet be provided seamlessly to end users an ideal demand for distributed systems to meet. Likewise complex computational problem solving alternatively clustering or grip computing requires massive amounts of processing power. Distributed systems are often the only systems that can operate on the large data sets required by complex computational problem solving. Finally the ability to take advantage of cloud computing where ever present network services meet centralized data and resources is often not possible without distributed systems.

Historically software has been created for a single computer system e.g. a software program that runs on a physical machine . The software performs tasks requested by the user such as browsing a collection of files or calculating a mathematical formula. Often to implement a distributed system software developers have utilized virtual machines to create software. Virtual machines alternatively process virtual machines or system virtual machines emulate the resources of a typical physical computer or program execution environment in a software construct. Virtual machines provide flexibility and portability to programs e.g. a computer system of one architecture can execute software written for another architecture by a virtual machine .

Profilers have enabled software written for a singular computing machine to be observed. As users request tasks to be performed by a software program a profiler may be able to analyze the software program and provide information about program execution e.g. memory usage call patterns stack information and timestamps . Additionally there exist profilers for virtual machines such that a user may analyze the performance of the software program as it performs tasks. To allow distributed systems to scale upwards in complexity of tasks and number of users software developers increasingly split tasks into multiple subtasks. This provides a challenge for profilers.

In detail tasks conventionally performed by a single machine software program in a distributed system are divided into subtasks that can be performed by a series of virtual machines. Traditional approaches to profiling software have various drawbacks when determining the performance of multiple virtual machines. A conventional profiler may be adapted to profile the entire task through multiple virtual machines. However because all communication internal and external of all virtual machines of the distributed system must be recorded it may be an impractical way to provide meaningful performance information. Additionally adapted profilers may only record information based on periodic checks which may exclude some meaningful interaction between virtual machines. An adapted conventional profiler may provide information for a distributed system executing a single task. But as a distributed system scales to perform many tasks concurrently the information is ineffectual to identify distributed system performance. Using a single profiler to provide information about one of many virtual machines is also of limited value. While any subtasks being performed in the profiled virtual machine may be observed the vast majority of subtasks those sent to other virtual machines yield no profiled information. Finally existing profiling techniques are inoperable to diagnose distributed systems for a variety of other reasons e.g. unacceptable impact on the function of the distributed system while performing a production environment load inability to pinpoint performance problems inability to provide accurate information and inability to enable and disable portions of the profiling capability in the middle of a task or tasks being performed .

Consistent with various embodiments a distributed profiler may enable users to determine performance characteristics of a distributed system. A distributed profiler may comprise a profiler controller and multiple profiler instances. It should be appreciated that in instances where a performance problem is identified in a specific virtual machine of a distributed system a distributed profiler may operate with a single profiler instance. The distributed profiler may operate separately from any existing virtual machine profiler or system profiler. The distributed profiler may operate in concert with an existing virtual machine profiler by altering the default functionality of an existing virtual machine profiler e.g. by utilizing delegation . The distributed profiler may monitor a virtual machine while minimally altering performance of the virtual machine which provides the user with meaningful information regarding the distributed system. The distributed profiler may be able to identify a task that has been subdivided into a variety of subtasks as the subtasks are called and results from the subtasks are returned from a multitude of virtual machines. The distributed profiler may be able to operate across a local area network. The distributed profiler may be able to operate across a wide area network such as the Internet.

A distributed system may operate based upon computers B and C and may comprise virtual machines A B and C collectively . Computer B may execute virtual machine A and computer C may execute virtual machine B and virtual machine C. The distributed system may perform tasks for one or more users by dividing each of the tasks into subtasks to be performed by the virtual machines . The virtual machines may perform a single subtask. In some embodiments one or more of the virtual machines may perform multiple subtasks.

The virtual machines may communicate with each other by using one or more communication streams A B and C collectively . Virtual machine A may use communication stream A virtual machine B may use communication stream B and virtual machine C may use communication stream C respectively. The communication streams may send data from and receive data for the virtual machines . In some embodiments the communication streams may be two data streams e.g. an output stream for sending data and an input stream for receiving data . In some embodiments there may be one or more communication streams for each subtask of a given virtual machine. The communication streams may transport subtask calls between the virtual machines . The communication streams may transport subtask calls between subtasks of the same virtual machine e.g. a first subtask on virtual machine C may utilize communication stream C to transport a subtask call to a second subtask on virtual machine C .

The distributed system may provide a service to end users. For example a photo sharing service may be hosted by the distributed system and may be accessible to end users by means of the Internet. The photo sharing service may be divided into a multitude of subtasks not depicted . Virtual machine A may perform the following subtasks a first subtask for receiving end user requests for navigating a user interface saving and sharing pictures creating associations between pictures and altering metadata of pictures and altering content of pictures a second subtask for receiving pictures from end users and a third subtask for sharing pictures with services external to the distributed system. Virtual machine B may perform the following subtasks a fourth subtask for detecting faces of humans in pictures and creating metadata based upon the detected faces a fifth subtask for saving metadata of pictures and a sixth subtask for saving associations between pictures. Virtual machine C may perform the following subtasks a seventh subtask for saving new pictures uploaded from end users to long term storage not depicted an eighth subtask for retrieving pictures from the long term storage a ninth subtask for altering the content of pictures and a tenth subtask for rendering the user interface.

The distributed profiler may comprise profiler instances A B C collectively and a profiler controller . The profiler instances may be capable of profiling the virtual machines as they process subtasks e.g. profiler instance A may profile virtual machine A profiler instance B may profile virtual machine B and profiler instance C may profile virtual machine C . The profiler instances may be able to collect information regarding the virtual machines and any subtasks being performed by the virtual machines . In some embodiments the profiler instances may be able to collect a set of profiler data i.e. one or more attributes about the virtual machines . The profiler instances may embed a unique identifier into subtask calls to track an instance of a task executed by the distributed system.

The profiler controller of the distributed profiler may instruct the profiler instances to begin operation at the same time. In some embodiments the profiler controller may instruct the profiler instances to begin operation independently of each other such as instructing only profiler instance B to begin operation. The profiler controller may execute on computer A and may send communication to the profiler instances through the network . In some embodiments the profiler controller may execute from computer B or computer C and communication to one or more of the profiler instances may take place without use of the network . The profiler controller may receive profiler information from the profiler instances and may evaluate performance based upon this information. The profiler controller may instruct the profiler instances based upon the profiler information received from the profiler instances.

The profiler controller may know the architecture and topology of the distributed system. The profiler controller may know the interaction between the computers the virtual machines and the communication streams of the distributed system. The profiler controller may know when the virtual machines use the communication streams to communicate internally e.g. a subtask on virtual machine A calling another subtask on virtual machine A . The profiler controller may know when the virtual machines use the communication streams to communicate externally e.g. subtask on virtual machine A calling another subtask on virtual machine B . The profiler controller may instruct the profiler instances based upon its knowledge.

The distributed profiler may analyze tasks performed by the distributed system. To continue the above example as users begin to operate the described photo sharing service the virtual machines cooperatively perform subtasks. If a system administrator wants to observe performance of the photo sharing service while users are using the photo sharing service the system administrator may utilize the distributed profiler . To begin profiling the photo sharing service the profiler controller may send a first instruction to profiler instance A. Profiler instance A may begin to profile the operation of virtual machine A in response to the first instruction. As users navigate the photo sharing service subtasks may be performed by virtual machine A and attributes of performance may be captured by profiler instance A. Profiler instance A may record attributes such as the start times and end times of instances of the first subtask second subtask and third subtask described above. Profiler instance A may also record other attributes about instances of the first subtask second subtask and third subtask e.g. performance of code sections of the subtasks names of variables created by the subtasks memory used by the subtasks processing cycles of the subtasks processor utilization of the subtasks etc. . In some embodiments profiler instance A may also record other attributes about virtual machine A generally e.g. total memory used total processing time network utilization etc. .

Profiler instance A may transmit the attributes regarding virtual machine A to the profiler controller . The profiler controller may identify a first task of the distributed system e.g. an execution instance of a first user of the photo sharing service in response to the attributes received by profiler instance A. In a usage example if the first user requests to alter the metadata of some photos virtual machine A may execute a first instance of the first subtask and profiler instance A may identify that the first instance is related to the first user. Virtual machine A may also make a first call to virtual machine C to render the graphical user interface for the first user. Virtual machine C may execute a first instance of the tenth subtask to render the user interface a first instance of the ninth subtask to retrieve pictures from long term storage and then return execution to virtual machine A. The profiler instance A may capture attributes of virtual machine A before the first call to and after a first return from virtual machine C and may transmit attributes to the profiler controller . However the profiler controller may be unable to understand any detail regarding virtual machine C after the first call and before the first return e.g. subtask performance of virtual machine C resource usage by virtual machine C subtask calls from virtual machine C to virtual machine B etc. .

To fully understand execution of the distributed system the profiler controller may transmit through the network a second instruction to profiler instance B to profile virtual machine B and a third instruction to profiler instance C to profile virtual machine C. In response to the second instruction profiler instance B may begin collecting attributes related to the operation of virtual machine B. In response to the third instruction profiler instance C may begin collecting attributes related to the operation of virtual machine C. Based on the first instruction the second instruction and the third instruction the profiler instances may begin encoding subtask calls to the virtual machines . The profiler instances may modify the communication streams to encode the subtask calls. This encoding of the subtask calls may include altering the name field of the subtask calls. In some embodiments the encoding of the subtask calls may include altering other fields e.g. an altered identification field an altered header an altered footer an altered unused field an altered debug field etc. . The format of the altered field may be a fixed length string. The format of the altered field may be a unique identifier such as a key. The format of the altered field may be a combination of a values. The format of the altered field may be further modified for speed size security or other reason e.g. hashing . The altered field may be generated by the profiler instances . In some embodiments the altered field may be generated by the profiler controller . Based on the first instruction the second instruction and the third instruction the profiler instances may also begin decoding subtask calls from the virtual machines . The profiler instances may modify the communication streams to decode the subtask calls. After a subtask call has been processed by one of the virtual machines the virtual machines may generate a subtask return. The profiler instances may encode and decode the subtask returns in a similar manner to the encoding and decoding of the subtask calls.

Referring again to the photo sharing system example above but prior to the first user requesting to manipulate the metadata of some photos the profiler controller may transmit instructions to the profiler instances A and C. In response to the instructions the profiler instances A and C may begin to profile the virtual machines A and C respectively. In response to the instructions the profiler instances A and C may profile the communication streams A and C respectively by encoding subtask calls with unique identifiers. When the first user requests to alter the metadata of some photos virtual machine A may execute a first instance of the first subtask and the profiler instance A may identify that the first instance is related to a first task the first user manipulating metadata . Profiler instance A may record attributes of virtual machine A including the execution of the first instance of the first subtask. Virtual machine A may make a first call to virtual machine C to render the graphical user interface for the first user. Profiler instance A may intercept the first call to virtual machine C and embed a first identifier into the first call copy the first identifier and pass the first call to the communication stream A. Profiler instance A may associate the recorded attributes with the first identifier and pass the recorded attributes and the first identifier to the profiler controller .

When communication stream C receives the first call for virtual machine C profiler instance C may intercept the first call. Profiler instance C may copy the first identifier from the first call remove the first identifier from the first call and pass the first call to virtual machine C. Virtual machine C may execute a first instance of the tenth subtask to render the user interface and a first instance of the ninth subtask to retrieve pictures from long term storage in response to the first call. Profiler instance C may record attributes of virtual machine C including the execution of the first instance of the tenth subtask and the execution of the first instance of the ninth subtask. After execution virtual machine C may transmit a first return from the first call to virtual machine A. Profiler instance C may associate the recorded attributes with the first identifier. Profiler instance C may intercept the first return embed the first identifier into the first return and pass the first return to communication stream C. Profiler instance C may associate the recorded attributes with the first identifier and transmit the attributes of execution by virtual machine C and the first identifier to the profiler controller .

When communication stream A receives the first return for virtual machine A profiler instance A may intercept the first return. Profiler instance A may copy the first identifier from the first return remove the first identifier from the first return and pass the first return to virtual machine A. As virtual machine A continues performing subtasks for the first user the profiler instance A may continue to record attributes and associate the attributes with the first identifier. Profiler instance A may transmit the attributes of execution by virtual machine A and the first identifier to the profiler controller .

The profiler controller may identify an instance of the task the first user manipulating metadata being executed based upon the attributes and the copies of the first identifier sent from profiler instances A and C. As execution continues and other subtasks are executed by the virtual machines A and C the profiler instances A and C may continue to associate subtasks and subtask calls with the task and the profiler controller may continue to identify the execution instance of the task and sets of profiler data related to the task. During execution of the distributed profiler if the administrator wants to capture performance of virtual machine B the profiler controller may transmit an instruction to profiler instance B. In response to the instruction operation of profiler instance B may commence similarly to operation of profiler instances A and C. If multiple users are executing tasks on the distributed system at the same time the distributed profiler may coordinate execution of the subtasks by the distributed system in the same way e.g. a second task comprised of a second set of subtasks executed by the virtual machines is identified by the profiler controller a third task comprised of a third set of subtasks executed by the virtual machines is identified by the profiler controller etc. . As they are identified each task may be associated with a different unique identifier to ensure the profiler controller may be able to evaluate the performance of each task in the distributed system.

Each profiler instance of a distributed profiler may include a socket profiler and a local profiler. In some embodiments method of using the socket profiler may be executed by each profiler instance of the distributed profiler. Further some operations of method may be executed by both each of the profiler instances and the profiler controller of the distributed profiler. The method may comprise only a portion of execution of each profiler instance and additional methods not depicted may also be performed.

At start the first profiler instance may begin to intercept calls of communication from the first virtual machine e.g. from an outbound communication socket of the first virtual machine . This ability to intercept calls may be enabled by altering the code of the first virtual machine such as embedding an outbound communication monitor. The outbound communication monitor may operate based on a network socket application programming interface. Because the outbound communication monitor may operate at the socket level any higher level communication may be captured by the intercepting of calls . At a determination may be made as to whether a call should be altered. The determination of call alteration at operation may be based upon a set of rules e.g. one or more values related to the distributed system one or more values related to the distributed profiler . The set of rules may be received from the profiler controller. The set of rules may be based upon whether a call is intended for a different virtual machine. The set of rules may be based upon the name of a subtask being called by the call. The set of rules may be based upon a network address in the call. The set of rules may be based upon whether the virtual machine specified in the call is also being profiled by the distributed profiler.

If a determination is made that the call should be altered at a call token is generated by the first socket profiler at . In some embodiments the call token may be generated by the profiler controller. The call token may be a unique identifier. The call token may be generated by altering an existing value of the first virtual machine such as a date field or name field. The call token may be generated by combining multiple fields or values together. The newly generated call token may be embedded into the call at . The call token may be embedded by overwriting an entire field such as the name field of the call. The call token may be embedded by appending a field such as by being inserted into the beginning of the id field of the call. At the first socket profiler may update a local record cache of the first profiler instance with a set of profiler data regarding the call. The record may also be updated with the token from the call. The updated record may be transmitted by the first profiler instance to the profiler controller.

After the call record is updated per or after if it is determined that the call should not be altered the first socket profiler will instruct the socket monitor to pass the call to the output communication functionality of the first virtual machine at . The first virtual machine may then pass the call to an appropriate second virtual machine and the second virtual machine may execute subtasks based upon the call. The second virtual machine may generate a call return and may transmit the call return to the first virtual machine. The first socket profiler may intercept call returns at of communication from the second virtual machine. The functionality of intercepting call returns at may be enabled by altering the code of an inbound communication socket of the first virtual machine such as by inserting an inbound communication monitor. The inbound communication monitor may operate based on the network socket application programming interface.

At a determination if the call return contains a token may be performed. In some embodiments the determination at may be made as to whether a call return should be altered. The determination of call return alteration at may be based upon a set of rules similar to the rules for determining call alteration at . The determination of call return alteration at may also be based upon the record kept by the first profiler instance. For example if the call was altered by having a call token embedded the first socket profiler may compare the intercepted call return with the record and determine if the token exists.

If a determination is made that the call return contains a token at the token may be stripped from the call return at . At the first socket profiler may update the local records of the first profiler instance with a set of profiler data regarding the call return. The record may also be updated with the token from the call return. After the records are updated per or after if the determination is made that the call return does not contain the call token the call return is passed to the first virtual machine for execution at and method ends at .

Each profiler instance of a distributed profiler may include a socket profiler and a local profiler. In some embodiments method of using the socket profiler may be executed by each profiler instance of the distributed profiler. Further some operations of method may be executed by both each of the profiler instances and the profiler controller of the distributed profiler. The method may comprise only a portion of execution of each profiler instance and additional methods not depicted may also be performed.

At start a second profiler instance may begin to intercept requests of communication transmitted to the second virtual machine e.g. from an inbound communication socket of the second virtual machine . This ability to intercept requests may be enabled by altering the code of the second virtual machine such as embedding an inbound communication monitor. The inbound communication monitor may operate based on a network socket application programming interface. At a determination may be made as to whether a request e.g. the call in the description of contains a token. The determination at operation may be based upon a second set of rules e.g. one or more values related to the distributed system one or more values related to the second distributed profiler . The second set of rules may be received from the profiler controller.

If a determination is made that the request contains a token at the request token is stripped by the second socket profiler at . At the second socket profiler may update a second local record cache of the second profiler instance with a set of profiler data regarding the request. The second record may also be updated with the token from the request e.g. a copy of the token in the description of . The updated second record may be transmitted by the second profiler instance to the profiler controller. The second socket profiler may then pass the request to the second virtual machine at .

If it is determined that the request does not contain a token at then the second socket profiler will instruct the second socket monitor to pass the request to the second virtual machine at . The second virtual machine may then execute subtasks based upon the request. The second virtual machine may generate a request return e.g. the call return in the description of and may transmit the request return to the first virtual machine. The second socket profiler may intercept request returns at of communication from the second virtual machine. The functionality of intercepting request returns at may be enabled by altering the code of an outbound communication socket of the second virtual machine such as by inserting an outbound communication monitor. The outbound communication monitor may operate based on the network socket application programming interface.

At a determination if the request return should be altered may be made based upon the second record kept by the second profiler instance. For example whether the request related to the request return contained a token. If a determination is made that the request return should be altered at the token may be embedded in the request return at . At the second socket profiler may update the second local records of the second profiler instance with a set of profiler data regarding the request return. The second record may also be updated with the token from the request return. After the second local records are updated per or if it is determined at that the request return should not be altered then the second socket profiler may instruct the second socket monitor to pass the request return to the output communication functionality of the second virtual machine at and method ends at .

The distributed profiler may comprise profiler instances A and B collectively and a profiler controller . Profiler instance A may comprise a profiler loader A a local profiler A and a socket profiler A. Local profiler A and socket profiler A may record one or more attributes regarding virtual machine A into a local runtime record A. Profiler instance B may comprise a profiler loader B a local profiler B and a socket profiler B. Local profiler B and socket profiler B may record one or more attributes regarding virtual machine B into a local runtime record B. The profiler loaders A and B collectively may direct operation of local profilers A and B collectively respectively. The profile loaders A and B may also direct operation of socket profilers A and B collectively respectively. The profiler loaders may direct operation based on standard byte code instrumentation. The profiler loaders may receive communication from the profiler controller . The profiler loaders may direct operation of the local profilers and the socket profilers independently.

The local profilers may profile virtual machines . In detail local profiler A may profile virtual machine A and subtask A. Local profiler B may profile virtual machine B and subtasks B and C. The local profilers may profile by collecting attributes of the virtual machines A and B such as subtask call times and frequencies of function execution. The local profilers A and B may record the attributes into the local runtime records A and B collectively respectively. In some embodiments the local profilers may keep track of the subtasks and subtask calls to identify a call chain alternatively execution instance corresponding to a task executed by the distributed system. In some embodiments the local profilers may associate the call chains and other attributes with a unique identifier.

The socket profilers may profile the communication streams . In detail socket profiler A may profile communication stream A. Socket profiler B may profile communication streams B and C. The socket profilers may profile by collecting attributes of the communication streams such as subtask calls subtask call identifiers and called virtual machine names or identifiers. The socket profilers A and B may record the attributes into the local runtime records A and B respectively. In some embodiments the local profilers may add to append or modify the call chains and other attributes in the local runtime records . The socket profilers may intercept the communication streams and alter subtask calls. The socket profilers may use a modified version of stream monitors A B and C collectively of the communication streams . The socket profilers may use modified versions of input stream monitor code segments and output stream monitor code segments of the stream monitors to intercept and alter subtask calls. The modified version of the stream monitors may utilize code delegation techniques. The stream monitors may be existing code segments that are a part of the communication streams that are associated with the virtual machines .

The modified version of the output stream monitor of the stream monitors may generate the unique identifier. The unique identifier may be in a standardized form recognized by all of the profiler instances . The unique identifier may be generated using known coding techniques such as fixed length keys random number generators multiple field combinations field prefixes and suffixes combinations of existing fields and newly generated unique identifiers etc.

The profiler controller of the distributed profiler may comprise a master controller a system deployment architecture herein SDA and a statistics collector . The profiler controller may unify and categorize data from the profiler instances to provide meaningful information regarding the distributed system such as call chains of the subtasks across virtual machines . The master controller may transmit instructions to the profiler loaders . The instructions from the master controller may command the local profilers or the socket profilers to begin or cease operation. The master controller may instruct the operation of the various components of the profiler instances independently of each other. The master controller may instruct the operation of profiler instance A independently of profiler instance B. In some embodiments the master controller may transmit operation of a given profiler instance to the SDA . The master controller may receive requests from an end user of the distributed profiler e.g. a system administrator .

The SDA of the profiler controller may retrieve operation of a given profiler instance from the master controller . The SDA may have knowledge of the layout and operation of the distributed system such as which virtual machines execute which subtasks and which communication streams are used by which virtual machines for external communication to other virtual machines. In some embodiments the SDA may have knowledge of the operation of the distributed system that is not directly profiled by the distributed profiler e.g. the organization of virtual machine C and of subtasks D E and F . The SDA may have knowledge of operation of the profiler instances . The SDA may instruct the profiled output stream monitor of the stream monitors . The SDA may instruct a given profiled output stream monitor to embed unique identifiers into subtask calls. The SDA may instruct the stream monitors based upon the knowledge of the distributed system and the knowledge of operation of the profiler instances .

The statistics collector of the profiler controller may generate profiler information for the end user. The statistics collector may retrieve attributes and associated unique identifiers from the local runtime records . The statistics collector may analyze the attributes and unique identifiers from the local runtime records to generated profiler information. The statistics collector may generate summaries based upon information collected from the local runtime records e.g. execution instances subtask call chains identified tasks across virtual machines aggregate execution time etc. . The statistics collector may output the profiler information to a profiler results file or table.

The distributed profiler may be able to identify patterns of execution that slow operation of the distributed system. For example the distributed system may be performing three different tasks. The tasks may be comprised of a series of subtasks subtask calls and subtask returns. The first task may comprise the following subtask A a call to subtask B subtask B a call to subtask D subtask D a return to subtask B and a return to subtask A. The second task may comprise the following subtask A a call to subtask B subtask B a call to subtask E subtask E a call to subtask B subtask B a return to subtask E a return to subtask B and a return to subtask A. The third task may comprise the following subtask A a call to subtask C subtask C a call to subtask B subtask B a call to subtask F subtask F a return to subtask B a return to subtask C a call to subtask E subtask E a return to subtask C and a return to subtask A.

To continue the example the master controller may instruct profiler instance A to begin profiling virtual machine A. The local profiler A may monitor subtask A and record profiling information into local runtime record A. As the first task the second task and the third task are performed the local profiler A may only profile subtask A and record any calls to subtasks located on virtual machine B. e.g. calls to subtasks B and C . But the distributed profiler may not record any profiling information of the distributed system until a return to subtask A occurs.

The master controller may instruct profiler instance B to begin profiling virtual machine B. The SDA may detect that profiler instance B has been instructed to begin profiling virtual machine B and may instruct stream monitor A to encode unique identifiers into subtask calls to virtual machine B. As the profiler instances profile virtual machines A and B the local profilers and socket profilers may record and associate profiling information with the unique identifiers. As execution of the distributed system occurs now the local profilers and the socket profilers of profiler instance A and B may record profiling information of the distributed system into the local runtime records A and B respectively. The statistics collector may retrieve the profiler information from the local runtime records and may generate call chains and other performance related data about the execution of the first second and third tasks by the distributed system. The statistics collector may record the call chains and performance related data into the profile results . From the profile results an end user may be able to see execution time of all subtasks that make up each of the first second and third tasks. An issue related to performance may be observed from this information e.g. execution of the third task while three instances of the first task are being performed causes the distributed system to run out of memory .

The processor of the computer system may be comprised of one or more CPUs A B C D herein . The processor may additionally be comprised of one or more memory buffers or caches not depicted that provide temporary storage of instructions and data for the CPUs . The CPUs may perform instructions on input provided from the caches or from the memory and output the result to caches or the memory. The CPUs may be comprised of one or more circuits configured to perform one or methods consistent with embodiments of the invention. In some embodiments the computer system may contain multiple processors typical of a relatively large system however in other embodiments the computer system may alternatively be a single processor with a singular CPU .

The memory of the computer system may be comprised of a memory controller and one or more memory modules A B C D herein . In some embodiments the memory may comprise a random access semiconductor memory storage device or storage medium either volatile or non volatile for storing data and programs. The memory controller may communicate with the processor facilitating storage and retrieval of information in the memory modules . The memory controller may communicate with the I O interface facilitating storage and retrieval of input or output in the memory modules . In some embodiments the memory modules may be dual in line memory modules DIMMs .

The I O interface may comprise an I O bus a terminal interface a storage interface an I O device interface and a network interface . The I O interface may connect the main bus to the I O bus . The I O interface may direct instructions and data from the processor and memory to the various interfaces of the I O bus . The I O interface may also direct instructions and data from the various interfaces of the I O bus to the processor and memory . The various interfaces may comprise the terminal interface the storage interface the I O device interface and the network interface . In some embodiments the various interfaces may comprise a subset of the aforementioned interfaces e.g. an embedded computer system in an industrial application may not include the terminal interface and the storage interface .

Logic modules throughout the computer system including but not limited to the memory the processor and the I O interface may communicate failures and changes to one or more components to a hypervisor or operating system not depicted . The hypervisor or the operating system may be allocate the various resources available in the computer system and track the location of data in memory and of processes assigned to various CPUs . In embodiments that combine or rearrange elements aspects of the logic modules capabilities may be combined or redistributed. These variations would be apparent to one skilled in the art.

The present invention may be a system a method and or a computer program product. The computer program product may include a computer readable storage medium or media having computer readable program instructions thereon for causing a processor to carry out aspects of the present invention.

The computer readable storage medium can be a tangible device that can retain and store instructions for use by an instruction execution device. The computer readable storage medium may be for example but is not limited to an electronic storage device a magnetic storage device an optical storage device an electromagnetic storage device a semiconductor storage device or any suitable combination of the foregoing. A non exhaustive list of more specific examples of the computer readable storage medium includes the following a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory a static random access memory SRAM a portable compact disc read only memory CD ROM a digital versatile disk DVD a memory stick a floppy disk a mechanically encoded device such as punch cards or raised structures in a groove having instructions recorded thereon and any suitable combination of the foregoing. A computer readable storage medium as used herein is not to be construed as being transitory signals per se such as radio waves or other freely propagating electromagnetic waves electromagnetic waves propagating through a waveguide or other transmission media e.g. light pulses passing through a fiber optic cable or electrical signals transmitted through a wire.

Computer readable program instructions described herein can be downloaded to respective computing processing devices from a computer readable storage medium or to an external computer or external storage device via a network for example the Internet a local area network a wide area network and or a wireless network. The network may comprise copper transmission cables optical transmission fibers wireless transmission routers firewalls switches gateway computers and or edge servers. A network adapter card or network interface in each computing processing device receives computer readable program instructions from the network and forwards the computer readable program instructions for storage in a computer readable storage medium within the respective computing processing device.

Computer readable program instructions for carrying out operations of the present invention may be assembler instructions instruction set architecture ISA instructions machine instructions machine dependent instructions microcode firmware instructions state setting data or either source code or object code written in any combination of one or more programming languages including an object oriented programming language such as Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The computer readable program instructions may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider . In some embodiments electronic circuitry including for example programmable logic circuitry field programmable gate arrays FPGA or programmable logic arrays PLA may execute the computer readable program instructions by utilizing state information of the computer readable program instructions to personalize the electronic circuitry in order to perform aspects of the present invention.

Aspects of the present invention are described herein with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer readable program instructions.

These computer readable program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks. These computer readable program instructions may also be stored in a computer readable storage medium that can direct a computer a programmable data processing apparatus and or other devices to function in a particular manner such that the computer readable storage medium having instructions stored therein comprises an article of manufacture including instructions which implement aspects of the function act specified in the flowchart and or block diagram block or blocks.

The computer readable program instructions may also be loaded onto a computer other programmable data processing apparatus or other device to cause a series of operational steps to be performed on the computer other programmable apparatus or other device to produce a computer implemented process such that the instructions which execute on the computer other programmable apparatus or other device implement the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of instructions which comprises one or more executable instructions for implementing the specified logical function s . In some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or carry out combinations of special purpose hardware and computer instructions.

The descriptions of the various embodiments of the present disclosure have been presented for purposes of illustration but are not intended to be exhaustive or limited to the embodiments disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the described embodiments. The terminology used herein was chosen to explain the principles of the embodiments the practical application or technical improvement over technologies found in the marketplace or to enable others of ordinary skill in the art to understand the embodiments disclosed herein.

