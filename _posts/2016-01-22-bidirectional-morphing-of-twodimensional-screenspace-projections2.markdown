---

title: Bi-directional morphing of two-dimensional screen-space projections
abstract: Described herein are technologies that facilitate computationally low-intensity creation of additional frames in a sequence of frames created by real-time three-dimensional (3D) rendering. More particularly, the technologies described herein generate an interposed two-dimensional (2D) screen-space projection (e.g., the resulting rendered image) in between a pair of fully rendered surrounding frames in a sequence of rendered frames. The interposed 2D screen-space projection is generated based upon information derived from the pair of surrounding frames.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09589316&OS=09589316&RS=09589316
owner: Intel Corporation
number: 09589316
owner_city: Santa Clara
owner_country: US
publication_date: 20160122
---
In the realm of computer graphics three dimensional 3D scene rendering is the 3D computer graphics process of automatically converting 3D wire frame models into two dimensional 2D images i.e. frames or screen space with 3D photorealistic effects or non photorealistic rendering on a computer or video game system.

Rendering for Interactive media e.g. games and simulations is calculated and displayed in real time at rates of approximately 20 to 120 frames per second. In real time rendering the goal is to show as much information as possible as the eye can process in a fraction of a second. For example with 30 frame per second a frame is just one 30th of a second.

Typically a real time computer graphics system seeks to achieve as high as possible degree of photorealism at an acceptable minimum rendering speed. Real time rendering is often polygonal e.g. triangles and aided by the computer s GPU.

Unfortunately 3D scene rendering is computationally intensive. It seems that the industry s state of the art graphics hardware e.g. graphics processing unit GPU struggles to keep up with the expectations of realism and the demands of the graphics programmer. That hottest new video games push the envelope on the capability of the hardware to successfully render successive 3D scenes in real time and at a frame rate i.e. pictures per second that users viewers expect.

The Detailed Description references the accompanying figures. In the figures the left most digit s of a reference number identifies the figure in which the reference number first appears. The same numbers are used throughout the drawings to reference like features and components.

Described herein are technologies that facilitate computationally low intensity creation of additional frames in a sequence of frames created by real time 3D rendering. More particularly the technologies described herein generate an interposed 2D screen space projection e.g. the resulting rendered image in between a pair of fully rendered surrounding frames in a sequence of rendered frames. The interposed 2D screen space projection is generated based upon information derived from the pair of surrounding frames. The surrounding frames include a before i.e. preceding frame and an after i.e. succeeding frame.

Consider for example a ten second sequence of frames at sixty frames per second. To accomplish this using conventional approaches each of the 600 frames of the sequence must be fully 3D rendered. However with the new technologies described herein only a fraction e.g. half 300 third 200 quarter 150 of the frames of the sequence are fully 3D rendered. The frames that are not fully 3D rendered are instead generated based upon information derived from surrounding frames which were fully 3D rendered and interposed between their associated surrounding frames. That is the frames that are not fully 3D rendered are interleaved between the fully rendered frames to form the full 600 frame sequence.

The calculations of the interposed frame generation operate primarily in the 2D screen space projection rather than with the 3D space . Because of that the computational load of the interposed frame generation is significantly less than the computational burden of 3D rendering the same frame. Also the computational load is reduced because the original pixel shaders used for rendering the fully rendered frames are not executed with the intermediate frames. Instead for at least one implementation a minimal morphing shader has used that copies two color values and writes a weighted sum of those to the output. Per pixel processing is significantly reduced.

The generation of the interposed frames is accomplished for example by metamorphosing i.e. morphing a new 2D screen space projection from the surrounding frames. The morphing uses information about the projected triangles of the 3D geometry model of at least two surrounding frames. Those surrounding frames typically are the immediately preceding frame and the immediately succeeding frame of a sequence. This geometric model information is used to calculate an anticipated change in the projected triangles between the surrounding frames.

Next the calculated triangles are colored or shaded based upon the corresponding information from the surrounding frames. In this way the distance based weighted blending of pixel color information from the preceding and the succeeding frames is used to provide a good approximation of surface lighting and or special effect change in the morphed frame being inserted.

Herein the computational savings is primarily achieved by replacing for some fraction of the frames of a sequence the massive number of calculations in the 3D space as required by 3D rendering with a substantially smaller number of calculations in the 2D space as used by morphing new 2D screen space projection from surrounding already 3D rendered frames. Indeed in addition to the 3D geometry processing that is partially avoided with this new technology there are a massive number of calculations that are avoided that occur in 2D space within pixel shaders that compute pixel colors for the triangles 2D projections i.e. pixel shading works in 2D .

The aggressiveness of implementations of this new technology can be controlled by varying the ratio of morphed frames to fully rendered frames in the output stream. Most likely a lower fill rate e.g. one morph frame inserted between each pair of fully rendered frames would be effective for highly interactive applications like video games. Conversely a higher fill rate e.g. multiple morphed frames inserted between each pair of fully rendered frames would be effective for low interactive applications like movie like sequences. In some implementations the amount of object motion and or level of interactivity may be detected and or provided. A determination or indication of the the object motion and or level of interactivity may determine the fill rate e.g. rate of interleaving morphed frames of a frame sequence.

An embodiment of system can include or be incorporated within a server based gaming platform a game console including a game and media console a mobile gaming console a handheld game console or an online game console. In some embodiments system is a mobile phone smart phone tablet computing device or mobile Internet device. Data processing system can also include couple with or be integrated within a wearable device such as a smart watch wearable device smart eyewear device augmented reality device or virtual reality device. In some embodiments data processing system is a television or set top box device having one or more processors and a graphical interface generated by one or more graphics processors .

In some embodiments the one or more processors each include one or more processor cores to process instructions which when executed perform operations for system and user software. In some embodiments each of the one or more processor cores is configured to process a specific instruction set . In some embodiments instruction set may facilitate Complex Instruction Set Computing CISC Reduced Instruction Set Computing RISC or computing via a Very Long Instruction Word VLIW . Multiple processor cores may each process a different instruction set which may include instructions to facilitate the emulation of other instruction sets. Processor core may also include other processing devices such a Digital Signal Processor DSP .

In some embodiments the processor includes cache memory . Depending on the architecture the processor can have a single internal cache or multiple levels of internal cache. In some embodiments the cache memory is shared among various components of the processor . In some embodiments the processor also uses an external cache e.g. a Level 3 L3 cache or Last Level Cache LLC not shown which may be shared among processor cores using known cache coherency techniques. A register file is additionally included in processor which may include different types of registers for storing different types of data e.g. integer registers floating point registers status registers and an instruction pointer register . Some registers may be general purpose registers while other registers may be specific to the design of the processor .

In some embodiments processor is coupled to a processor bus to transmit communication signals such as address data or control signals between processor and other components in system . In one embodiment the system uses an exemplary hub system architecture including a memory controller hub and an Input Output I O controller hub . A memory controller hub facilitates communication between a memory device and other components of system while an I O Controller Hub ICH provides connections to I O devices via a local I O bus. In one embodiment the logic of the memory controller hub is integrated within the processor.

Memory device can be a dynamic random access memory DRAM device a static random access memory SRAM device flash memory device phase change memory device or some other memory device having suitable performance to serve as process memory. In one embodiment the memory device can operate as system memory for the system to store data and instructions for use when the one or more processors executes an application or process. Memory controller hub also couples with an optional external graphics processor which may communicate with the one or more graphics processors in processors to perform graphics and media operations.

In some embodiments ICH enables peripherals to connect to memory device and processor via a high speed I O bus. The I O peripherals include but are not limited to an audio controller a firmware interface a wireless transceiver e.g. Wi Fi Bluetooth a data storage device e.g. hard disk drive flash memory etc. and a legacy I O controller for coupling legacy e.g. Personal System 2 PS 2 devices to the system. One or more Universal Serial Bus USB controllers connect input devices such as keyboard and mouse combinations. A network controller may also couple to ICH . In some embodiments a high performance network controller not shown couples to processor bus . It will be appreciated that the system shown is exemplary and not limiting as other types of data processing systems that are differently configured may also be used. For example the I O controller hub may be integrated within the one or more processor or the memory controller hub and I O controller hub may be integrated into a discreet external graphics processor such as the external graphics processor .

The internal cache units A N and shared cache units represent a cache memory hierarchy within the processor . The cache memory hierarchy may include at least one level of instruction and data cache within each processor core and one or more levels of shared mid level cache such as a Level 2 L2 Level 3 L3 Level 4 L4 or other levels of cache where the highest level of cache before external memory is classified as the LLC. In some embodiments cache coherency logic maintains coherency between the various cache units and A N.

In some embodiments processor may also include a set of one or more bus controller units and a system agent core . The one or more bus controller units manage a set of peripheral buses such as one or more Peripheral Component Interconnect buses e.g. PCI PCI Express . System agent core provides management functionality for the various processor components. In some embodiments system agent core includes one or more integrated memory controllers to manage access to various external memory devices not shown .

In some embodiments one or more of the processor cores A N include support for simultaneous multi threading. In such embodiment the system agent core includes components for coordinating and operating cores A N during multi threaded processing. System agent core may additionally include a power control unit PCU which includes logic and components to regulate the power state of processor cores A N and graphics processor .

In some embodiments processor additionally includes graphics processor to execute graphics processing operations. In some embodiments the graphics processor couples with the set of shared cache units and the system agent core including the one or more integrated memory controllers . In some embodiments a display controller is coupled with the graphics processor to drive graphics processor output to one or more coupled displays. In some embodiments display controller may be a separate module coupled with the graphics processor via at least one interconnect or may be integrated within the graphics processor or system agent core .

In some embodiments a ring based interconnect unit is used to couple the internal components of the processor . However an alternative interconnect unit may be used such as a point to point interconnect a switched interconnect or other techniques including techniques well known in the art. In some embodiments graphics processor couples with the ring interconnect via an I O link .

The exemplary I O link represents at least one of multiple varieties of I O interconnects including an on package I O interconnect which facilitates communication between various processor components and a high performance embedded memory module such as an eDRAM module. In some embodiments each of the processor cores N and graphics processor use embedded memory modules as a shared Last Level Cache.

In some embodiments processor cores A N are homogenous cores executing the same instruction set architecture. In another embodiment processor cores A N are heterogeneous in terms of instruction set architecture ISA where one or more of processor cores A N execute a first instruction set while at least one of the other cores executes a subset of the first instruction set or a different instruction set. In one embodiment processor cores A N are heterogeneous in terms of microarchitecture where one or more cores having a relatively higher power consumption couple with one or more power cores having a lower power consumption. Additionally processor can be implemented on one or more chips or as an SoC integrated circuit having the illustrated components in addition to other components.

In some embodiments graphics processor also includes a display controller to drive display output data to a display device . Display controller includes hardware for one or more overlay planes for the display and composition of multiple layers of video or user interface elements. In some embodiments graphics processor includes a video codec engine to encode decode or transcode media to from or between one or more media encoding formats including but not limited to Moving Picture Experts Group MPEG formats such as MPEG 2 Advanced Video Coding AVC formats such as H.264 MPEG 4 AVC as well as the Society of Motion Picture Television Engineers SMPTE 421M VC 1 and Joint Photographic Experts Group JPEG formats such as JPEG and Motion JPEG MJPEG formats.

In some embodiments graphics processor includes a block image transfer BLIT engine to perform two dimensional 2D rasterizer operations including for example bit boundary block transfers. However in one embodiment 2D graphics operations are performed using one or more components of graphics processing engine GPE . In some embodiments graphics processing engine is a compute engine for performing graphics operations including three dimensional 3D graphics operations and media operations.

In some embodiments GPE includes a 3D pipeline for performing 3D operations such as rendering three dimensional images and scenes using processing functions that act upon 3D primitive shapes e.g. rectangle triangle etc. . The 3D pipeline includes programmable and fixed function elements that perform various tasks within the element and or spawn execution threads to a 3D Media sub system . While 3D pipeline can be used to perform media operations an embodiment of GPE also includes a media pipeline that is specifically used to perform media operations such as video post processing and image enhancement.

In some embodiments media pipeline includes fixed function or programmable logic units to perform one or more specialized media operations such as video decode acceleration video de interlacing and video encode acceleration in place of or on behalf of video codec engine . In some embodiments media pipeline additionally includes a thread spawning unit to spawn threads for execution on 3D Media sub system . The spawned threads perform computations for the media operations on one or more graphics execution units included in 3D Media sub system .

In some embodiments 3D Media subsystem includes logic for executing threads spawned by 3D pipeline and media pipeline . In one embodiment the pipelines send thread execution requests to 3D Media subsystem which includes thread dispatch logic for arbitrating and dispatching the various requests to available thread execution resources. The execution resources include an array of graphics execution units to process the 3D and media threads. In some embodiments 3D Media subsystem includes one or more internal caches for thread instructions and data. In some embodiments the subsystem also includes shared memory including registers and addressable memory to share data between threads and to store output data.

In some embodiments GPE couples with a command streamer which provides a command stream to the GPE 3D and media pipelines . In some embodiments command streamer is coupled to memory which can be system memory or one or more of internal cache memory and shared cache memory. In some embodiments command streamer receives commands from the memory and sends the commands to 3D pipeline and or media pipeline . The commands are directives fetched from a ring buffer which stores commands for the 3D and media pipelines . In one embodiment the ring buffer can additionally include batch command buffers storing batches of multiple commands. The 3D and media pipelines process the commands by performing operations via logic within the respective pipelines or by dispatching one or more execution threads to an execution unit array . In some embodiments execution unit array is scalable such that the array includes a variable number of execution units based on the target power and performance level of GPE .

In some embodiments a sampling engine couples with memory e.g. cache memory or system memory and execution unit array . In some embodiments sampling engine provides a memory access mechanism for execution unit array that allows execution array to read graphics and media data from memory. In some embodiments sampling engine includes logic to perform specialized image sampling operations for media.

In some embodiments the specialized media sampling logic in sampling engine includes a de noise de interlace module a motion estimation module and an image scaling and filtering module . In some embodiments de noise de interlace module includes logic to perform one or more of a de noise or a de interlace algorithm on decoded video data. The de interlace logic combines alternating fields of interlaced video content into a single fame of video. The de noise logic reduces or removes data noise from video and image data. In some embodiments the de noise logic and de interlace logic are motion adaptive and use spatial or temporal filtering based on the amount of motion detected in the video data. In some embodiments the de noise de interlace module includes dedicated motion detection logic e.g. within the motion estimation engine .

In some embodiments motion estimation engine provides hardware acceleration for video operations by performing video acceleration functions such as motion vector estimation and prediction on video data. The motion estimation engine determines motion vectors that describe the transformation of image data between successive video frames. In some embodiments a graphics processor media codec uses video motion estimation engine to perform operations on video at the macro block level that may otherwise be too computationally intensive to perform with a general purpose processor. In some embodiments motion estimation engine is generally available to graphics processor components to assist with video decode and processing functions that are sensitive or adaptive to the direction or magnitude of the motion within video data.

In some embodiments image scaling and filtering module performs image processing operations to enhance the visual quality of generated images and video. In some embodiments scaling and filtering module processes image and video data during the sampling operation before providing the data to execution unit array .

In some embodiments the GPE includes a data port which provides an additional mechanism for graphics subsystems to access memory. In some embodiments data port facilitates memory access for operations including render target writes constant buffer reads scratch memory space reads writes and media surface accesses. In some embodiments data port includes cache memory space to cache accesses to memory. The cache memory can be a single data cache or separated into multiple caches for the multiple subsystems that access memory via the data port e.g. a render buffer cache a constant buffer cache etc. . In some embodiments threads executing on an execution unit in execution unit array communicate with the data port by exchanging messages via a data distribution interconnect that couples each of the sub systems of GPE .

In some embodiments graphics processor includes a ring interconnect a pipeline front end a media engine and graphics cores A N. In some embodiments ring interconnect couples the graphics processor to other processing units including other graphics processors or one or more general purpose processor cores. In some embodiments the graphics processor is one of many processors integrated within a multi core processing system.

In some embodiments graphics processor receives batches of commands via ring interconnect . The incoming commands are interpreted by a command streamer in the pipeline front end . In some embodiments graphics processor includes scalable execution logic to perform 3D geometry processing and media processing via the graphics core s A N. For 3D geometry processing commands command streamer supplies commands to geometry pipeline . For at least some media processing commands command streamer supplies the commands to a video front end which couples with a media engine . In some embodiments media engine includes a Video Quality Engine VQE for video and image post processing and a multi format encode decode MFX engine to provide hardware accelerated media data encode and decode. In some embodiments geometry pipeline and media engine each generate execution threads for the thread execution resources provided by at least one graphics core A.

In some embodiments graphics processor includes scalable thread execution resources featuring modular cores A N sometimes referred to as core slices each having multiple sub cores A N A N sometimes referred to as core sub slices . In some embodiments graphics processor can have any number of graphics cores A through N. In some embodiments graphics processor includes a graphics core A having at least a first sub core A and a second core sub core A. In other embodiments the graphics processor is a low power processor with a single sub core e.g. A . In some embodiments graphics processor includes multiple graphics cores A N each including a set of first sub cores A N and a set of second sub cores A N. Each sub core in the set of first sub cores A N includes at least a first set of execution units A N and media texture samplers A N. Each sub core in the set of second sub cores A N includes at least a second set of execution units A N and samplers A N. In some embodiments each sub core A N A N shares a set of shared resources A N. In some embodiments the shared resources include shared cache memory and pixel operation logic. Other shared resources may also be included in the various embodiments of the graphics processor.

In some embodiments thread execution logic includes a pixel shader a thread dispatcher instruction cache a scalable execution unit array including a plurality of execution units A N a sampler a data cache and a data port . In one embodiment the included components are interconnected via an interconnect fabric that links to each of the components. In some embodiments thread execution logic includes one or more connections to memory such as system memory or cache memory through one or more of instruction cache data port sampler and execution unit array A N. In some embodiments each execution unit e.g. A is an individual vector processor capable of executing multiple simultaneous threads and processing multiple data elements in parallel for each thread. In some embodiments execution unit array A N includes any number individual execution units.

In some embodiments execution unit array A N is primarily used to execute shader programs. In some embodiments the execution units in array A N execute an instruction set that includes native support for many standard 3D graphics shader instructions such that shader programs from graphics libraries e.g. Direct 3D and OpenGL are executed with a minimal translation. The execution units support vertex and geometry processing e.g. vertex programs geometry programs vertex shaders pixel processing e.g. pixel shaders fragment shaders and general purpose processing e.g. compute and media shaders .

Each execution unit in execution unit array A N operates on arrays of data elements. The number of data elements is the execution size or the number of channels for the instruction. An execution channel is a logical unit of execution for data element access masking and flow control within instructions. The number of channels may be independent of the number of physical Arithmetic Logic Units ALUs or Floating Point Units FPUs for a particular graphics processor. In some embodiments execution units A N support integer and floating point data types.

The execution unit instruction set includes single instruction multiple data SIMD instructions. The various data elements can be stored as a packed data type in a register and the execution unit will process the various elements based on the data size of the elements. For example when operating on a 256 bit wide vector the 256 bits of the vector are stored in a register and the execution unit operates on the vector as four separate 64 bit packed data elements Quad Word QW size data elements eight separate 32 bit packed data elements Double Word DW size data elements sixteen separate 16 bit packed data elements Word W size data elements or thirty two separate 8 bit data elements byte B size data elements . However different vector widths and register sizes are possible.

One or more internal instruction caches e.g. are included in the thread execution logic to cache thread instructions for the execution units. In some embodiments one or more data caches e.g. are included to cache thread data during thread execution. In some embodiments sampler is included to provide texture sampling for 3D operations and media sampling for media operations. In some embodiments sampler includes specialized texture or media sampling functionality to process texture or media data during the sampling process before providing the sampled data to an execution unit.

During execution the graphics and media pipelines send thread initiation requests to thread execution logic via thread spawning and dispatch logic. In some embodiments thread execution logic includes a local thread dispatcher that arbitrates thread initiation requests from the graphics and media pipelines and instantiates the requested threads on one or more execution units A N. For example the geometry pipeline e.g. of dispatches vertex processing tessellation or geometry processing threads to thread execution logic . In some embodiments thread dispatcher can also process runtime thread spawning requests from the executing shader programs.

Once a group of geometric objects has been processed and rasterized into pixel data pixel shader is invoked to further compute output information and cause results to be written to output surfaces e.g. color buffers depth buffers stencil buffers etc. . In some embodiments pixel shader calculates the values of the various vertex attributes that are to be interpolated across the rasterized object. In some embodiments pixel shader then executes an application programming interface API supplied pixel shader program. To execute the pixel shader program pixel shader dispatches threads to an execution unit e.g. A via thread dispatcher . In some embodiments pixel shader uses texture sampling logic in sampler to access texture data in texture maps stored in memory. Arithmetic operations on the texture data and the input geometry data compute pixel color data for each geometric fragment or discards one or more pixels from further processing.

In some embodiments the data port provides a memory access mechanism for the thread execution logic output processed data to memory for processing on a graphics processor output pipeline. In some embodiments the data port includes or couples to one or more cache memories e.g. data cache to cache data for memory access via the data port.

In some embodiments the graphics processor execution units natively support instructions in a 128 bit format . A 64 bit compacted instruction format is available for some instructions based on the selected instruction instruction options and number of operands. The native 128 bit format provides access to all instruction options while some options and operations are restricted in the 64 bit format . The native instructions available in the 64 bit format vary by embodiment. In some embodiments the instruction is compacted in part using a set of index values in an index field . The execution unit hardware references a set of compaction tables based on the index values and uses the compaction table outputs to reconstruct a native instruction in the 128 bit format .

For each format instruction opcode defines the operation that the execution unit is to perform. The execution units execute each instruction in parallel across the multiple data elements of each operand. For example in response to an add instruction the execution unit performs a simultaneous add operation across each color channel representing a texture element or picture element. By default the execution unit performs each instruction across all data channels of the operands. In some embodiments instruction control field enables control over certain execution options such as channels selection e.g. predication and data channel order e.g. swizzle . For 128 bit instructions an exec size field limits the number of data channels that will be executed in parallel. In some embodiments exec size field is not available for use in the 64 bit compact instruction format .

Some execution unit instructions have up to three operands including two source operands src0 src1 and one destination . In some embodiments the execution units support dual destination instructions where one of the destinations is implied. Data manipulation instructions can have a third source operand e.g. SRC2 where the instruction opcode determines the number of source operands. An instruction s last source operand can be an immediate e.g. hard coded value passed with the instruction.

In some embodiments the 128 bit instruction format includes an access address mode information specifying for example whether direct register addressing mode or indirect register addressing mode is used. When direct register addressing mode is used the register address of one or more operands is directly provided by bits in the instruction .

In some embodiments the 128 bit instruction format includes an access address mode field which specifies an address mode and or an access mode for the instruction. In one embodiment the access mode to define a data access alignment for the instruction. Some embodiments support access modes including a 16 byte aligned access mode and a 1 byte aligned access mode where the byte alignment of the access mode determines the access alignment of the instruction operands. For example when in a first mode the instruction may use byte aligned addressing for source and destination operands and when in a second mode the instruction may use 16 byte aligned addressing for all source and destination operands.

In one embodiment the address mode portion of the access address mode field determines whether the instruction is to use direct or indirect addressing. When direct register addressing mode is used bits in the instruction directly provide the register address of one or more operands. When indirect register addressing mode is used the register address of one or more operands may be computed based on an address register value and an address immediate field in the instruction.

In some embodiments instructions are grouped based on opcode bit fields to simplify Opcode decode . For an 8 bit opcode bits and allow the execution unit to determine the type of opcode. The precise opcode grouping shown is merely an example. In some embodiments a move and logic opcode group includes data movement and logic instructions e.g. move mov compare cmp . In some embodiments move and logic group shares the five most significant bits MSB where move mov instructions are in the form of 0000xxxxb and logic instructions are in the form of 0001xxxxb. A flow control instruction group e.g. call jump jmp includes instructions in the form of 0010xxxxb e.g. 0x20 . A miscellaneous instruction group includes a mix of instructions including synchronization instructions e.g. wait send in the form of 0011xxxxb e.g. 0x30 . A parallel math instruction group includes component wise arithmetic instructions e.g. add multiply mul in the form of 0100xxxxb e.g. 0x40 . The parallel math group performs the arithmetic operations in parallel across data channels. The vector math group includes arithmetic instructions e.g. dp4 in the form of 0101xxxxb e.g. 0x50 . The vector math group performs arithmetic such as dot product calculations on vector operands.

In some embodiments graphics processor includes a graphics pipeline a media pipeline a display engine thread execution logic and a render output pipeline . In some embodiments graphics processor is a graphics processor within a multi core processing system that includes one or more general purpose processing cores. The graphics processor is controlled by register writes to one or more control registers not shown or via commands issued to graphics processor via a ring interconnect . In some embodiments ring interconnect couples graphics processor to other processing components such as other graphics processors or general purpose processors. Commands from ring interconnect are interpreted by a command streamer which supplies instructions to individual components of graphics pipeline or media pipeline .

In some embodiments command streamer directs the operation of a vertex fetcher that reads vertex data from memory and executes vertex processing commands provided by command streamer . In some embodiments vertex fetcher provides vertex data to a vertex shader which performs coordinate space transformation and lighting operations to each vertex. In some embodiments vertex fetcher and vertex shader execute vertex processing instructions by dispatching execution threads to execution units A B via a thread dispatcher .

In some embodiments execution units A B are an array of vector processors having an instruction set for performing graphics and media operations. In some embodiments execution units A B have an attached L1 cache that is specific for each array or shared between the arrays. The cache can be configured as a data cache an instruction cache or a single cache that is partitioned to contain data and instructions in different partitions.

In some embodiments graphics pipeline includes tessellation components to perform hardware accelerated tessellation of 3D objects. In some embodiments a programmable hull shader configures the tessellation operations. A programmable domain shader provides back end evaluation of tessellation output. A tessellator operates at the direction of hull shader and contains special purpose logic to generate a set of detailed geometric objects based on a coarse geometric model that is provided as input to graphics pipeline . In some embodiments if tessellation is not used tessellation components can be bypassed.

In some embodiments complete geometric objects can be processed by a geometry shader via one or more threads dispatched to execution units A B or can proceed directly to the clipper . In some embodiments the geometry shader operates on entire geometric objects rather than vertices or patches of vertices as in previous stages of the graphics pipeline. If the tessellation is disabled the geometry shader receives input from the vertex shader . In some embodiments geometry shader is programmable by a geometry shader program to perform geometry tessellation if the tessellation units are disabled.

Before rasterization a clipper processes vertex data. The clipper may be a fixed function clipper or a programmable clipper having clipping and geometry shader functions. In some embodiments a rasterizer depth in the render output pipeline dispatches pixel shaders to convert the geometric objects into their per pixel representations. In some embodiments pixel shader logic is included in thread execution logic . In some embodiments an application can bypass the rasterizer and access un rasterized vertex data via a stream out unit .

The graphics processor has an interconnect bus interconnect fabric or some other interconnect mechanism that allows data and message passing amongst the major components of the processor. In some embodiments execution units A B and associated cache s texture and media sampler and texture sampler cache interconnect via a data port to perform memory access and communicate with render output pipeline components of the processor. In some embodiments sampler caches and execution units A B each have separate memory access paths.

In some embodiments render output pipeline contains a rasterizer and depth test component that converts vertex based objects into an associated pixel based representation. In some embodiments the rasterizer logic includes a windower masker unit to perform fixed function triangle and line rasterization. An associated render cache and depth cache are also available in some embodiments. A pixel operations component performs pixel based operations on the data though in some instances pixel operations associated with 2D operations e.g. bit block image transfers with blending are performed by the 2D engine or substituted at display time by the display controller using overlay display planes. In some embodiments a shared L3 cache is available to all graphics components allowing the sharing of data without the use of main system memory.

In some embodiments graphics processor media pipeline includes a media engine and a video front end . In some embodiments video front end receives pipeline commands from the command streamer . In some embodiments media pipeline includes a separate command streamer. In some embodiments video front end processes media commands before sending the command to the media engine . In some embodiments media engine includes thread spawning functionality to spawn threads for dispatch to thread execution logic via thread dispatcher .

In some embodiments graphics processor includes a display engine . In some embodiments display engine is external to processor and couples with the graphics processor via the ring interconnect or some other interconnect bus or fabric. In some embodiments display engine includes a 2D engine and a display controller . In some embodiments display engine contains special purpose logic capable of operating independently of the 3D pipeline. In some embodiments display controller couples with a display device not shown which may be a system integrated display device as in a laptop computer or an external display device attached via a display device connector.

In some embodiments graphics pipeline and media pipeline are configurable to perform operations based on multiple graphics and media programming interfaces and are not specific to any one application programming interface API . In some embodiments driver software for the graphics processor translates API calls that are specific to a particular graphics or media library into commands that can be processed by the graphics processor. In some embodiments support is provided for the Open Graphics Library OpenGL and Open Computing Language OpenCL from the Khronos Group the Direct3D library from the Microsoft Corporation or support may be provided to both OpenGL and D3D. Support may also be provided for the Open Source Computer Vision Library OpenCV . A future API with a compatible 3D pipeline would also be supported if a mapping can be made from the pipeline of the future API to the pipeline of the graphics processor.

In some embodiments client specifies the client unit of the graphics device that processes the command data. In some embodiments a graphics processor command parser examines the client field of each command to condition the further processing of the command and route the command data to the appropriate client unit. In some embodiments the graphics processor client units include a memory interface unit a render unit a 2D unit a 3D unit and a media unit. Each client unit has a corresponding processing pipeline that processes the commands. Once the command is received by the client unit the client unit reads the opcode and if present sub opcode to determine the operation to perform. The client unit performs the command using information in data field . For some commands an explicit command size is expected to specify the size of the command. In some embodiments the command parser automatically determines the size of at least some of the commands based on the command opcode. In some embodiments commands are aligned via multiples of a double word.

The flow diagram in shows an exemplary graphics processor command sequence . In some embodiments software or firmware of a data processing system that features an embodiment of a graphics processor uses a version of the command sequence shown to set up execute and terminate a set of graphics operations. A sample command sequence is shown and described for purposes of example only as embodiments are not limited to these specific commands or to this command sequence. Moreover the commands may be issued as batch of commands in a command sequence such that the graphics processor will process the sequence of commands in at least partially concurrence.

In some embodiments the graphics processor command sequence may begin with a pipeline flush command to cause any active graphics pipeline to complete the currently pending commands for the pipeline. In some embodiments the 3D pipeline and the media pipeline do not operate concurrently. The pipeline flush is performed to cause the active graphics pipeline to complete any pending commands. In response to a pipeline flush the command parser for the graphics processor will pause command processing until the active drawing engines complete pending operations and the relevant read caches are invalidated. Optionally any data in the render cache that is marked dirty can be flushed to memory. In some embodiments pipeline flush command can be used for pipeline synchronization or before placing the graphics processor into a low power state.

In some embodiments a pipeline select command is used when a command sequence requires the graphics processor to explicitly switch between pipelines. In some embodiments a pipeline select command is required only once within an execution context before issuing pipeline commands unless the context is to issue commands for both pipelines. In some embodiments a pipeline flush command is 912 is required immediately before a pipeline switch via the pipeline select command .

In some embodiments a pipeline control command configures a graphics pipeline for operation and is used to program the 3D pipeline and the media pipeline . In some embodiments pipeline control command configures the pipeline state for the active pipeline. In one embodiment the pipeline control command is used for pipeline synchronization and to clear data from one or more cache memories within the active pipeline before processing a batch of commands.

In some embodiments return buffer state commands are used to configure a set of return buffers for the respective pipelines to write data. Some pipeline operations require the allocation selection or configuration of one or more return buffers into which the operations write intermediate data during processing. In some embodiments the graphics processor also uses one or more return buffers to store output data and to perform cross thread communication. In some embodiments the return buffer state includes selecting the size and number of return buffers to use for a set of pipeline operations.

The remaining commands in the command sequence differ based on the active pipeline for operations. Based on a pipeline determination the command sequence is tailored to the 3D pipeline beginning with the 3D pipeline state or the media pipeline beginning at the media pipeline state .

The commands for the 3D pipeline state include 3D state setting commands for vertex buffer state vertex element state constant color state depth buffer state and other state variables that are to be configured before 3D primitive commands are processed. The values of these commands are determined at least in part based the particular 3D API in use. In some embodiments 3D pipeline state commands are also able to selectively disable or bypass certain pipeline elements if those elements will not be used.

In some embodiments 3D primitive command is used to submit 3D primitives to be processed by the 3D pipeline. Commands and associated parameters that are passed to the graphics processor via the 3D primitive command are forwarded to the vertex fetch function in the graphics pipeline. The vertex fetch function uses the 3D primitive command data to generate vertex data structures. The vertex data structures are stored in one or more return buffers. In some embodiments 3D primitive command is used to perform vertex operations on 3D primitives via vertex shaders. To process vertex shaders 3D pipeline dispatches shader execution threads to graphics processor execution units.

In some embodiments 3D pipeline is triggered via an execute command or event. In some embodiments a register write triggers command execution. In some embodiments execution is triggered via a go or kick command in the command sequence. In one embodiment command execution is triggered using a pipeline synchronization command to flush the command sequence through the graphics pipeline. The 3D pipeline will perform geometry processing for the 3D primitives. Once operations are complete the resulting geometric objects are rasterized and the pixel engine colors the resulting pixels. Additional commands to control pixel shading and pixel back end operations may also be included for those operations.

In some embodiments the graphics processor command sequence follows the media pipeline path when performing media operations. In general the specific use and manner of programming for the media pipeline depends on the media or compute operations to be performed. Specific media decode operations may be offloaded to the media pipeline during media decode. In some embodiments the media pipeline can also be bypassed and media decode can be performed in whole or in part using resources provided by one or more general purpose processing cores. In one embodiment the media pipeline also includes elements for general purpose graphics processor unit GPGPU operations where the graphics processor is used to perform SIMD vector operations using computational shader programs that are not explicitly related to the rendering of graphics primitives.

In some embodiments media pipeline is configured in a similar manner as the 3D pipeline . A set of media pipeline state commands are dispatched or placed into in a command queue before the media object commands . In some embodiments media pipeline state commands include data to configure the media pipeline elements that will be used to process the media objects. This includes data to configure the video decode and video encode logic within the media pipeline such as encode or decode format. In some embodiments media pipeline state commands also support the use one or more pointers to indirect state elements that contain a batch of state settings.

In some embodiments media object commands supply pointers to media objects for processing by the media pipeline. The media objects include memory buffers containing video data to be processed. In some embodiments all media pipeline states must be valid before issuing a media object command . Once the pipeline state is configured and media object commands are queued the media pipeline is triggered via an execute command or an equivalent execute event e.g. register write . Output from media pipeline may then be post processed by operations provided by the 3D pipeline or the media pipeline . In some embodiments GPGPU operations are configured and executed in a similar manner as media operations.

In some embodiments 3D graphics application contains one or more shader programs including shader instructions . The shader language instructions may be in a high level shader language such as the High Level Shader Language HLSL or the OpenGL Shader Language GLSL . The application also includes executable instructions in a machine language suitable for execution by the general purpose processor core . The application also includes graphics objects defined by vertex data.

In some embodiments operating system is a Microsoft Windows operating system from the Microsoft Corporation a proprietary UNIX like operating system or an open source UNIX like operating system using a variant of the Linux kernel. When the Direct3D API is in use the operating system uses a front end shader compiler to compile any shader instructions in HLSL into a lower level shader language. The compilation may be a just in time JIT compilation or the application can perform shader pre compilation. In some embodiments high level shaders are compiled into low level shaders during the compilation of the 3D graphics application .

In some embodiments user mode graphics driver contains a back end shader compiler to convert the shader instructions into a hardware specific representation. When the OpenGL API is in use shader instructions in the GLSL high level language are passed to a user mode graphics driver for compilation. In some embodiments user mode graphics driver uses operating system kernel mode functions to communicate with a kernel mode graphics driver . In some embodiments kernel mode graphics driver communicates with graphics processor to dispatch commands and instructions.

One or more aspects of at least one embodiment may be implemented by representative code stored on a machine readable medium which represents and or defines logic within an integrated circuit such as a processor. For example the machine readable medium may include instructions which represent various logic within the processor. When read by a machine the instructions may cause the machine to fabricate the logic to perform the techniques described herein. Such representations known as IP cores are reusable units of logic for an integrated circuit that may be stored on a tangible machine readable medium as a hardware model that describes the structure of the integrated circuit. The hardware model may be supplied to various customers or manufacturing facilities which load the hardware model on fabrication machines that manufacture the integrated circuit. The integrated circuit may be fabricated such that the circuit performs operations described in association with any of the embodiments described herein.

The RTL design or equivalent may be further synthesized by the design facility into a hardware model which may be in a hardware description language HDL or some other representation of physical design data. The HDL may be further simulated or tested to verify the IP core design. The IP core design can be stored for delivery to a 3party fabrication facility using non volatile memory e.g. hard disk flash memory or any non volatile storage medium . Alternatively the IP core design may be transmitted e.g. via the Internet over a wired connection or wireless connection . The fabrication facility may then fabricate an integrated circuit that is based at least in part on the IP core design. The fabricated integrated circuit can be configured to perform operations in accordance with at least one embodiment described herein.

Additionally other logic and circuits may be included in the processor of integrated circuit including additional graphics processors cores peripheral interface controllers or general purpose processor cores.

Using this conventional high level 3D rendering workflow a computer graphics system e.g. GPU produces a fully 3D rendered frame for each of the frames in the sequence. In a real time scenario then the system must produce these frames fast enough e.g. 30 60 frames per second to create a seamless and smooth visual environment for the viewer.

Frame is labeled Frame n in this sequence. Alternatively it could be labeled frame 0 or frame at t. That is this frame is the first frame of this example frame sequence.

With regard to frame the 3D rendering starts with a 3D model . The 3D model describes the geometry information of the objects in a 3D scene of that frame. That geometry information includes vertices that define the shape of 3D objects in the form of polygons e.g. triangles . The geometry information of an object is often visualized as a wireframe model of an object. The box representing the 3D model shows a wireframe sphere on the left hand side of that box. The wireframe sphere is an example of a 3D object that is represented as a collection of vertices of polygons.

Next geometry processing is performed on the 3D model . The geometry processing commonly includes vertex shader modules which are hardware and or software . Vertex shaders operate in 3D space. Vertex shaders manipulate properties such as position color and texture coordinate.

Next pixel processing calculates the effects on a per pixel basis of the resulting 2D screen space projection including the pixels that represent the objects handled by the geometry processing . Depending upon the screen resolution typically more than two million pixels may need to be rendered lit shaded and colored per frame. That pixel processing does that processing for frame . The pixel processing commonly includes pixel shader modules which are hardware and or software .

2D screen space projection represents the 2D screen space projection of the fully 3D rendered 3D model . In the case of real time graphics this frame is quickly displayed on the screen in the proper sequence and with the proper timing. The 2D screen space projection is illustrated to be displayed on a computer graphics screen e.g. television monitor . This is done to show the real time nature of the 3D rendering performed by the computer graphics system.

As depicted the 2D screen space projection shows a solid colored sphere on the left hand size of the screen. This is intended to match the wireframe sphere shown in the 3D model and illustrate the effect of 3D rendering.

The next frame is frame . Frame is labeled Frame n 1 to indicate the next frame in the frame sequence. Except for some of the information about the previous 3 D model e.g. 3D model the processing of this frame starts anew. The retained and transformed information about the previous 3D model is shown by arrow .

Frame is produced using the same process as the one before it. It starts with a 3D model . Geometry processing and pixel processing is performed on the model . This produces 2D screen space projection . This frame is shown with the proper timing right after the frame before it e.g. frame .

The next frame is frame . This frame is labeled Frame n 2 to indicate the next frame in the frame sequence. Except for some of the information about the previous 3 D model e.g. 3D model the processing of this frame starts anew. The retained and transformed information about the previous 3D model is shown by arrow .

Frame is produced using the same process as the frames before it. It starts with a 3D model . Geometry processing and pixel processing is performed on the model . This produces 2D screen space projection . This frame is shown with the proper timing right after the frame before it e.g. frame .

The last frame of this snippet of a frame sequence is frame . This frame is labeled Frame n 3 to indicate the next frame in the frame sequence. Except for some of the information about the previous 3 D model e.g. 3D model the processing of this frame starts anew. The retained and transformed information about the previous 3D model is shown by arrow .

Frame is produced using the same process as the frames before it. It starts with a 3D model . Geometry processing and pixel processing is performed on the model . This produces 2D screen space projection . This frame is shown with the proper timing right after the frame before it e.g. frame .

To better illustrate the frame sequence or a portion thereof each frame has a wireframe sphere shown in the box that represents its 3D model. Also each frame has a solid sphere shown in the box that represents is 2D screen space projection. Across the frame sequence portion the wireframe and solid spheres are shown to move from left to right within their respective boxes in a corresponding manner.

As depicted the coordinated wireframe solid sphere movement across frames is meant to convey that objects and or the viewer s perspective changes from frame to frame with real time computer graphics.

Like the discussion about the conventional high level 3D rendering workflow this discussion is based on a similar short sequence of frames which are shown from left to right as frame and . Each of these frames corresponds to similarly situated and numbered frames e.g. and of the conventional workflow sequence discussed above.

However unlike the conventional workflow sequence a computer graphics system e.g. GPU produces a fully 3D rendered frame for only the first and the last frames e.g. and of this example workflow sequence . Using information derived from the already fully 3D rendered frames and the computer graphics system calculates the intermediate frames e.g. and in accordance with the new technologies described herein.

Frame is labeled Frame n in this sequence. Alternatively it could be labeled frame 0 or frame at t. That is this frame is the first frame of this example frame sequence. Frame is labeled Frame n 3 in this sequence. It is effectively the last frame of the example sequence. That said without an implementation of the new technology frames and would be the only frames of the sequence.

For each of these frames and the 3D rendering starts with a 3D model e.g. and . Arrow indicates that some of the information about the previous 3 D model e.g. 3D model is transferred to the next fully 3D rendered frame which is frame .

For each of the fully 3D rendered frames and the computer graphics system performs geometry processing e.g. and on their 3D model. For each of the frames and the computer graphics system performs pixel processing e.g. and and calculates the effects on a per pixel basis of the resulting 2D screen space projection.

The conventional full 3D rendering process produces a 2D screen space projection e.g. and for each of the fully 3D rendered frames and .

In this example workflow sequence there are two frames and that occur between the fully 3D rendered frames . Instead of being fully 3D rendered these frames and are morphed from information available from fully 3D rendered frames .

With frame a morph processing obtains geometry information from the geometry processing of frame which is the immediately preceding frame and from the geometry processing of frame which is a later or succeeding frame . This is depicted by arrows and respectively. In particular the morph processing uses this geometry information to determine the motion of 2D projections of 3D model primitives i.e. triangles .

Also the morph processing obtains pixel information from the completed 2D screen space projection of frame which is the immediately preceding frame and from the completed 2D screen space projection of frame which is a later or succeeding frame . This is depicted by arrows and respectively.

With frame a morph processing obtains geometry information from the geometry processing of frame which is an earlier or preceding frame and from the geometry processing of frame which is the immediately succeeding frame . This is depicted by arrows and respectively. In particular the morph processing uses this geometry information to determine the motion of 2D screen space projection triangles between subsequent frames e.g. frame and .

Also the morph processing obtains pixel information from the completed 2D screen space projection of frame which is an earlier or preceding frame and from the completed 2D screen space projection of frame which is the immediately succeeding frame . This is depicted by arrows and respectively.

The morph processing and involves use of pixel data e.g. color of actual pixels in 2D screen space projection based on motion vector calculations and segmentation. The morph processing includes using the color values of the surrounding frames e.g. and from the coordinates obtained from adding the segmented motion vector to the current pixel coordinates. This stage the output color is interpolated between the two values e.g. using distance weighted sum . This provides good approximations of surface lighting and or special effect change in the morphed frame.

Also morph processing utilizes information from the stencil buffer to handle situations where one or the surrounding frames have incomplete information for an effective morphing. This occurs when objects of the surrounding frames are occluded by objects in the other frame.

For at least one or more implementations this stencil buffer is a special dedicated stencil buffer that is specific to the implementation and maintained by an extra step that is part of the full rendering a surrounding frame. A computer graphics system e.g. GPU and 3D applications may have other stencil buffers that it uses for other purposes.

As depicted the 2D screen space projection shows a solid colored sphere on the left hand size of the screen. This is intended to correspond to the wireframe sphere shown in the 3D model and illustrate the effect of 3D rendering. Similarly the 2D screen space projection shows a solid colored sphere on the right hand size of the screen. This is intended to correspond to the wireframe sphere shown in the 3D model and illustrate the effect of 3D rendering.

Frames and are not part of the set of fully 3D rendered frames e.g. and they must be generated. To continue a smooth and constituent frame rate the interposed frames e.g. frames and are placed as equal distance in the frame sequence. For example frame is generated as though it occurred at frame n 1. That is frame is generated so that it occurs at a time that about a third of the way between when frame and frame occur.

With this the pixels of a triangle in the morphed frame are drawn in the middle assuming 1 1 fill ratio of the stretch it made when moving between surrounding frames e.g. if the pixel which is say the middle of a triangle moved one inch to the right when comparing frame n and n 2 then in the morphed frame n 1 we will draw it half an inch to the right from its original position and will use a blend of its colors in the original and final positions by the way .

To illustrate this the solid spheres of the 2D screen space projections and are shown traveling across the display on which the screen spaces would be displayed. The movement or change of the sphere in the interposed frames e.g. and are projected calculated or morphed based upon the geometry information from the surrounding frames.

Scene shows a triangle of a before or previous frame such as frame and shows that triangle in dashed lines. The scene also shows a triangle of an after or succeeding frame such as frame .

In the virtual 3D space an implementation of the morph processing determines e.g. computers motion vectors such as those labeled in scene from the vertices of the triangle of the before frame to the corresponding vertices of the triangle of the after frame. These vectors are also called vertex motion vectors.

As shown in scene the implementation segments the vertex motion vectors at points into two vectors. These new vertex motion vectors originate at points and point towards the surrounding frames. Typically this segmentation divides the vertex motion vectors equally.

While this example shows the vertex motion vector being divided into two equal segments or new vectors other implementations may divide the vertex motion vectors into more than two equally spaced segments. This may be done to insert more than one morphed frame between surrounding frames. These segmented vertex motion vectors may be called the forward and backward motion vectors.

Scene shows a new or intermediate triangle created in a new 2D screen space projection. The vertices of the intermediate triangle are the points the origin points of the segmented motion vectors.

Scene shows the intermediate triangle with its segmented motion vectors pointing forward or backward towards its source triangle of the surrounding frames.

Also scene shows the pixels of the intermediate triangle associated with their corresponding segmented motion vectors. Those motion vectors are assocaiont with corresponding pixels of the before and after frame. For example as shown in scene pixel of the intermediate triangle is associated with its motion vector that points a corresponding pixel from the before frame such as and from corresponding pixel from the after frame such as .

The backward and forward motion vectors are used to shade the intermediate triangle with the motion vectors at each pixel e.g. pixel interpolated between triangle vertices. For each pixel of the intermediate triangle the pixel processing uses a pair of backward and forward motion vectors relative to the current position used to calculate the coordinates of the pixel to be copied from the before and after frames respectively.

At block the computer graphics system renders frame n e.g. frame using for example conventional full 3D rendering. While this is called frame n here it may also be called the before preceding previous first or part of the pair of surrounding 3D rendered frames. The geometry processing e.g. portion of the rendering produces geometry information regarding the vertices of frame n. This may also be called geometry stage output. The system stores the geometry information for the rendered frame n at cache .

At block the computer graphics system renders frame n 3 e.g. frame using for example conventional full 3D rendering. While this is called frame n 3 here it may also be called the after succeeding current second or part of the pair of surrounding 3D rendered frames. The geometry processing e.g. portion of the rendering produces geometry information. This may also be called geometry stage output. The system stores the geometry information for the rendered frame n 3 at cache .

The geometry information produced by the rendering of the surrounding frames and used by later portions of this process includes for example the vertex coordinates as the relevant vertex attributes. Other attributes include surface normal vectors and vertex lighting and the like.

At the system computes vertex motion vectors based upon the geometry information e.g. vertex coordinates obtained from the surrounding pair of frames from caches and . As illustrated in scene of the system derive e.g. compute motion vectors such as those labeled in scene from the vertices of the triangle of the before frame to the corresponding vertices of the triangle of the after frame. These vectors are also called vertex motion vectors.

At the system segments the computed motion vectors based upon the fill ratio. As illustrated in scene of the system divides each of the vertex motion vectors at points into two vectors segments. These new vertex motion vectors originate at points and point towards the surrounding frames. Typically this segmentation divides the vertex motion vectors equally.

Fill ratio is the ratio of morphed to fully rendered frames. For example a ratio of 1 1 means there is one morphed frame for every two fully rendered frames.

At the system computes the segmented motion vectors and makes them to be the vertex attributes. They may be described as setting up backward and forward motion vectors as interpolated vertex attributes. As illustrated in scene of the system interpolates vertex attributes of the intermediate triangle based upon the attributes of the vertices of the corresponding triangles e.g. and of the surrounding frames e.g. and . The positions where to read the color information from are interpolated based on the motions vectors the colors themselves are read from the surrounding frames in a subsequent stage i.e. pixel processing the output color is interpolated form the two read values.

At the system interpolates motion vectors between vertices The system uses the interpolated motion vectors to read pixel colors from surrounding frames then the system calculates a weighted sum value from the two colors.

At the system stores e.g. caches or transfers the motion vectors as vertex attributes to be later used for determining the per pixel motion of the morphed frame.

Data blocks and represent data sources used by this example process . They may be implemented in a cache or memory storage space. Alternatively they may be received from the hardware that calculates or produces the data. Lines and represent the morphing process accessing data from data blocks and .

Data block is the result of the example process . In particular data block includes the motion vectors of the morphed frame. Data blocks and include pixel information e.g. color from the surrounding frames e.g. frame n and frame n 3 .

At block the computer graphics system computes the position of the pixels to fetch from the surrounding frames based upon the motion vectors e.g. from data block . The computer graphics system determines the attributes e.g. color of the pixels of the intermediate triangle e.g. from corresponding e.g. fetched pixels of the before and after frame. For example as shown in scene of the attributes e.g. color of pixel of the intermediate triangle is interpolated from both the attributes e.g. color from corresponding pixel from the before frame such as and the attributes of the corresponding pixel from the after frame such as .

Using the motion vectors e.g. from data block the system calculates color value for the pixels of the intermediate triangle as a distance based weighted sum of the backward and forward frame pixel color values to yield smooth color and lighting transition.

At the system reads stencil buffers of surrounding frames. It may acquire the information of the stencil buffers from the frame information data blocks and . A stencil buffer maintains information associating pixels with triangles. Therefore the system can use the stencil buffer information to determine which pixels of the surrounding frames correspond to the pixel of the intermediate triangle.

With the triangle pixel association information from each of the surrounding frames the system can determine whether the source triangles of the surrounding frames were covered or occluded. If so then the attributes of one or part of one of the triangles may not exist in the 2D screen space projection of one of the surrounding frames. In this situation attribute information for the intermediate triangle of the morphed frame is available from only one triangle of one of the surrounding frames.

Scene shows two triangles in dashed lines. Triangles and overlap each other. For this example presume that these triangles are from one the fully rendered frames. They are also labeled and respectively. Scene shows the same triangles and but with shading i.e. color as they would appear in a 2D screen space projection. From this shaded scene one can tell that triangle overlaps or obscures the triangle .

Scene shows the same triangles and but it shows another triangle labeled . This new triangle represents a geometry transformation between successive frames.

As shown by scene the geometry transformation between frames caused some areas of triangle covered by another triangle triangle in the previous frame to become uncovered in the current frame. The appropriate uncovering is shown by the shading and hatching of the triangles shown in scene . This leads to a case where there are no known pixels that can be copied from one of the backward or the forward frame for the area.

In this case the color value of the one available pixel is copied instead of the weighted sum of color values. To support determining whether both or only one pixel color values are available a stencil buffer for a per primitive unique predefined value storing on successful color buffer writes is maintained. This predefined value is the same for corresponding geometry primitives in each frame e.g. draw call number . If the stencil read value is equal to this predefined value of the currently rendered primitive the pixel is deemed available for copying.

At the system determines whether a pixel of the intermediate triangle has both corresponding pixels available in the 2D screen space projection of the surrounding frames. Said differently the system determines if the stencil values are equal to a predefined value.

If so then at block the system computes distance based weighted attribute e.g. color sum of the both corresponding pixels available in the 2D screen space projection of the surrounding frames. That is the system does a form of color blending between the corresponding pixels from the surrounding frames.

Otherwise then at block the system copies the color attribute from the sole corresponding pixel available in the 2D screen space projection of one of the surrounding frames. Thus there is no blending or interpolation in this instance.

At block for each pixel of an intermediate triangle the system stores the determined attribute value e.g. color for that pixel. It does this and inserts it into the frame buffer. When this is done for all of the triangles then an entire 2D screen space projection of the morphed frame is created.

The frame buffer the 2D screen space projection as represented as a bitmap that represents a complete frame of data. This bitmap is driven to a video display of a computer graphics system e.g. GPU .

Said differently at block the system inserts the morphed frame into the frame sequence. For example it inserts frame and between fully rendered frames and .

A computer graphics system e.g. GPU produces a 2D screen space projection of a first frame using full three dimensional 3D rendering. The 2D screen space projection of the first frame includes projections of primitives rendered from a 3D model associated with the first frame.

The computer graphics system produces a 2D screen space projection of a second frame using full 3D rendering. The 2D screen space projection of the second frame includes projections of primitives rendered from a 3D model associated with the second frame.

The computer graphics system morphs a 2D screen space projection of one or more intermediate frames based at least in part on color attributes associated with 2D screen space projections of the primitives of both the first and the second frames. The intermediate frame morphing includes interpolation of the color attributes of 2D screen space projections of the primitives of each the first and the second frames.

The intermediate frame morphing is based at least in part on geometry information regarding the primitives of the each of the first and second frames. The geometry information includes positions of vertices of the primitives of their frame s associated 2D screen space projection. The intermediate frame morphing further includes computing vertex motion vectors from the vertices of the primitives of the first frame s associated 2D screen space projection to the vertices of corresponding primitives of the second frame s associated 2D screen space projection.

The intermediate frame morphing further includes segmenting the vertex motion vectors into multiple motion vectors each of these segmented motion vectors refers back to its corresponding primitives of either the first frame or the second frame generating one or more intermediate primitives based on the segmented motion vectors and interpolating color motion vectors of vertices of the one or more intermediate primitives from vertex attributes of corresponding primitives of the first frame and the second frame.

The intermediate frame morphing is based at least in part on pixel information regarding the primitives of the each of the first and second frames. The pixel information includes color values of pixels of the primitives of their frame s associated 2D screen space projection. The intermediate frame morphing further includes interpolating color motion vectors of pixels of the one or more intermediate primitives from pixel attributes of corresponding primitives of the first frame and the second frame. The intermediate frame morphing further includes for a particular pixel of the one or more intermediate primitives determining that a corresponding pixel exists in the 2D screen space projection of only one of the first and the second frames and in response to that determination copying one or more color attributes of the corresponding pixel to the particular pixel of the one or more intermediate primitives.

The computer graphics system displays the first frame the one or more intermediate frames and the second frame in that order.

A computer graphics system e.g. GPU three dimensionally renders 3D render a pair of frames to produces a 2D screen space image for each frame. Each of the 2D screen space images includes projections of primitives 3D rendered from a 3D model associated with that frame.

The computer graphics system generates a 2D screen space projection of an intermediate frame based at least in part on attributes of 2D screen space projections of the primitives of the pair of 3D rendered frames. The attributes include color values. The intermediate frame is generated without 3D rendering of that frame.

The generation includes morphing of the attributes of 2D screen space projections of the primitives of each the pair of 3D rendered frames. The morphing includes interpolation of the attributes of 2D screen space projections of the primitives of the pair of 3D rendered frames.

The computer graphics system presents a sequence of frames on a display with the intermediate frame being presented in the sequence of frames between the presentation of the pair of 3D rendered frames.

Alternatively the computer graphics system may generate additional intermediate frames based at least in part on attributes of 2D screen space projections of the primitives of the pair of 3D rendered frames and during the presentation of the sequence of frames insert the additional intermediate frames between the presentation of the pair of 3D rendered frames.

To reduce perceived latency the pixel processing like that of an example process for the intermediate and the after or current frame can be scheduled in parallel or be executed at least in part within the pixel shader of one of the intermediate frames.

An additional level of rendering coarseness performance control is provided by scaling the size of the interpolated motion vectors buffer vs. the actual frame buffer. A variation of the example process may use a buffer with edges scaled by half that will result in motion vectors pointing to 2 2 pixel blocks rather than individual pixels in the source frames computed at a quarter cost of a per pixel motion vector buffer.

In the above description of example implementations for purposes of explanation specific numbers materials configurations and other details are set forth in order to better explain the present invention as claimed. However it will be apparent to one skilled in the art that the claimed invention may be practiced using different details than the example ones described herein. In other instances well known features are omitted or simplified to clarify the description of the example implementations.

The inventor s intend the described example implementations to be primarily examples. The inventor s do not intend these example implementations to limit the scope of the appended claims. Rather the inventor s have contemplated that the claimed invention might also be embodied and implemented in other ways in conjunction with other present or future technologies.

Moreover the word example is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as example is not necessarily to be construed as preferred or advantageous over other aspects or designs. Rather use of the word example is intended to present concepts and techniques in a concrete fashion. The term techniques for instance may refer to one or more devices apparatuses systems methods articles of manufacture and or computer readable instructions as indicated by the context described herein.

As used in this application the term or is intended to mean an inclusive or rather than an exclusive or. That is unless specified otherwise or clear from context X employs A or B is intended to mean any of the natural inclusive permutations. That is if X employs A X employs B or X employs both A and B then X employs A or B is satisfied under any of the foregoing instances. In addition the articles a and an as used in this application and the appended claims should generally be construed to mean one or more unless specified otherwise or clear from context to be directed to a singular form.

These processes are illustrated as a collection of blocks in a logical flow graph which represents a sequence of operations that can be implemented in mechanics alone or a combination with hardware software and or firmware. In the context of software firmware the blocks represent instructions stored on one or more computer readable storage media that when executed by one or more processors perform the recited operations.

Note that the order in which the processes are described is not intended to be construed as a limitation and any number of the described process blocks can be combined in any order to implement the processes or an alternate process. Additionally individual blocks may be deleted from the processes without departing from the spirit and scope of the subject matter described herein.

The term computer readable media includes computer storage media. For example computer storage media may include but are not limited to magnetic storage devices e.g. hard disk floppy disk and magnetic strips optical disks e.g. compact disk CD and digital versatile disk DVD smart cards flash memory devices e.g. thumb drive stick key drive and SD cards and volatile and non volatile memory e.g. random access memory RAM read only memory ROM .

In the claims appended herein the inventor invokes 35 U.S.C. 112 f or paragraph only when the words means for or steps for are used in the claim. If such words are not used in a claim then the inventor does not intend for the claim to be construed to cover the corresponding structure material or acts described herein and equivalents thereof in accordance with 35 U.S.C. 112 f or paragraph .

To the extent various operations or functions are described herein they can be described or defined as hardware circuitry software code instructions configuration and or data. The content can be embodied in hardware logic or as directly executable software object or executable form source code high level shader code designed for execution on a graphics engine or low level assembly language code in an instruction set for a specific processor or graphics core. The software content of the embodiments described herein can be provided via an article of manufacture with the content stored thereon or via a method of operating a communication interface to send data via the communication interface.

A non transitory machine readable storage medium can cause a machine to perform the functions or operations described and includes any mechanism that stores information in a form accessible by a machine e.g. computing device electronic system etc. such as recordable non recordable media e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. . A communication interface includes any mechanism that interfaces to any of a hardwired wireless optical etc. medium to communicate to another device such as a memory bus interface a processor bus interface an Internet connection a disk controller etc. The communication interface is configured by providing configuration parameters or sending signals to prepare the communication interface to provide a data signal describing the software content. The communication interface can be accessed via one or more commands or signals sent to the communication interface.

Various components described can be a means for performing the operations or functions described. Each component described herein includes software hardware or a combination of these. The components can be implemented as software modules hardware modules special purpose hardware e.g. application specific hardware application specific integrated circuits ASICs digital signal processors DSPs etc. embedded controllers hardwired circuitry etc. Besides what is described herein various modifications can be made to the disclosed embodiments and implementations of the invention without departing from their scope. Therefore the illustrations and examples herein should be construed in an illustrative and not a restrictive sense. The scope of the invention should be measured solely by reference to the claims that follow.

A graphics processing unit GPU that facilitates bi directional morphing of two dimensional 2D screen space projections the GPU comprising a graphics processor configured to process computer graphics a memory configured to operate with the graphics processor the graphics processor further configured to produce a 2D screen space projection of a first frame using full three dimensional 3D rendering wherein the 2D screen space projection of the first frame includes projections of primitives rendered from a 3D model associated with the first frame produce a 2D screen space projection of a second frame using full 3D rendering wherein the 2D screen space projection of the second frame includes projections of primitives rendered from a 3D model associated with the second frame morph a 2D screen space projection of one or more intermediate frames based at least in part on color attributes associated with 2D screen space projections of the primitives of both the first and the second frames display the first frame the one or more intermediate frames and the second frame in that order.

A GPU of Example 1 wherein the intermediate frame morphing includes interpolation of the color attributes of 2D screen space projections of the primitives of each the first and the second frames.

A GPU of Example 1 wherein the intermediate frame morphing is based at least in part on geometry information regarding the primitives of the each of the first and second frames.

A GPU of Example 3 wherein the geometry information includes positions of vertices of the primitives of their frame s associated 2D screen space projection.

A GPU of Example 4 wherein the intermediate frame morphing further includes computing vertex motion vectors from the vertices of the primitives of the first frame s associated 2D screen space projection to the vertices of corresponding primitives of the second frame s associated 2D screen space projection.

A GPU of Example 5 wherein the intermediate frame morphing further includes segmenting the vertex motion vectors into multiple motion vectors each of these segmented motion vectors refers back to its corresponding primitives of either the first frame or the second frame generating one or more intermediate primitives based on the segmented motion vectors interpolating motion vectors of vertices of the one or more intermediate primitives from vertex attributes of corresponding primitives of the first frame and the second frame.

A GPU of Example 1 wherein the intermediate frame morphing is based at least in part on pixel information regarding the primitives of the each of the first and second frames.

A GPU of Example 7 wherein the pixel information includes color values of pixels of the primitives of their frame s associated 2D screen space projection.

A GPU of Example 7 wherein the intermediate frame morphing further includes interpolating motion vectors of pixels of the one or more intermediate primitives from pixel attributes of corresponding primitives of the first frame and the second frame.

A GPU of Example 7 wherein the intermediate frame morphing further includes for a particular pixel of the one or more intermediate primitives determining that a corresponding pixel exists in the 2D screen space projection of only one of the first and the second frames in response to that determination copying one or more color attributes of the corresponding pixel to the particular pixel of the one or more intermediate primitives.

A graphics processing unit GPU comprising a graphics processor configured to process computer graphics a memory configured to operate with the graphics processor the graphics processor further configured to produce a 2D screen space projection of a first frame using full three dimensional 3D rendering wherein the 2D screen space projection of the first frame includes projections of primitives rendered from a 3D model associated with the first frame produce a 2D screen space projection of a second frame using full 3D rendering wherein the 2D screen space projection of the second frame includes projections of primitives rendered from a 3D model associated with the second frame morph a 2D screen space projection of one or more intermediate frames based at least in part on attributes of 2D screen space projections of the primitives of both the first and the second frames wherein the morphing includes interpolation of the attributes of 2D screen space projections of the primitives of each the first and the second frames display the first frame the one or more intermediate frames and the second frame in that order.

A GPU of Example 11 wherein the intermediate frame morphing is based at least in part on geometry information regarding the primitives of the each of the first and second frames.

A GPU of Example 13 wherein the geometry information includes positions of vertices of the primitives of their frame s associated 2D screen space projection.

A GPU of Example 14 wherein the intermediate frame morphing further includes computing vertex motion vectors from the vertices of the primitives of the first frame s associated 2D screen space projection to the vertices of corresponding primitives of the second frame s associated 2D screen space projection.

A GPU of Example 15 wherein the intermediate frame morphing further includes segmenting the vertex motion vectors into multiple motion vectors each of these segmented motion vectors refers back to its corresponding primitives of either the first frame or the second frame generating one or more intermediate primitives based on the segmented motion vectors interpolating vertex motion vertices of the one or more intermediate primitives from vertex attributes of corresponding primitives of the first frame and the second frame.

A GPU of Example 11 wherein the intermediate frame morphing is based at least in part on pixel information regarding the primitives of the each of the first and second frames.

A GPU of Example 17 wherein the pixel information includes color values of pixels of the primitives of their frame s associated 2D screen space projection.

A GPU of Example 17 wherein the pixel information includes color of pixels of the primitives of their frame s associated 2D screen space projection.

A GPU of Example 17 wherein the intermediate frame morphing further includes interpolating attributes of pixels of the one or more intermediate primitives from pixel attributes of corresponding primitives of the first frame and the second frame.

A GPU of Example 17 wherein the intermediate frame morphing further includes for a particular pixel of the one or more intermediate primitives determining that a corresponding pixel exists in the 2D screen space projection of only one of the first and the second frames in response to that determination copying one or more attributes of the corresponding pixel to the particular pixel of the one or more intermediate primitives.

A graphics processing unit GPU comprising a graphics processor configured to process computer graphics a memory configured to operate with the graphics processor the graphics processor further configured to three dimensionally render 3D render a pair of frames to produces a 2D screen space projection for each frame wherein each of the 2D screen space projections includes projections of primitives 3D rendered from a 3D model associated with that frame generate a 2D screen space projection of an intermediate frame based at least in part on attributes of 2D screen space projections of the primitives of the pair of 3D rendered frames presenting a sequence of frames on a display wherein the intermediate frame is presented in the sequence of frames between the presentation of the pair of 3D rendered frames.

A GPU of Example 22 wherein the graphics processor is further configured to generate additional intermediate frames based at least in part on attributes of 2D screen space projections of the primitives of the pair of 3D rendered frames during the presentation of the sequence of frames insert the additional intermediate frames between the presentation of the pair of 3D rendered frames.

A GPU of Example 22 wherein the generating includes morphing of the attributes of 2D screen space projections of the primitives of each the pair of 3D rendered frames.

A GPU of Example 22 wherein the generating includes interpolation of the attributes of 2D screen space projections of the primitives of the pair of 3D rendered frames.

A GPU of Example 22 wherein the intermediate frame morphing is based at least in part on geometry information regarding the primitives of the pair of 3D rendered frames.

A GPU of Example 22 wherein the intermediate frame morphing is based at least in part on pixel information regarding the primitives of the each of the first and second frames.

