---

title: Systems and methods of using a bitmap index to determine bicliques
abstract: A method includes receiving, at a computing device comprising a processor, a request to determine bicliques in a graph, where the graph includes a first set of nodes, a second set of nodes, and a set of edges, each edge in the set of edges connecting a node in the first set of nodes to a node in the second set of nodes. The method also includes determining at least one biclique based on querying a bitmap index representing the graph, where the bitmap index includes a plurality of bit strings corresponding to the first set of nodes, and where a value stored in a particular location in each bit string indicates whether an edge connects a first node corresponding to the bit string to a second node corresponding to the particular location.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09607104&OS=09607104&RS=09607104
owner: UMBEL CORPORATION
number: 09607104
owner_city: Austin
owner_country: US
publication_date: 20160429
---
Computer networks such as public networks e.g. the Internet and private networks e.g. at medical institutions financial institutions business enterprises etc. have become a medium for research communication distribution and storage of data. Consequently more and more devices are network enabled. To illustrate on any given day a typical user may access a half dozen or more network enabled devices such as their mobile phone tablet computer home security system devices one or more wearable devices a home laptop or desktop a work laptop or desktop and home entertainment devices e.g. televisions game consoles set top boxes etc. . Moreover Internet of Things IoT protocols enable network enabled devices to communicate with each other without user intervention. Thus there is an increasing amount of data being accessed transferred and stored online. As users use networks to access data they also generate a large amount of data regarding themselves. On websites such as social networks users actively and willingly share data regarding themselves. Identifying patterns in the data about users can be useful for analytics purposes such as for informed marketing. However identifying such patterns may be ineffective or impractical due to the sheer volume of data generated by computer network use.

One way of representing data is to use a graph data structure. A graph data structure typically includes nodes that are connected by edges. For example in a graph data structure corresponding to an Internet based social network nodes may represent users and edges may represent that two users are friends on the social network. Various data patterns can be identified in graph data structures. Examples of such data patterns include but are not limited to cliques maximal cliques bicliques and maximal bicliques. A clique is a set of nodes in a graph such that each node of the clique is connected to each other node of the clique. To illustrate in a social networking example a clique may correspond to a set of users in which each user is friends with each other user. A maximal clique is a clique such that it is not possible to add another node and still have the resulting set of nodes set be a clique. Stated differently a maximal clique is not part of any other clique. Thus in the social networking example for a maximal clique there is no other user on the social network that is friends with every user of the clique if there was the clique would not be maximal .

Some graphs are bipartite graphs bigraphs in which the nodes can be divided into two distinct sets such that no node in one set is connected to any other node of that set. Stated another way every edge of a bigraph connects a node from one set to a node in the other set. To illustrate a bigraph may be used to represent player affiliations in a sports league one set of nodes represents players the other set of nodes represents teams and edges represent that a player has played for a team. Bigraphs can have subsets of nodes and edges that are classified as bicliques also known as complete bipartite graphs in which each node from one set is connected to every node in the other set and vice versa. Thus a maximal biclique of a bigraph is a biclique such that it is not possible to add another node and have the result still be a biclique. Stated differently a maximal biclique is a biclique that is not part of any other biclique.

Determining bicliques and maximal bicliques is a computationally expensive N P hard problem to which there is no known polynomial time solution due to how much larger the search space becomes when even a single additional node is added to either side of a bigraph. The United Nations has estimated that there are over three billion people that use the Internet. Thus even if sufficient computing resources were available determining the bicliques present in such a large data set would be very time intensive. The systems and methods of the present disclosure enable determining bicliques on large data sets by leveraging an in memory e.g. in random access memory RAM bitmap index that represents the large data set or at least a subset thereof and by distributing computation across an arbitrary number of computing devices.

As an illustrative non limiting example a bitmap index may index data related to users that access a website. A system may track various characteristics of the users based on actions performed by the users on the web site actions performed by the users on other websites accessing the users social networking profiles etc. This raw data may be stored in a distributed storage network and the bitmap index may include bit strings corresponding to the raw data or a portion thereof . To illustrate the bitmap index may include a bit string for the demographic property Male and a bit string for the demographic property Age 21 25. The same position in each bit string may correspond to the same user. For example if a particular user is assigned a user identifier ID of N then the value of the Nbit of the Male bit string indicates whether the particular user is male and the value of the Nbit of the Age 21 25 bit string indicates whether the particular user is between the ages of 21 and 25.

The bitmap index may enable real time or near real time computation of various metrics or queries that combine logical set operations such as AND OR and NOT operations. When the underlying data set is large the bit strings of the bitmap index may be stored in distributed fashion across multiple storage nodes e.g. servers having memory and executing queries on the bitmap index may involve parallel computations on multiple storage nodes. As further described herein an algorithm to identify bicliques or maximal bicliques may be reduced to queries that perform logical set operations on a bitmap index and thus may be performed in a relatively short period of time even though the data set underlying the bitmap index is large.

In accordance with at last one described embodiment a method includes receiving at a computing device comprising a processor a request to determine bicliques in a graph where the graph includes a first set of nodes a second set of nodes and a set of edges each edge in the set of edges connecting a node in the first set of nodes to a node in the second set of nodes. The method also includes computing at least one biclique based on querying a bitmap index representing the graph where the bitmap index includes a plurality of bit strings corresponding to the first set of nodes and where a value stored in a particular location in each bit string indicates whether an edge connects a first node corresponding to the bit string to a second node corresponding to the particular location.

In another particular embodiment an apparatus includes a processor and a memory storing instructions executable by the processor to perform operations including receiving an event signal where the event signal includes information corresponding to a profile identifier associated with a user. The operations also include modifying a value of at least one bit stored in a bitmap index where the bitmap index corresponds to a graph having a first set of nodes a second set of nodes and a set of edges. Each edge in the set of edges connects a node in the first set of nodes to a node in the second set of nodes. The bitmap index includes a plurality of bit strings corresponding to the first set of nodes and a value stored in a particular location in each bit string indicates whether an edge connects a first node corresponding to the bit string to a second node corresponding to the particular location. The operations further include receiving a request to determine bicliques in the graph where the request specifies a target segment of users. The operations include computing at least one biclique based on querying the bitmap index.

In another particular embodiment a computer readable storage device stores instructions that when executed cause a computer to perform operations including receiving at a first storage node a request to determine bicliques in a graph where the graph includes a first set of nodes a second set of nodes and a set of edges each edge in the set of edges connecting a node in the first set of nodes to a node in the second set of nodes. The operations also include identifying one or more portions of bit strings that are stored at the first storage node and that are associated with a bitmap index where the bitmap index includes a plurality of bit strings corresponding to the first set of nodes and where a value stored in a particular location in each bit string indicates whether an edge connects a first node corresponding to the bit string to a second node corresponding to the particular location. The operations further include determining at the first node at least a first biclique based on the one or more portions of bit strings that are stored at the first storage node. The operations include forwarding the request to at least a second storage node for determination of at least a second biclique and receiving data identifying the second biclique from the second storage node. The operations also include outputting data identifying the first biclique and the data identifying the second biclique in response to the request.

The measurement system may be implemented using one or more computing devices e.g. servers . For example such computing devices may include one or more processors or processing logic memories and network interfaces. The memories may include instructions executable by the processors to perform various functions described herein. The network interfaces may include wired and or wireless interfaces operable to enable communication to local area networks LANs and or wide area networks WANs such as the Internet. In the illustrated example the measurement system is communicably coupled to a network .

The event signals may include information associated with audience members of a media property. For example when an audience member creates an account or otherwise registers with a media property using social networking identification the measurement system may retrieve event signals corresponding to data stored in social networking profiles of the audience member. As another example the event signals may identify specific interactions by the audience members with respect to the media property e.g. what action was taken at a media property when the action was taken for how long the action was taken etc. . The interactions may include interactions with advertisements presented by the media property and or interactions with content presented by the media property. In a particular embodiment each of the event signals identifies a property e.g. Property and an audience member alternately referred to herein as a user . For example if a user having a user ID N made a purchase on the website for Property a corresponding event signal received by the measurement system may be userID N property Property behavior Purchase . In alternate embodiments a different format may be used to represent an event signal.

The measurement system may include a data processing module and a query execution module each of which may be implemented using instructions executable by one or more processors at the measurement system . The data processing module may receive the event signals and store raw data corresponding to the event signals e.g. a copy of the event signals in cloud based storage . The data processing module may also store indexing data for the cloud based storage in a bitmap index . In a particular embodiment unlike the cloud based storage the bitmap index may be local or more quickly accessible to the measurement system . To illustrate data for the bitmap index may be stored across one or more data storage devices e.g. nodes that are part of the measurement system or accessible to the measurement system via a LAN or other private high speed network as opposed to a WAN. Alternatively or in addition data of the bitmap index may be stored in memory such as in RAM. Thus read and write operations with respect to the bitmap index may be faster than corresponding read and write operations with respect to the cloud based storage .

The measurement system may maintain a bitmap index for each media property being measured. Data in the bitmap index may be stored in the form of bit strings. The bitmap index may store bit strings corresponding to at least a subset of the data stored in the cloud based storage . Thus depending on implementation the bitmap index may for a particular media property include bit strings for all of the data stored in the cloud based storage or less than all of the data stored in the cloud based storage . In a particular embodiment the bitmap index for a particular media property includes for each audience member of the media property data regarding one or more attributes of the audience member which may include but are not limited to demographic attributes brand affinities behaviors e.g. interactions with the media property etc.

To illustrate a media property may have a known audience of one hundred thousand registered members. The bitmap index for the media property may include bit strings representing various attributes associated with each of the hundred thousand audience members. Thus each of the bit strings may be one hundred thousand bits in length. Further the same location in each bit string may correspond to the same audience member. For example if the Nlocation in a Male bit string has a value of 1 and the Nlocation in a Watches video bit string has a value of 1 this indicates that the Naudience member who has a userID N is a male that has watched at least one video on the property.

In some examples the bitmap index for a media property may store bit strings corresponding to less than all of the data stored in the cloud based storage . For example although the cloud based storage may include raw data corresponding millions of signals tiles the bitmap index may store bit strings for a smaller subset of the most signals tiles e.g. the top fifty thousand signals tiles . In an alternative embodiment the bitmap index may store bit strings for all of the signals tiles tracked in the cloud based storage . Examples of the bitmap index are further described herein. In a particular embodiment the bitmap index is automatically sorted based on a parameter such as the total count of asserted bits in each bit strings as an illustrative non limiting example.

The query execution module may be configured to use the bitmap index to execute queries regarding measurement data for a media property. For example the query execution module may receive a query corresponding to the question What are the top 50 tiles signals for my audience In a particular embodiment the query may be generated using a query generation interface. If the bitmap index is already sorted by the total number of asserted bits the query execution module may return data regarding the first fifty strings in the bitmap index .

Alternatively if the bitmap index is not sorted the query execution module may perform count operations on bit strings stored in the bitmap index . In a particular embodiment because the bit strings may be stored across multiple nodes the query execution module may formulate a query execution plan that parallelizes execution of the query across multiple nodes and minimizes the amount of data that is transferred between nodes during execution of the query . By executing the query on bit strings stored in the bitmap index in parallel without retrieving data from the cloud based storage and by reducing or minimizing data transfers the query execution module may achieve real time or near real time performance. For example the query execution module may have a maximum query execution latency less than or equal to one hundred milliseconds. Further examples regarding query execution are described herein.

During operation the measurement system may receive the event signals from various event sources. Each event signal may include a unique identifier such as a user ID. If the user is a new audience member the user may be assigned a new user ID and a user profile may be created for the user. Data for the user profile may be stored in the cloud based storage and or the bitmap index . In a particular embodiment data for the user profile may be retrieved from third party data sources including but not limited to social networks. For example the data may include but is not limited to demographic information associated with the user e.g. a name an age a geographic location a marital family status a homeowner status etc. social information associated with the user e.g. social networking activity of the user social networking friends likes interests of the user etc. and other types of data. The cloud based storage and the bitmap index may be updated as additional event signals are received e.g. when additional users register with the media property interact with the media property etc. .

When the measurement system receives the query the query execution module may execute the query based on a query execution plan that parallelizes execution and reduces minimizes the amount of bit string data that is transferred between nodes during execution of the query . The system of may thus enable audience measurement and analysis based on data e.g. event signals received from various sources. For example event signals may be generated in response to user interactions with websites web pages audio items video items games and or text associated with various media properties. Further the system of may enable real time or near real time execution of queries on the collected data. For example the query execution module may execute complex top N queries using the bitmap index in real time or near real time e.g. within one hundred milliseconds .

In alternate embodiments the described bitmap index may correspond to patients and the event signals may identify a patient and may correspond to a healthcare event e.g. a visit to a doctor s office a prescription being filled etc. . Bit strings of the bitmap index may correspond to medical attributes such as medical history allergy information medication taken etc. The same location in each bit string may correspond to the same patient. As another example a tracked audience may correspond to inventory or customers of a store. Bit strings of the bitmap index may correspond to attributes of inventory such as color price demand etc. and or attributes of customers. The same location in each bit string may correspond to the same inventory item or the same customer. As yet another example in the financial industry the same location in each bit string may correspond to the same investor the same financial advisor the same financial product etc. As yet another example bit strings of the bitmap index may correspond to data output by devices in an IoT environment and the same location of each bit string may correspond to the same device.

In some embodiments data represented by the bitmap index may correspond to a graph. For example illustrates an example of a bitmap index corresponding to a graph . In the graph a set of profiles P P and P corresponding to users named Alex Bill and Cindy are selectively connected to a set of tiles T T and T corresponding to a user being female a user having bought coffee and a user having shopped online . A connection between nodes of the graph corresponds to an asserted bit in the bitmap index . For example because Bill and Cindy have shopped online the bit string for T has a value of 1 for P and P. Although a 3 3 bitmap index is illustrated for simplicity it is to be understood that the techniques of the present disclosure may be used with bitmap indexes having an arbitrary number of rows e.g. R where R is an integer greater than or equal to one and an arbitrary number of columns e.g. C where C is an integer greater than or equal to one .

Various data patterns can be identified in graph data structures. Examples of such data patterns include but are not limited to cliques maximal cliques bicliques and maximal bicliques. A clique is a set of nodes in a graph such that each node of the clique is connected to each other node of the clique. A maximal clique is a clique such that it is not possible to add another node and still have the resulting set of nodes be a clique. Stated differently a maximal clique is not part of any other clique. The graph can be classified as a bipartite graph bigraph because nodes of the graph can be divided into two distinct sets such that the no node in one set is connected to any other node of that set. That is every edge of the graph connects a node from one set to a node in the other set. Bigraphs can include subsets of nodes and edges that are classified as bicliques also known as complete bipartite graphs in which each node from one set is connected to every node in the other set and vice versa. Thus a maximal biclique of a bigraph is a biclique such that it is not possible to add another node and have the result still be a biclique. Stated differently a maximal biclique is a biclique that is not part of any other biclique.

In some examples the query execution module of may be configured to execute queries corresponding to logical operations that are performed when determining quasi maximal bicliques e.g. bicliques that are maximal near maximal or sufficiently large to be of interest . When a bigraph links user profiles to attribute tiles as in determining bicliques or maximal bicliques can be useful to identify groups of seemingly unrelated users profiles that all share common attributes tiles . For example assume a bigraph represents ticket sales for a professional sports franchise during a calendar year. Nodes in one set of the bigraph may represent individual ticket purchasers and nodes in the other set of the bigraph may represent attributes regarding ticket purchasers such as age payment method estimated household income whether the ticket was part of a season ticket package or an individual event ticket average amount of money spent by the purchaser on concessions whether the purchaser bought tickets as part of a group purchase etc. Determining bicliques or maximal bicliques in the bigraph may enable the professional sports franchise to determine various personas of the ticket purchasing population. For example a first maximal biclique identified in the bigraph may indicate that a large number of the ticket purchasers were season ticket holders that spent very little money on concessions. Based on this information the sports franchise may conclude that season ticket holders were opting to dine elsewhere before or after events and may diversity concession offerings in an effort to incite season ticket holders to spend more on food and beverages.

In the algorithm begins with an initial call to a biclique find procedure which includes the parameters G L R P and Q. G is the graph of including all nodes and edges L is initially the set of all profiles in the graph R is initially empty P is initially the set of all tiles in the graph and Q is initially empty. Additional sets R L P and Q are initialized as empty. Generally as the algorithm proceeds R will contain a subset of P that includes candidate nodes for a maximal biclique L will contain nodes connected to the nodes in R and Q will contain examined candidate nodes. Thus as the algorithm proceeds R will generally grow while P and L generally shrink.

Continuing to while P is not empty a tile x is removed from P and added to the R and profiles connected to the tiles in R are moved from L to L . In the illustrated example x T shaded in gray on is removed from P and added to R leaving T and T in P. Further because T is connected to P P is moved from L to L . It will be appreciated that a query on the bitmap index of may be used to identify all profiles connected to a tile e.g. by checking which bits have a value of 1 in the bit string corresponding to the tile . In the example of the third bit of the bit string for T has a value of 1 and is marked using a hatch pattern for purposes of illustration.

Advancing to the candidate biclique L R is checked for maximality by iterating over P. If any node in P connect to all nodes in L then that node is added to R i.e. the candidate biclique is extended to include the node . To illustrate in T is added to R because T connects to all of the nodes in L i.e. to P. Similarly continuing to T is added to R because T connects to all of the nodes in L i.e. to P. In a particular embodiment the bitmap index may be used to determine whether a particular tile in P connects to all of the profiles in L . In particular a tile is connected to all of the profiles in L when the bit string for the tile has a value of 1 at the bit positions corresponding to each of the profiles in L . Thus to iterate over P and check maximality a profiles bit string may first be generated based on the profiles in L . In the profiles bit string the bit positions corresponding to each of the profiles in L may have a value of 1 . Then a logical AND operation may be performed between the profiles bit string and the bit strings for each of the tiles in P. If the result of the logical AND operation is the same as the profiles bit string then the tile had a value of 1 in for each of the profiles in L and the corresponding tile is added to R .

Advancing to after the iteration over P to check maximality is completed L R is output as a maximal biclique. In the example of the computed maximal biclique is P T T T which corresponds to the persona of female that buys coffee and shops online. Continuing to Q is expanded to include x T indicating T has been examined during a preceding iteration of the biclique find procedure.

A second iteration of the main while loop of the biclique find procedure begins in . During this second iteration x T is removed from P and added to R . P and P are added to L because they are connected to T by an edge. The fact that P and P are connected to T may be determined by querying on the bitmap index of to see which bit positions have a value of 1 in the bit string corresponding to tile T.

Progressing to the nodes in Q are iterated over to determine whether the remaining algorithm steps for this value of x can be skipped because Q includes a node that is connected to all nodes in L . When this condition is met the biclique L R cannot be maximal. In the example of the condition is not met because T is not connected to P. As a result T is added to Q as shown.

Advancing to maximality is checked by iterating over P. Unlike this time a node in P connects to fewer than all of the nodes in L . In particular T connects to P but not P. As a result T is added to the set P in preparation for a recursive call to the biclique find procedure.

Continuing to the maximal biclique L R is output. In this example the maximal biclique P P T corresponds to coffee buyers. Advancing to the biclique find procedure is recursively called using L R P and Q instead of L R P and Q respectively. To illustrate as shown in during the recursive call the set L is initialized with the nodes of L from and therefore does not include P. This is also graphically illustrated by hiding the column for P from the bitmap index in . During the recursive call the algorithm iterates over P. In the example of x T is removed from P leaving P empty and is added to R which already includes T due to the parameters passed during the recursive call . All nodes in L that are connected to T are added to L . Thus P is added to L .

Advancing to it is determined that a node in Q i.e. T connects to all of the nodes in L i.e. P . Therefore the candidate maximal biclique L R cannot be maximal. The rest of the procedure is skipped and x T is added to Q as shown. In this case because P is empty the while loop ends and thus the recursive call to biclique find initiated in also ends.

Returning from the recursive call x T is added to Q as shown in . Continuing to x T is removed from P leaving P empty and is added to R . All nodes connecting to T are added to L . Thus P and P are added to L . Advancing to T and T are added to Q because T and T are connected to some but not all nodes in L .

Continuing to because P is empty there is no need to iterate over P to check maximality of the candidate biclique L R . Thus the biclique P P T is output as a maximal biclique corresponding to the persona of online shopper. Q is expanded to include x T. Moreover because P is empty the biclique find procedure terminates.

Additional details regarding storing updating and querying a bitmap index are described with reference to . Referring to a particular embodiment of a bitmap index is shown. In an illustrative embodiment the bitmap index is the bitmap index of or the bitmap index of . The bitmap index may correspond to a particular media property tracked by the measurement system of . The bitmap index stores a plurality of bit strings which correspond to rows or portions thereof in the bitmap index . Each bit string represents a tile which in the example of correspond to demographic signals brand affinity signals and or behavior signals exhibited by the audience members. For purposes of illustration the bitmap index is shown as a grid where each row of the bitmap index corresponds to a bit string. In a bit string count is shown for the brand affinity bit strings. For example the bit string for Coffee Shop A has a total of 7 indicating that 7 audience members have a brand affinity for Coffee Shop A. 

As described with reference to the same location in each bit string may correspond to the same audience member e.g. profile or user ID . Thus each column of the bitmap index corresponds to a particular audience member. For example a zero 0 at the intersection of the row and the column indicates that the user having a user ID equal to Q does not have an income in the range of 100 000 110 000. It should be noted that the specific tiles shown in for example only. Bit strings may be stored for more fewer and or different tiles in alternative embodiments.

In a particular embodiment each bit string in the bitmap index is subdivided into slices e.g. sub strings . In the illustrated example each slice includes S bits where S is a positive integer. Thus a first slice of each bit string includes data related to audience members having IDs 0 to S 1. A last e.g. X slice includes data related to audience members having IDs X 1 S to Q. When bit strings are subdivided into slices different slices of the same bit string may be stored in different locations e.g. storage nodes . A hashing algorithm such as consistent hashing may be used e.g. during read operations write operations query execution etc. to identify locations of the slices of a bit string. The value of S which represents the maximum length of each slice may be set based on a desired query execution latency. In a particular embodiment S is equal to 65 535 e.g. each slice includes 2bits .

During operation the capture processor may receive an event signal corresponding to a new user registration event for the user . The event signal indicates that the user is to be assigned a new user ID and is a new user for the media property Property . The event signal also indicates e.g. on the basis of retrieved social networking data and or third party data that the user is a male has an income of 105 000 and is single. In alternate embodiments such demographic information may be automatically retrieved by a measurement system after the new user registration event as further described herein.

The capture processor which may implement a capture application programming interface API may send the event signal to the event processor . Because the user is a new audience member the event processor may generate and assign a new user ID to the user . For example the event processor may atomically increment a largest previously assigned user ID e.g. Q to generate a new user ID e.g. Q 1 . In a particular embodiment the event processor requests the new user ID from an atomic incrementer service e.g. a web service . The event processor may then store data corresponding to the event signal in the data store the SQL database and or the bitmap index . For example a new column may be created in the bitmap index by storing a new Q 1 bit in each of the bit strings in the bitmap index. When allocating and storing data in the Q 1 column involves creating a new slice the event processor may automatically generate a new slice for each bit string of the bitmap index . The value of the Q 1 bit in the Male Income 100 110 k and Single bit strings may be set to 1 based on the event signal. The value of the Q 1 bit in the remaining bit strings may be zero e.g. a default value .

As described with reference to in some embodiments the bitmap index includes bit strings for fewer than all of the attributes tiles being tracked. For example although all demographic and or behavioral tiles may be stored in the bitmap index bit strings for only the top N brands may be included in the bitmap index where N is an integer greater than or equal to one. In such embodiments a received event signal may cause a particular tile to become elevated into or fall out of the top N tiles. illustrates a particular embodiment of updating the bitmap index responsive to an event signal.

For ease of illustration the bitmap index is depicted as storing three brand affinity bit strings i.e. N 3 . Initially the three brands may be Coffee Shop A Store B and Television Network C. The brand affinity counts for the three brands are 7 5 and 10 audience members respectively. Brand affinity data for additional brands e.g. brands outside the top N brands may be stored in the data store .

A received event signal may indicate that the user has an affinity for Clothing brand D. Upon receiving the event signal the event processor may determine that a brand affinity bit string for Clothing Brand D is not stored in the bitmap index . Thus the event processor may store data for the event signal in the data store . The event processor or a background process or thread may determine that because of the event signal Store B which has a count of 5 has fallen outside of the top N brands and that Clothing Brand D which now has a count of 6 has become elevated into the top N brands. In response to the determination a bit string for Store B may be replaced in the bitmap index with a bit string for Clothing Brand D. 

Resolving the query may include ANDing each bit string location i.e. each user of a Male bit string with a corresponding location of an Income 100 110 k bit string as shown. When both corresponding locations contain a 1 the corresponding location of the filter string is set to 1. At the conclusion of the AND operations the filter string corresponds to a custom audience segment of men who earn 100 000 110 000.

In a particular embodiment the filter string is stored and available for use during execution of subsequent queries. The filter string may also be used to query the data store e.g. cloud based storage or the SQL database e.g. a user profile database regarding the custom audience segment. It should be noted that while the illustrated query calls for a single set operation to generate the filter string the described techniques may be used with more complex queries that involve any number of union operations intersection operations and or count operations. For example illustrates a particular embodiment of resolving a more complex second query to generate a second filter string . In the query is a top Z brand affinities query where Z is a positive integer .

The query requests identification of audience members that are male and that like Coffee Shop A or have made a purchase on the media property. The filter string may be generated by ORing a Coffee Shop A bit string with a Purchase bit string to generate an intermediate result string not shown . The filter string may be generated by ANDing the Male bit string with the intermediate result string. The audience members having a 1 in the filter string represent the audience members who are male and either have a brand affinity for Coffee Shop A or have made a purchase. In a particular embodiment the filter string may be stored and used during execution of subsequent queries. For example to answer the question What are the top 50 brands for men in my audience that either have an affinity for Coffee Shop A or have made a purchase the filter string may be generated. The filter string may be ANDed with each of the brand affinity bit strings to generate result strings. Count operations may be performed on the result strings and the brand affinities with the highest counts may be returned in response to the question.

It will be appreciated that during query execution the AND OR operations performed on bit strings are performed one bit at a time and the result of an operation on any single bit location does not impact the result of the operation on any other bit location. Thus query execution may be parallelized. For example when slices of the bit strings are stored at different network nodes performing an operation with respect to bit strings may be parallelized into performing the operation with respect to individual slices at individual nodes. To determine where and in what order such parallel operations should be performed a query execution module may generate a query execution plan.

For example illustrates a particular embodiment of generating of a query execution plan to resolve the query of . Upon receiving the query a query execution module may generate a query execution plan . In a particular embodiment because data transfers between nodes may represent a bottleneck the query execution plan may be generated such that data transfers are reduced minimized. In a particular embodiment the query execution module is part of one of the nodes . Alternately the query execution module may be part of a separate node e.g. a load balancing node .

For example the query execution module may determine that resolution of the query of involves performing operations on the Male bit string the Coffee Shop A bit string and the Purchase bit string. In the illustrated example each of the bit strings has three slices. A first slice of the Male bit string designated Maleis stored on Node A . A Maleslice and a Maleslice are stored on Node B . Coffee Shop A Coffee Shop A Coffee Shop A and Purchaseslices and are stored on Node C . Purchase and Purchaseslices and are stored on Node D .

The query execution plan identifies operations and at what nodes are to perform the operations. For example the query execution plan indicates that in a first step Node C is to perform a union OR operation between Coffee Shop Aslice and the Purchaseslice to generate an intermediate result slice Union. In parallel Node A is to transfer a copy of the Maleslice to Node C and Node B is to transfer copies of the Maleslice and the Maleslice to Node C . Node D is to transfer copies of the Purchase slice and the Purchaseslice to Node C .

In a second step Node C performs two operations in parallel ORing the Purchaseslice and the Coffee Shop Aslice to generate an intermediate result slice Union and ORing the Purchaseslice and the Coffee Shop Aslice to generate an intermediate result slice Union.

In a third step Node C performs three operations in parallel to generate three intermediate bit strings. The first intermediate bit string Resultis generated by ANDing the Unionslice with the Maleslice. The second intermediate bit string Resultis generated by ANDing the Unionslice with the Maleslice. The third intermediate bit string Resultis generated by ANDing the Unionslice with the Maleslice. In a fourth step Node C concatenates the Result Result and Resultbit strings to generate the filter string of .

In the foregoing description bit strings are described as being subdivided into slices. For example each slice may include 64 kibibits 1 kibibit 2bits 1 024 bits . In a particular embodiment slices may be further divided into chunks. For example chunks may be up to 2 kibibits in length e.g. each slice is subdivided into 32 chunks . To reduce the amount of space occupied by bit strings of a bitmap index chunks may be stored in a compressed fashion. For example illustrates a particular embodiment of compressing and storing data of a bitmap index. In particular depicts Node A of which stores the Maleslice . The Maleslice may be compressed in accordance with various compression schemes. In the illustrated compression scheme chunks that have only zeroes are not stored. Chunks that include a one are stored. A flag corresponding to each chunk is stored. If a flag has a value of zero the corresponding chunk is stored in its entirety. For example a first flag and a third flag have a value of zero indicating that corresponding first chunk and third chunk are stored at Node A . If a flag has a value of one the corresponding chunk is compressed by not being stored. For example a second flag has a value of one indicating that a corresponding second chunk includes only zeroes and is not stored. During queries the second chunk may be dynamically generated by introducing zeroes e.g. 2 048 zeroes between the first chunk and the third chunk .

While illustrates one example of a compression scheme in alternate embodiments different compression schemes may be used. Further data for the compression scheme may be stored in different places. For example the chunks and may be stored at Node A and the flags and may be stored in a different location e.g. as part of a hash table that is used to identify where slices chunks of a bit string are stored .

As another example when a first storage node receives a request to determine bicliques in a graph the first storage node may identify the bit string portions e.g. slices of a bitmap index that are stored at the first storage node and may execute the biclique find procedure based on the locally stored bit string portions. The first storage node may also forward the request to one or more other storage nodes that store other bit string portions of the bitmap index for computation of additional bicliques. Each time the biclique find procedure executing on a storage node outputs a biclique the result may be collected e.g. by the first storage node . If the combination of tiles included in the result has not previously been output in response to the initial request to determine bicliques then the result may be output and the tile combination may be saved for future reference. Thus in this example the first storage node may maintain state information indicating which tile combinations have been previously output. Tile uniqueness rather than profile uniqueness may be used because multiple storage nodes may store slices of roughly the same set of tiles albeit for different profile ID ranges. In some examples additional post processing may be performed to determine which of the result bicliques are maximal and then determine an associated set of profile IDs using a set intersection operation. Alternatively or in addition filtering and pruning on biclique results and or during execution of the biclique find procedure may be performed e.g. to restrict results to having X profiles or Y tiles . As another example a scoring metric may be applied and only biclique results having greater than a threshold score may be output.

As yet another example the top N functionality of the bitmap index may be used to restrict the search space e.g. the parameters G P and or L in the biclique find procedure to tiles that have high counts and are therefore more likely to be part of interesting bicliques. Moreover the top N functionality may be used in conjunction with custom segment functionality to target a maximal biclique search at a particular segment of interest. To illustrate females between the ages of 25 34 may be considered a valuable demographic for mobile device marketing. A segment corresponding to this group may be identified by querying the bitmap index and then the biclique find procedure may be called on the segment rather than on the bitmap index as a whole. The resulting bicliques may indicate what other attributes most strongly correlate the various members of this valuable segment which may provide insight on how to target marketing material to such users. As yet another example a sports franchise may request computation of maximal bicliques that include a season ticket holder tile to identify the various personas associated with season ticket holder. Such personas may include middle aged homeowner with family ticket reseller etc. The franchise may implement different marketing and customer engagement initiatives for different personas.

It will be appreciated that the bitmap index described herein may be dynamic in nature as additional event signals are received additional users are registered etc. Each such event corresponds to the addition or removal of an edge or a node from the graph represented by the bitmap index. Thus as the bitmap index changes the bicliques and maximal bicliques identified based on the bitmap index may also change. In a particular embodiment rather than recomputing bicliques periodically or each time the bitmap index changes the biclique find procedure of may be called on a smaller search space that is likely to be affected by newly received event signal s . As an illustrative non limiting example if an event signal results in modifying a bit string for a particular tile then the biclique find procedure may be called to 1 check if any new maximal bicliques including the tile exist and 2 check if any maximal bicliques including the tile remain maximal. In an alternative embodiment bicliques may be recomputed across the entire bitmap index periodically when the bitmap index changes or when at least a threshold number of changes to the bitmap index have occurred.

The data driven persona discovery process described herein may be preferable to using other computation technologies. For example MapReduce is a computation model in which 1 a one to one map operation is performed on all elements of a set and 2 a reduce operation is performed to generate an aggregate value based on the mapped data. MapReduce generally relies on the assumption that it is faster to move code than data. Therefore code is collocated with data elements for the map operation and then data is moved as needed for the reduce operation. Consequently MapReduce best practices involve a map more reduce less paradigm. However in MapReduce only the reduce operation is aware of other data elements the map operation is individually performed over each data element independent of any other data elements. This lack of neighbor awareness until the reduce operation along with the general preference to map more reduce less renders MapReduce ineffective to computing maximal bicliques as described herein including identifying all nodes connected to a particular node or whether a first node is connected to every node that a second node is connected to.

Referring to a particular embodiment of a method of using a bitmap index to determine bicliques is shown. In an illustrative embodiment the method may be performed by a computing device having a processor such as a computing device included in the measurement system of .

The method includes receiving a request to determine bicliques in a graph at . The graph includes a first set of nodes a second set of nodes and a set of edges where each edge in the set of edges connecting a node in the first set of nodes to a node in the second set of nodes. In an illustrative example receiving the request may include receiving a request to execute the biclique find procedure of . Such a request may be received via user input or may be generated automatically at the measurement system of .

The method also includes determining at least one biclique based on querying a bitmap index representing the graph at . In a particular embodiment the bitmap index already exists when the request to determine bicliques is received. Alternatively at least a portion of the bitmap index is generated or updated prior to determining the bicliques. The bitmap index includes a plurality of bit strings corresponding to the first set of nodes and a value stored in a particular location in each bit string indicates whether an edge connects a first node corresponding to the bit string to a second node corresponding to the particular location.

Referring to another particular embodiment of a method of using a bitmap index to determine bicliques is shown. In an illustrative embodiment the method may be performed by a computing device having a processor such as a computing device included in the measurement system of or one of the storage nodes of .

The method includes receiving at a first storage node a request to determine bicliques in a graph at . The graph includes a first set of nodes a second set of nodes and a set of edges each edge in the set of edges connecting a node in the first set of nodes to a node in the second set of nodes. The method also includes identifying one or more portions of bit strings that are stored at the first storage node and that are associated with a bitmap index at . The bitmap index includes a plurality of bit strings corresponding to the first set of nodes and a value stored in a particular location in each bit string indicates whether an edge connects a first node corresponding to the bit string to a second node corresponding to the particular location. In an illustrative non limiting example the request specifies the graph and or the bitmap index by virtue of specifying a media property e.g. website a data set etc. corresponding to the bitmap index.

The method further includes determining biclique s at the first storage node at and forwarding the request to at least a second storage node for computation of at least a second biclique at . The biclique s determined at the first storage node may be determined based on the one or more portions of bit strings stored at the first storage node. When the second storage node identifies a second biclique the first storage node may receive data identifying the second biclique at .

Continuing to the method includes determining whether a tile combination i.e. bit string combination in a biclique has previously been output for the request at . If not the method includes adding the tile combination to state information being maintained at the first node and outputting data identifying the biclique at . If the tile combination has previously been output or after outputting the biclique the method returns to and repeats until biclique computation is completed at all storage nodes operating on the request.

The bitmap index described herein may thus enable a measurement system such as the measurement system to quickly provide analysis for raw data stored in an offsite e.g. cloud based storage location. The bitmap index may represent an on the fly index of binary representations of different audience traits that can be mined to determine what set of audience members is most likely to be receptive to particular content a particular advertisement etc. Audience traits may be combined into long bit strings where each bit string represents a single trait for an entire audience. By keeping the bitmap index hot in memory ad hoc queries including computation of bicliques and maximal bicliques may be performed efficiently and with reduced latency. The described techniques may also be used with other types of systems. For example in alternate embodiments the same location in each bit string of the bitmap index may correspond to an identifier other than a user ID such as an inventory number an employee number a hospital patient identifier etc. illustrate additional scenarios in which a bitmap index may be generated and used.

In particular illustrates an alternate embodiment of a measurement system and is generally designated . A measurement system may be communicatively coupled to one or more user devices e.g. illustrative user devices and to one or more content delivery networks CDNs e.g. illustrative CDN and to properties e.g. websites and . In the properties and are illustrated by corresponding servers e.g. web servers . The measurement system may be implemented using one or more computing devices e.g. servers . For example such computing devices may include one or more processors or processing logic memories and network interfaces. The memories may include instructions executable by the processors to perform various functions described herein. The network interfaces may include wired and or wireless interfaces operable to enable communication to local area networks and or wide area networks e.g. the Internet .

The user devices may be associated with various users. For example the desktop computing device and the tablet computing device may be associated with a first user and the mobile telephone device e.g. smartphone may be associated with a second user . It should be noted that the user devices are shown for example only and are not to be considered limiting. In alternate embodiments fewer additional and or different types of user devices may be present in the system . For example a radio frequency identification RFID enabled device may be carried by a user and may transmit a signal in response to detecting that the user is visiting a particular physical location. In a particular embodiment the user devices may execute applications that are operable to access the properties and . For example the user devices may include applications developed using a mobile software development kit SDK that includes support for audience measurement functions. To illustrate when the SDK based applications interact with the properties and the applications may generate first event signals that are transmitted by the user devices to the measurement system .

The first event signals may include information identifying specific interactions by the users via the user devices e.g. what action was taken at a media property when the action was taken for how long the action was taken etc. . The user interactions may include interactions with advertisements presented by the media property and or interactions with content presented by the media property. The event signals may also include an identifier such as a browser identifier browser ID generated by the SDK. In a particular embodiment browser identifiers are unique across software installations and devices. For example a first installation of a SDK based application at the desktop computing device and a second installation of the same SDK based application at the tablet computing device may use different browser IDs even though both installations are associated with the same user .

In another particular embodiment Browser IDs may remain consistent until applications or web browsers are reset e.g. caches cookies are cleared . In some embodiments the user devices may execute applications other than browser applications such as downloadable mobile applications that generate the event signals based on user interactions with advertisements and or content presented by the applications.

The user devices may access content provided by the properties and directly or via the CDN . The CDN may provide distributed load balanced access to audio video graphics and web pages associated with the media properties and . For example the CDN may include geographically distributed web servers and media servers that serve Internet content in a load balanced fashion. The CDN may send second event signals to the measurement system . The second event signals may include information identifying interactions with media properties and browser IDs provided to the CDN by the user devices and or the properties and . For example the second event signals may include CDN logs or data from CDN logs.

The media properties and may be controlled by the same entity e.g. may be part of a federated property or by different entities. The properties and may send third event signals to the measurement system . The third event signals may include information identifying interactions with the media properties and browser IDs provided by the user devices during communication with the properties and e.g. communication via hypertext transfer protocol HTTP transport control protocol internet protocol TCP IP or other network protocols .

In a particular embodiment the third event signals may include server logs or data from server logs. Alternately or in addition the third event signals may be generated by SDK based e.g. web SDK based applications executing at the properties and such as scripts embedded into web pages hosted by the properties and .

The first event signals from the user devices and the second event signals generated by the CDN may be considered first party event signals. The third event signals from the properties and may be considered third party event signals. First party event signals may be considered more trustworthy and reliable than third party event signals because of the possibility that third party event signals could be modified by a media property owner prior to transmission to the measurement system .

In a particular embodiment the properties and may send data to the measurement system and receive data from the measurement system regarding advertisements and or content presented by the properties and . Such communication is illustrated in as advertisement content communication . For example an advertisement or software associated with the advertisement that is executing on a client device such as web server a computer a mobile phone a tablet device etc. may collect and transmit data on a per advertisement per user basis. The data may include or identify a profile of a user a duration that the user viewed the advertisement action s performed by the user with respect to the advertisement etc. As another example a content item or software associated therewith may collect and transmit data regarding user interactions with the content item.

In a particular embodiment the measurement system includes a data filtering module a data processing module a data reporting module and a query execution module . In a particular embodiment each of the modules is implemented using instructions executable by one or more processors at the measurement system .

The data filtering module may receive the event signals and . The data filtering module may check the event signals and for errors and may perform data cleanup operations when errors are found. The data filtering module may also receive and perform cleanup operations on advertisement measurement data and content measurement data received from the properties and and from applications executing on the user devices . In a particular embodiment the data filtering module may implement various application programming interfaces APIs for event signal collection and inspection. The data filtering module may store authenticated verified event signals in a database event cache archive and or cloud storage . In a particular embodiment the measurement system includes or has access to a brand database that tracks brands. For example raw data corresponding to the brand database and other collected data may be stored in the cloud storage . Signals received from the properties and and from applications executing the user devices may identify a brand that matches one of the brands in the brand database. The measurement system may thus track advertisements content for various brands across multiple properties.

The data processing module may operate as described with reference to the data processing module of . Alternately or in addition the data processing module may associate received event signals and interactions represented thereby with user profiles of users. For example when an event signal having a particular browser ID is a social networking registration event e.g. when a user logs into a website using a Facebook account a Twitter account a LinkedIn account or some other social networking account the data processing module may retrieve a corresponding social networking profile or other user profile data from third party data sources . Facebook is a registered trademark of Facebook Inc. of Menlo Park Calif. Twitter is a registered trademark of Twitter Inc. of San Francisco Calif. LinkedIn is a registered trademark of LinkedIn Corp. of Mountain View Calif.

It will be appreciated that interactions that were previously associated only with the particular browser ID i.e. impersonal alphanumeric data may be associated with an actual person e.g. John Smith after retrieval of the social networking profile or user profile. Associating interactions with individuals may enable qualitative analysis of the audiences of media properties. For example if John Smith is a fan of a particular sports team the measurement system may indicate that at least one member of the audience of the first property or the second property is a fan of the particular sports team. When a large percentage of a media property s audience shares a particular characteristic or interest the media property may use such information in selecting and or generating advertising or content. User profiles e.g. a profile of the user John Smith and audience profiles e.g. profiles for the media properties associated with the properties and may be stored in the cloud storage and or in another database. An audience profile for a particular media property may be generated by aggregating the user profiles of the individual users e.g. including John Smith that interacted with the particular media property.

Audience profiles may be generated using as few as one or two user profiles although any number of user profiles may be aggregated. In a particular embodiment audience profiles may be updated periodically e.g. nightly weekly monthly etc. in response to receiving updated data for one or more users in the audience in response to receiving a request for audience profile data or any combination thereof. Audience profiles may similarly be generated for audiences of a particular mobile application based on signals generated by installations of the mobile application on various user devices.

The data reporting module may generate various interfaces. The data reporting module may also support an application programming interface API that enables external devices to view and analyze data collected and stored by the measurement system . In a particular embodiment the data reporting module is configured to segment the data.

As used herein a segment is based on a group of people e.g. an audience or a subset thereof . As further described herein a digital genome may be determined for each segment. Examples of segments include but are not limited to brand affinity segments also called brand segments demographic segments geographic segments social activity segments employer segments educational institution segments professional group segments industry category of employer segments brand affinity category segments professional skills segments job title segments and behavioral segments. In a particular embodiment behavioral segments are defined by a client e.g. property owner or publisher or by the measurement system and represent actions taken on a client s property.

Additional examples of segments include segments based on an advertisement an advertisement campaign an advertisement placement an advertisement context a content item a content context content placement a platform e.g. desktop laptop computer vs. mobile phone vs. tablet computer etc. Segments may be used to understand or evaluate characteristics of an audience craft a content strategy generate advertising leads create advertising pitches and respond to inbound advertising requests. Segments may also be used to acquire additional audience members receive information from advertisements content items and send information to advertisements content items. In a particular embodiment the measurement system may be operable to define new segments based on performing logical operations e.g. logical OR operations and logical AND operations .

The measurement system may also include a bitmap index e.g. the bitmap index of the bitmap index of and or the bitmap index of . The bitmap index may store bit strings corresponding to at least a subset of the raw data stored in the cloud storage . In one example a different bitmap index is maintained for each property . The bitmap index for a particular property may include for each audience member of the property data regarding a demographic attribute of the audience member a brand affinity of the audience member and or behaviors e.g. interactions with the media property of the audience member. The same location in each bit string of the bitmap index may correspond to the same user.

The data processing module may also be configured to upon receiving an event signal parse the event signal to identify what user and media property the event signal corresponds to. The data processing module may store data corresponding to the event signal in one or more databases e.g. the cloud storage a user profile database etc. . The data processing module may also store indexing data corresponding to the event signal in the bitmap index for the identified media property. If the user is a new audience member for the media property the data processing module may assign a new ID to the user. Event signals may be processed as described above with reference to .

The query execution module may operate as described with reference to the query execution module of and or the query execution module of . For example the query execution module may receive a query and generate a query execution plan that parallelizes execution and reduces minimizes data transfers between storage nodes during query execution.

During operation the users may interact with the media properties and and with applications executing on the user devices . In response to the interactions the measurement system may receive the event signals and or . Each event signal may include a unique identifier such as a browser ID and or an audience member ID. If the user is a new audience member the data processing module may create a user profile. Data for the user profile may be stored in the cloud storage and or the bitmap index . In a particular embodiment data for the user profile may be retrieved from the third party data sources .

For example the data processing module may retrieve and store data from one or more social network profiles of the user. The data may include demographic information associated with the user e.g. a name an age a geographic location a marital family status a homeowner status etc. social information associated with the user e.g. social networking activity of the user social networking friends likes interests of the user etc. and other types of data. The data processing module may also collect and store data associated with advertisements and content served by the properties and and by applications executing on the user devices . In a particular embodiment the measurement system is further configured to receive offline data from external data sources. For example the measurement system may receive data regarding transactions e.g. purchases made by an audience and may use the transaction data to generate additional signals that contribute to the digital genome of an audience brand property etc. Another example of offline data may be a data dump of data collected by an RFID enabled device or an RFID detector. Offline data may be stored in one or more computer readable files that are provided to the measurement system . In a particular embodiment offline data can include previously collected data regarding users or audience members e.g. names addresses etc. .

The data reporting module may report data collected by the measurement system . For example the data reporting module may generate reports based on an audience profile of a media property or application where the audience profile is based on aggregating user profiles of users that interacted with the media property or application . To illustrate the data reporting module may generate an interface indicating demographic attributes of the audience as a whole e.g. a percentage of audience members that are male or female percentages of audience members in various age brackets percentages of audience members in various income bracket most common audience member cities states of residence etc. . The interface may also indicate social attributes of the audience as a whole e.g. the most popular movies sports teams etc. amongst members of the audience . Audience profiles may also be segmented and or aggregated with other audience profiles as further described herein. Audience profiles may further be segmented based on advertisement advertisement campaign brand content item etc. Audience profiles may also be constructed by combining segments as further described herein.

In a particular embodiment the system may also receive event signals based on measurements e.g. hardware measurements made at a device. For example an event signal from the tablet computing device or the mobile telephone device may include data associated with a hardware measurement at the tablet computing device or the mobile telephone device such as an accelerometer or gyroscope measurement indicating an orientation a tilt a movement direction and or a movement velocity of the tablet computing device or the mobile telephone device . As another example the system may receive a signal in response to an RFID device detecting that a user is visiting a particular physical location. The system of may also link interactions with user profiles of users. This may provide information of how many viewers and how long the viewers watched a particular video e.g. as in direct response measurement systems and also who watched the particular video e.g. demographic social and behavioral attributes of the viewers .

The system of may thus enable audience measurement and analysis based on data e.g. event signals received from various sources. Further the system of may enable real time or near real time execution of queries on collected data such as execution of top N queries using the bitmap index .

The system includes or has access to an authentication provider third party data sources an audience web application a first framework a second framework a database an interrogator a data store and a bitmap index . In an illustrative embodiment the third party data sources are the third party data sources of the event processing tier and the interrogator correspond to the data processing module of and the bitmap index is the bitmap index of .

The data collection tier includes a content management system CMS cloud storage content delivery networks client browsers and client servers . The data collection tier may further include an application programming interface API . The API includes a load balancer capture servers and cloud storage .

The event processing tier includes a job queues module an anonymous buffer and an event bundle buffer . The job queues module includes an authentication token handler an event dispatch and an event bundle handler . In alternate embodiments the job queues module may include more fewer and or different handlers than illustrated in .

The monitoring tier includes an internal monitoring module a ping monitor and a notifications module . The internal monitoring module includes a penetration monitor a performance analysis module a system monitor and an alert rules module .

During operation the content management system may be used to generate a client specific script e.g. webscript for various clients e.g. media properties . The client specific script may be stored in the cloud storage and replicated to the content delivery networks . As audience members register and interact with a media property the content delivery networks may deliver the client specific script along with property content to the client browsers . Based on the client specific script the client browsers may generate tags e.g. a tag corresponding to a particular user activity such as watching a video or tokens e.g. a social networking registration token . The tags or tokens may be sent to the load balancer . The client servers may also generate tags or tokens to send to the load balancer based on user registrations and user activity at media properties. The tags or tokens from the client servers may be authenticated by the authentication provider .

The load balancer may send the tags or tokens to the capture servers based on a load balancing algorithm. The capture servers may generate event data e.g. event signals based on the tags or tokens. The capture servers may store the event data in event logs in the cloud storage and send the event data to the job queues module .

The job queues module may distribute the event data to different event handler s based on the type of the event data. For example event data including an authentication token may be sent to the authentication token handler . In addition event data requiring additional information from social media sources may be sent to the authentication token handler . The handler may perform asynchronous event collection operations based on the received event data. For example when a new user registers with a media property using a social networking profile a token may be provided by the data collection tier to the authentication token handler . The handler may use the token to retrieve demographic and brand affinity data for the user from the user s social networking profile.

Event signals may also be sent to the event dispatch which determines whether the event signals corresponds to known or unknown users. When event data corresponds to an unknown user the event dispatch buffers the event data in the anonymous buffer . After a period of time e.g. three days event data from the anonymous buffer may be sent to the job queues module to be processed again.

When event data corresponds to a known user e.g. a user that has already been assigned a user ID the event dispatch may send the event data to the event bundles buffer . The event bundle handler may retrieve event data stored in the event bundles buffer every bundling period e.g. one hour . The event bundle handler may bundle event data received each bundling period into an event bundle that is sent to the interrogator .

The interrogator may parse the event bundle and update the data store the SQL database and or the bitmap index . For example the interrogator may perform bitmap index generation and update operations as described herein. In a particular embodiment the database corresponds to a profiles database that is accessible the first framework to the audience web application . For example the first framework may be a database driven framework that is operable to dynamically generate webpages based on data in the database . The audience web application may be operable to generate various graphical user interfaces to analyze the data collected by the system . The bitmap index may be accessible to the audience web application via the second framework . In one example the second framework supports representational state transfer REST based data access and webpage navigation. Although not shown in particular embodiments the data store may also be accessible to the audience web application .

The monitoring tier may monitor the various components of the system during operation to detect errors bottlenecks network intrusions and other issues. For example the penetration monitor may collect data indicating unauthorized access to or from the capture servers and the first framework . The penetration monitor may provide the data to the alert rules module . Similarly the system monitor may collect performance data from the capture servers from the second framework and from the data store . The system monitor may provide the performance data to the performance analysis module which may analyze the data and send the analyzed data to the alert rules module . The alert rules module may compare received data to alert rules and based on the comparison send an alert to the notifications module . For example the alert rules module may determine that an intruder has accessed components of the system or that the system is not operating at a desired level of efficiency and may send an alert to the notifications module .

The notifications module may also receive alerts from the ping monitor . The ping monitor may monitor the load balancer and the audience web application and collect data regarding uptime downtime and performance and provide alerts to the notification module .

The notification module may send notifications e.g. via short message service SMS e mail instant messaging paging etc. to one or more technical support staff members to enable timely response in the event of errors performance bottlenecks network intrusion etc.

In accordance with various embodiments of the present disclosure the methods functions and modules described herein may be implemented by software programs executable by a computer system. Further in an exemplary embodiment implementations can include distributed processing component object distributed processing and parallel processing. Alternatively virtual computer system processing can be constructed to implement one or more of the methods or functionality as described herein.

Particular embodiments can be implemented using a computer system executing a set of instructions that cause the computer system to perform any one or more of the methods or computer based functions disclosed herein. A computer system may include a laptop computer a desktop computer a mobile phone a tablet computer a set top box a media player or any combination thereof. The computer system may be connected e.g. using a network to other computer systems or peripheral devices. For example the computer system or components thereof can include or be included within any one or more devices modules and or components illustrated in . In a networked deployment the computer system may operate in the capacity of a server or as a client user computer in a server client user network environment or as a peer computer system in a peer to peer or distributed network environment. The term system can include any collection of systems or sub systems that individually or jointly execute a set or multiple sets of instructions to perform one or more computer functions.

In a particular embodiment the instructions can be embodied in a computer readable or a processor readable device. The terms computer readable device and processor readable device include a single storage device or multiple storage devices such as a centralized or distributed database and or associated caches and servers that store one or more sets of instructions. The terms computer readable device and processor readable device also include any device that is capable of storing a set of instructions for execution by a processor or that cause a computer system to perform any one or more of the methods or operations disclosed herein. For example a computer readable or processor readable device or storage device may include random access memory RAM flash memory read only memory ROM programmable read only memory PROM erasable programmable read only memory EPROM electrically erasable programmable read only memory EEPROM registers a hard disk a removable disk a disc based memory e.g. compact disc read only memory CD ROM or any other form of storage device. A computer readable or processor readable device is not a signal.

The illustrations of the embodiments described herein are intended to provide a general understanding of the structure of the various embodiments. The illustrations are not intended to serve as a complete description of all of the elements and features of apparatus and systems that utilize the structures or methods described herein. Many other embodiments may be apparent to those of skill in the art upon reviewing the disclosure. Other embodiments may be utilized and derived from the disclosure such that structural and logical substitutions and changes may be made without departing from the scope of the disclosure. Accordingly the disclosure and the figures are to be regarded as illustrative rather than restrictive.

Although specific embodiments have been illustrated and described herein it should be appreciated that any subsequent arrangement designed to achieve the same or similar purpose may be substituted for the specific embodiments shown. This disclosure is intended to cover any and all subsequent adaptations or variations of various embodiments. Combinations of the above embodiments and other embodiments not specifically described herein will be apparent to those of skill in the art upon reviewing the description.

The Abstract of the Disclosure is submitted with the understanding that it will not be used to interpret or limit the scope or meaning of the claims. In addition in the foregoing Detailed Description various features may be grouped together or described in a single embodiment for the purpose of streamlining the disclosure. This disclosure is not to be interpreted as reflecting an intention that the claimed embodiments require more features than are expressly recited in each claim. Rather as the following claims reflect inventive subject matter may be directed to less than all of the features of any of the disclosed embodiments.

The above disclosed subject matter is to be considered illustrative and not restrictive and the appended claims are intended to cover all such modifications enhancements and other embodiments which fall within the true scope of the present disclosure. Thus to the maximum extent allowed by law the scope of the present disclosure is to be determined by the broadest permissible interpretation of the following claims and their equivalents and shall not be restricted or limited by the foregoing detailed description.

