---

title: Efficient method data recording
abstract: According to one general aspect, a method may include monitoring the execution of at least a portion of a software application. The method may also include collecting subroutine call information regarding a plurality of subroutine calls included by the portion of the software application, wherein one or more of the subroutine calls is selected for detailed data recording. The method may further include pruning, as the software application is being executed, a subroutine call tree to include only the subroutine calls selected for detailed data recording and one or more parent subroutine calls of each subroutine calls selected for detailed data recording.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09483391&OS=09483391&RS=09483391
owner: Identify Software Ltd.
number: 09483391
owner_city: Petach Tikva
owner_country: US
publication_date: 20160121
---
This application is a continuation of and claims priority under 35 U.S.C. 120 to U.S. application Ser. No. 13 630 784 filed on Sep. 28 2012 and entitled EFFICIENT METHOD DATA RECORDING the contents of which are hereby incorporated by reference.

This description relates to software analysis and more specifically to performance and function monitoring of software applications.

Generally software application diagnostics tools for production or operations environments provide initial identification of problems. Often when identified problems are escalated to an application development team for further analysis and in order to be fixed. Typically when a problem is escalated to developers it may be very helpful to have to be provided focused and detailed recorded information that is specifically relevant to the problem. Such information may shorten the time is takes to find and fix the problem s root cause. Often such details include the amount of time spent in a given method or subroutine the arguments received by the method or subroutine the value or data if any returned from the method of subroutine any exceptions or errors thrown or generated by the method or subroutine any method or subroutine specific data e.g. internal variables global variables etc. or application specific information e.g. Structured Query Language SQL queries related to a specific invocation of a database query hypertext transport protocol HTPP header information for networking subroutines etc. etc.

Often in order to provide detailed data as described above data must be collected during the method or subroutine execution on the user thread thus causing considerable overhead on the server or executing computer during subroutine execution. Generally it is desirable for any processes running on server s request handling threads to be as efficient as possible. This is often highly important in production environments where latency increase is a real problem. Specifically collection of method data e.g. method arguments return types thrown exceptions entry exit times etc. may involve invocation of expensive procedures.

Further it is often necessary to alter the source code of a subroutine or method prior to compilation in order to allow for collection of the data described above. In addition due to the desire to reduce latency or more generally the use of system resources e.g. processor cycles memory usage network bandwidth etc. any processing of the collected subroutine data is often done after the execution of the subroutine or software application as a whole.

According to one general aspect a method may include monitoring the execution or at least a portion of a software application. The method may also include collecting subroutine call information regarding a plurality of subroutine calls included by the portion of the software application wherein one or more of the subroutine calls is selected for detailed data recording. The method may further include pruning as the software application is being executed a subroutine call tree to include only the subroutine calls selected for detailed data recording and one or more parent subroutine calls of each subroutine calls selected for detailed data recording.

According to another general aspect an apparatus may include a processor and a memory. The processor may be configured to execute a software application monitor the execution or at least a portion of the software application and collect subroutine call information regarding a plurality of subroutine calls included by the portion of the software application wherein one or more of the subroutine calls is selected for detailed data recording. The memory may be configured to store the subroutine call information that was collected by the processor. The processor may be further configured to prune as the software application is being executed a subroutine call tree to include only the subroutine calls selected for detailed data recording and one or more parent subroutine calls of each subroutine calls selected for detailed data recording.

According to another general aspect a computer program product for aiding software analysis may be tangibly and non transitorily embodied on a computer readable medium. The computer program product may include executable code that when executed is configured to cause an apparatus to monitor the execution or at least a portion of a software application collect subroutine call information regarding a plurality of subroutine calls included by the portion of the software application wherein one or more of the subroutine calls is selected for detailed data recording and prune as the software application is being executed a subroutine call tree to include only the subroutine calls selected for detailed data recording and one or more parent subroutine calls of each subroutine calls selected for detailed data recording.

The details of one or more implementations are set forth in the accompanying drawings and the description below. Other features will be apparent from the description and drawings and from the claims.

A system and or method for software analysis substantially as shown in and or described in connection with at least one of the figures as set forth more completely in the claims.

In various embodiments the server device may include a computing device such as for example as laptops desktops workstations personal digital assistants servers blade servers mainframes and other appropriate computers etc. or a virtual machine or virtual computing device thereof. In various embodiments the server device may be used by a user not shown . In various embodiments the server device may include a processor configured to execute one or more machine executable instructions or pieces of software firmware or a combination thereof. The server device may include in some embodiments a memory configured to store one or more pieces of data either temporarily permanently semi permanently or a combination thereof. Further the memory may include volatile memory non volatile memory or a combination thereof. In various embodiments the server device may include a storage medium configured to store data in a semi permanent or substantially permanent form. In various embodiments the storage medium may be included by the memory .

In various embodiments the server device may include one or more network interfaces configured to allow the placement device to be part of and communicate via a communications network . Examples of a Wi Fi protocol may include but are not limited to Institute of Electrical and Electronics Engineers IEEE 802.11g IEEE 802.11n etc. Examples of a cellular protocol may include but are not limited to IEEE 802.16m a.k.a. Wireless MAN Metropolitan Area Network Advanced Long Term Evolution LTE Advanced Enhanced Data rates for GSM Global System for Mobile Communications Evolution EDGE Evolved High Speed Packet Access HSPA etc. Examples of a wired protocol may include but are not limited to IEEE 802.3 a.k.a. Ethernet Fibre Channel Power Line communication e.g. HomePlug IEEE 1901 etc. etc. It is understood that the above are merely a few illustrative examples to which the disclosed subject matter is not limited.

In various embodiments the server device may include one or more other hardware components e.g. a display or monitor a keyboard a mouse a camera a fingerprint reader a video processor etc. . It is understood that the above are merely a few illustrative examples to which the disclosed subject matter is not limited.

In various embodiments the server device may include an operating system OS configured to provide one or more services to an application and manage or act as an intermediary between the application and the various hardware components e.g. the processor a network interface etc. of the placement device . In such an embodiment the server device may include one or more native applications which may be installed locally e.g. within the storage medium etc. and configured to be executed directly by the processor and directly interact with the OS . In such an embodiment the native applications may include pre compiled machine executable code. In some embodiments the native applications may include a script interpreter e.g. C shell csh AppleScript AutoHotkey etc. or a virtual execution machine VM e.g. the Java Virtual Machine the Microsoft Common Language Runtime etc. that are configured to translate source or object code into executable code which is then executed by the processor .

In one embodiment the OS may allow the application access to various system resources e.g. access to the storage medium access to a camera access to a location sensor draw a user interface UI on a display monitor etc. to perform various application functions e.g. contact a web site take a picture read write a file etc. .

In various embodiments the application may include one or more subroutines . In this context a subroutine includes an independent module or portion of software programming instructions. In many embodiments a subroutine performs a specific task or function and may be relatively independent from the application as a whole. In various embodiments what is referred to as a subroutine may also be referred to as a function method subprogram procedure or routine by those skilled in the art.

Generally a subroutine receives as input various variables or data elements from a calling portion of the application which may be another subroutine. In this context such input data elements are referred to as arguments or parameters . Often but not always a subroutine returns or provides as output one or more data elements. In this context such output data elements are referred to as return value s . In some embodiments a subroutine may include variables or data elements that are considered local or are generally not accessible by another portion of the application .

In this context a subroutine is called when another portion of the application instructs the processor or other executing component e.g. virtual machine etc. to jump to the subroutine or otherwise begin to execute instructions included by the subroutine. In such an embodiment each separate call may include or provide to the subroutine different arguments and result in different return values. In various embodiments multiple calls to the same subroutine may be active or executed substantially simultaneously e.g. in the case of multi threading multi tasking pipelining etc. .

In this context a subroutine is entered when the subroutine is first called and the arguments are provided to the subroutine . Conversely in this context a subroutine is exited when the instructions of the subroutine finish executing. When a subroutine exits is often when a return value is provided back to the calling portion of the application . In some embodiments a return value may not be provided directly back to the calling portion of the application but may be output to another portion of the application or a data structure e.g. a database not shown an array stored in memory and used by the application etc. .

In various embodiments the server device may include a monitoring engine configured to monitor the execution or at least a portion of application . In various embodiments the selection of which portions of the application to monitor may be predefined e.g. via list provided by a user etc. . In another embodiment the selection of which portions of the application to monitor may be dynamically selected based upon a set of predefined rules or criteria e.g. an error of the application during the current or prior execution a number of users accessing the application system resource of a portion of the application etc. . In some embodiments the monitoring engine may be configured to monitor the entire application . It is understood that the above are merely a few illustrative examples to which the disclosed subject matter is not limited.

In various embodiments the monitoring engine may be configured to monitor or provide data that will eventually be turned into a subroutine call tree or a data structure that includes information regarding various subroutines or portions of the application s execution for further analysis by a user or software developer . In some embodiments this subroutine call tree or a data structure may be transmitted or provided to a client computing device that is configured to be controlled by a user .

In various embodiments the system may include a client computing device . In various embodiments the client device may include a computing device such as for example as laptops desktops workstations personal digital assistants and other appropriate computers etc. or a virtual machine or virtual computing device thereof. In various embodiments the client device may include hardware and or software similar to or analogous to that described in reference to the server e.g. processor memory OS etc. . In various embodiments the client device may include an application e.g. software analysis tool software development integrated design environment etc. configured to make use of the subroutine call tree . In such an embodiment the user may review the subroutine call tree and based on the data included by the subroutine call tree make changes to the application or the source code that results in the application . It is understood that the above is merely one illustrative example to which the disclosed subject matter is not limited.

In the illustrated embodiment the subroutine call executes for 1344 milliseconds ms . The other subroutines execute for 0 ms or less than 1 ms depending on the granularity of the monitoring tool . As such a software developer may not be interested in the information included for the 0 ms execution subroutines subroutines and but may be very interested in subroutine call and any subroutines that called either directly or indirectly the subroutine call subroutine calls and . In such an embodiment the information regarding subroutine calls and may be uninteresting to the software developer and their monitoring may reduce the performance of the computing device that executed them.

In various embodiments the subroutine call tree may include information pertaining to the subroutine calls included in the subroutine call tree . In various embodiments the subroutine information may include one or more of the following the subroutine name a class name or name of a data structure that includes the subroutine the input arguments or variables and or their values any return values a recording rule that caused the server device to record or include the subroutine in the subroutine call tree a subroutine descriptor or signature that identifies the subroutine to the compiler or execution device e.g. processor virtual execution machine etc. a subroutine call identifier ID that identifies the subroutine call to the monitoring engine or other device that generated the subroutine call tree and or any extra or custom information that a user or other entity designated as desirable for capture. It is understood that the above are merely a few illustrative examples to which the disclosed subject matter is not limited.

Returning to in various embodiments subroutine call trees e.g. subroutine call tree may be very large with only small part that is actually interesting for problem root cause analysis or other purposes. In some embodiments many if not most subroutine call trees may not be deemed not interesting at all i.e. the subroutine call tree may not contain any interesting branches at all . In various embodiments the server device may be configured to identify interesting branches in the tree already at runtime and record data for those. In the illustrated embodiment the server device may be configured to prune the subroutine call tree or the data from which the subroutine call tree is derived such that only to the interesting branches of the subroutine call tree remain. In such an embodiment the server device may be configured to disregard these uninteresting branches and in some embodiments entire uninteresting subroutine call trees. In such an embodiment by being selective about which subroutine calls are recorded or added to the subroutine call tree system resources e.g. time processing cycles memory usage etc. may be saved.

In various embodiments the server device may be configured to identify interesting branches in the tree already at runtime and record data for those. In various embodiments what the server device selects as interesting subroutine calls may be based upon predefined criteria or rules a predefined static list of subroutine calls or points of code execution a dynamic triggering event e.g. exceeding a threshold between the entry and exit times throwing an exception a subroutine returning a null or other value an error condition etc. . In some embodiments a recording rule would indicate why a subroutine or subroutine call is to be recorded and include information required for subroutine or subroutine type e.g. based on object class inheritance subroutine hierarchy etc. specific data or information recording. It is understood that the above are merely a few illustrative examples to which the disclosed subject matter is not limited.

In such an embodiment the server device may be configured to filter out or avoid a vast majority of recorded data. Further as described below the in the illustrated embodiment may be configured to perform this filtering or pruning substantially at runtime or as the application or the monitored subroutines are being executed.

As described above in various embodiments the monitoring engine may be configured to collect various pieces of data regarding the selected subroutines . In some embodiments subroutine information may include but is not limited to one or more of the following the subroutine name a class name or name of a data structure that includes the subroutine the input arguments or variables and or their values any return values a recording rule that caused the server device to record or include the subroutine in the subroutine call tree a subroutine descriptor or signature that identifies the subroutine to the compiler or execution device e.g. processor virtual execution machine etc. a subroutine call identifier ID that identifies the subroutine call to the monitoring engine or other device that generated the subroutine call tree and or any extra or custom information that a user or other entity designated as desirable for capture. It is understood that the above are merely a few illustrative examples to which the disclosed subject matter is not limited.

In various embodiments each subroutine or call of a subroutine may be assigned or associated with a substantially unique subroutine call identifier ID . In various embodiments the subroutine call identifier may be universally unique. In another embodiment the subroutine call identifier may only be sufficiently unique to reduce the probability of an inadvertent duplication or conflict of identifiers below a certain threshold. It is understood that the above are merely a few illustrative examples to which the disclosed subject matter is not limited. In various embodiments whenever a subroutine or subroutine call is identified as interesting for recording the subroutine call ID may be allocated with it and this subroutine call ID may be mapped to the corresponding rule that selected or marked the subroutine or subroutine call as interesting .

In various embodiments the server device may include a subroutine data registry or database DB configured to store recorded or collected subroutine information . In various embodiments a fast retrieve mapping may exist between each subroutine call ID and any data or information collected or recorded. For example such data may include subroutine and class names as well as corresponding Recording Rule as described above.

In some embodiments the monitoring engine may be configured to alter the selected subroutines or inject code into the selected subroutines in order to collect subroutine call information . In such an embodiment the code injection may occur at runtime or as the subroutine is about to be executed or being executed. In various embodiments a virtual execution machine may be configured to support such code injection. In another embodiment the code injection may occur without the aid of the processing or executing device e.g. processor virtual machine etc. .

In various embodiments the injected code may be injected into the body of the subroutine or into the subroutine itself. In another embodiment the injected code may be injected into the calling subroutine or portion of the application e.g. before and or after the call of the selected subroutine . In yet another embodiment a mixture of the two schemes may be employed.

In the illustrated embodiment the subroutine doSomething has had four pieces of code and injected into it. In some embodiments the injected code which in the illustrated embodiment are themselves subroutine calls may fall into two broad categories injected subroutines that act when the monitored subroutine is first called or entered e.g. code and injected subroutines that act when the monitored subroutine is terminated or exited e.g. code or . It is understood that the above is merely one illustrative example to which the disclosed subject matter is not limited.

In one embodiment subroutine call may include a recordEntry or subroutine entry injected code portion. In such an embodiment the subroutine entry injected code may be configured to cause a subroutine entry array element and stack element to be created as described below in reference to subroutine array and subroutine stack . In the illustrated embodiment the subroutine entry injected code may not accept as input any of the input parameters of the selected subroutine doSomething . In another embodiment such input parameters may be input to the subroutine entry injected code. In such an embodiment this may be useful if the input arguments are likely to change before the subroutine exits or returns a value e.g. when input arguments are passed by reference or as a memory pointer or address to a data structure etc. . It is understood that the above are merely a few illustrative examples to which the disclosed subject matter is not limited.

In various embodiments the subroutine calls and may include a recordReturn or subroutine exit injected code portion. In such an embodiment the subroutine exit injected code may call a subroutine just before the selected subroutine doSomething exits or returns a value. In the illustrated embodiment the selected subroutine may return one of two values s or s and therefore the two subroutine calls and may be injected into the code . In the illustrated embodiment the code may be restructured such that temporary variables are explicitly used instead of the implicit variables that were used in the un injected source code . It is understood that the above is merely one illustrative example to which the disclosed subject matter is not limited.

In the illustrated embodiment each of the subroutine calls and may accept as input the identifier associated with the selected subroutine e.g. the value to be returned form the selected subroutine e.g. First or Second as the variables s or s respectively and the input arguments to the selected subroutine e.g. the string s . These values and any other information collected by the subroutine exit injected code e.g. exit time etc. may be stored as part of the subroutine call information as described above. Also as described above in various embodiments the subroutine entry injected code may return the input arguments of the selected subroutine. In yet another embodiment both the subroutine entry and exit injected code portions may report the input arguments of the selected subroutine. In such an embodiment a comparison of any changes made to the input arguments either by the selected subroutine or another portion of the application during the execution of the selected subroutine may be collected. It is understood that the above are merely a few illustrative examples to which the disclosed subject matter is not limited.

In various embodiments a subroutine call may include a recordThorwn or subroutine exit by error injected code portion. In such an embodiment the subroutine exit by error injected code portion may be similar to the subroutine exit injected code portions and but may called when the selected subroutine encounters an error or exception or exits abnormally. In such an embodiment in addition to the ID of the selected subroutine e.g. and in various embodiments the input arguments of the selected subroutine e.g. s the subroutine exit by error injected code portion may also collect information regarding the exception or error that caused the selected subroutine to exit e.g. the object t . It is understood that the above are merely a few illustrative examples to which the disclosed subject matter is not limited.

Returning to in various embodiments once the subroutine call information has been collected via the injected code it may be stored in the subroutine data database . As described above in various embodiments the monitoring engine may collect subroutine call information regarding every subroutine call. However in a preferred embodiment the monitoring engine may only collect subroutine call information for subroutine calls that are selected as being interesting or being associated with an interesting subroutine call.

In one embodiment the server device may include a pruning engine . In such an embodiment the pruning engine may be configured to manage the collection of the subroutine call information and reducing the amount of subroutine call information collected and the amount of system resources e.g. processor cycles memory usage etc. used while collecting the subroutine call information .

In the illustrated embodiment the pruning engine may include or manage a subroutine call array and or a subroutine call stack or data structure based on the concept of last in first out LIFO . In some embodiments other forms of data structures may be employed. It is understood that the above are merely a few illustrative examples to which the disclosed subject matter is not limited.

In various embodiments an array and stack may be created and associated with a particular execution thread or instance of a portion of the application . In the embodiment in which the application provides a service or responds to requests from another computing device not shown an array and stack may be created and associated with each server or application request.

In various embodiments the subroutine call array and subroutine stack may include information that represents the hierarchy and call structure of a portion of the subroutines calls made during the execution of the application . In some embodiments the subroutine call array and subroutine stack may be updated added to and pruned during the execution of the application . In such an embodiment as a subroutine call or entry is made a corresponding subroutine call entry element may be added or made to the subroutine call array and or subroutine stack . Likewise as a subroutine call exits either the corresponding subroutine call entry element may be removed or pruned from the subroutine call array and or subroutine stack or a corresponding subroutine call exit element may be added or made to the subroutine call array and or subroutine stack . In various embodiments the decision to prune or to add a subroutine call element may be based upon whether or not the subroutine call was selected or deemed interesting or was a parent subroutine call of an interesting or selected subroutine call. An embodiment of this process is described in more detail below in reference to 

In various embodiments the server device may include a formatting engine . In such an embodiment the formatting engine may be configured to convert the subroutine call array into a pruned subroutine call tree or other data structure that may be employed for software analysis of the application . An embodiment of this process is described in more detail below in reference to .

In various embodiments graph may illustrate a number of subroutine calls made while executing an application. In various embodiments the array may be configured to store subroutine call entry exit elements that represent subroutine call entry or exit points. In some embodiments the stack may be configured to temporarily store subroutine call information. As described above in various embodiments other data structures may be used and it is understood that the above are merely illustrative examples to which the disclosed subject matter is not limited.

In the illustrated embodiment the array may include a data index . In some embodiments the data index may be configured to points to the next memory space within the array to store data or subroutine call elements. In the illustrated embodiment the array may include a persist index . In some embodiments the persist index may be configured to mark the last index for stored data or subroutine call element that is to be persisted or not pruned.

In the illustrated embodiment the subroutine may be called or entered illustrated by the arrow . In such an embodiment in response to the entry or calling of the subroutine a timestamp or start time associated with the subroutine call may be created. In various embodiments a subroutine call entry element may be added to the array at the next available position. In such an embodiment as a result of the added subroutine call element the data index may be incremented or moved by one.

In some embodiments the creation of an object or memory structure for each subroutine call entry element which may be made for each subroutine call as the application executes may be considered expensive in terms of system resources e.g. memory usage computation time etc. . This may be true especially for applications that include thousands of subroutine calls. Therefore in various embodiments in order to at least partially reduce the system resource usage a single subroutine call entry element may be used or employed for every subroutine call entry element added to the array . In various embodiments the subroutine call entry element may include a null or empty element. In another embodiment the subroutine call entry element may include a pointer to a shared or generic subroutine call entry element such that the system resource costs of creating a new object or data structure for the subroutine call entry element . It is understood that the above is merely one illustrative example to which the disclosed subject matter is not limited.

In various embodiments once the subroutine call entry element has been added to the array a stack element may be placed on the stack . In some embodiments the stack element may include an entry time associated with the subroutine call and the data index associated with the subroutine call s entry element . In various embodiments the stack may be configured to temporarily store subroutine call information e.g. the entry time etc. .

In some embodiments if the subroutine call entry element is null or does not include subroutine call information the stack may be used to store the subroutine call information that would normally be stored in the subroutine call entry element . In such an embodiment the stack may be pre allocated in memory. As a result there may be very little system resource usage in storing or removing data from the stack . In such an embodiment it may be preferable to temporarily store subroutine call information within the stack . It is understood that the above is merely one illustrative example to which the disclosed subject matter is not limited.

In the illustrated embodiment upon the exit of subroutine the recording structures or subroutine call information e.g. input arguments returned value etc. may be collected. In various embodiments this may be accomplished via the code injected into the subroutine .

In such an embodiment a timestamp associated the exit time of the subroutine may be recorded. In various embodiments the stack element may be popped off or retrieved from the stack . In some embodiments the entry time may be compared against the exit time in order to determine if the duration of the subroutine call exceeds a threshold value and therefore is judged to be interesting. Although it is understood that the above is merely one illustrative example to which the disclosed subject matter is not limited.

In the illustrated embodiment the call of subroutine is judged to not be interesting and the subroutine call entry element is not selected for preservation. In such an embodiment the subroutine call entry element may be removed from the array and the data index decremented.

As described above the exit time for the exit of subroutine may be recorded and compared against the entry time stored in the stack . In the illustrated embodiment the processing time involved in the call to subroutine may have exceeded a threshold value and the subroutine call may be marked as interesting . In various embodiments other reasons a subroutine call may be considered interesting may include the subroutine exiting abnormally e.g. throwing an exception etc. the subroutine call fulfilling a recording rule or predefined set of criteria if the subroutine call is a parent subroutine call to another that was selected as being interesting etc. It is understood that the above are merely a few illustrative examples to which the disclosed subject matter is not limited.

In such an embodiment a subroutine call exit element may be added to the array . In various embodiments the subroutine call exit element may include the subroutine call information associated with the subroutine call . This may include at least the entry time value stored in the stack element . In various embodiments the stack element may be removed from the stack . In some embodiments the persist index may be moved to the current subroutine call exit element .

In various embodiments unlike the subroutine call entry elements which do not involve the creation of an object or data structure and therefore result in minimal system resource usage the addition or creation of a subroutine call exit element may result in a unique object or data structure. However in various embodiments the number of interesting subroutine calls and therefore a subroutine call exit elements may be very small compared to the number of total or uninteresting subroutine calls. In such an embodiment the impact on system resources may be far smaller than embodiments in which all subroutine call elements entry and exit result in the creation of an object or data structure.

In such an embodiment the subroutine call information may be included in or associated with a subroutine call exit element and the start index and persist index may be incremented. Further the stack element or element may be removed or the stack .

In such an embodiment a new subroutine call entry element may be added to the array and the start index may be incremented. In various embodiments the entry timestamp and the value of the start index may be stored in the stack as stack element .

In such an embodiment a subroutine call exit element may be added to the array . The start index may be incremented. In various embodiments the subroutine call exit element may include the subroutine call information associated with the subroutine call . This may include at least the entry time value stored in the stack element . In various embodiments the stack element may be removed from the stack . In some embodiments the persist index may be moved to the current subroutine call exit element .

In such an embodiment a subroutine call exit elements and may be added to the array . The start index may be incremented twice. In various embodiments the subroutine call exit elements and may include the subroutine call information associated with the subroutine calls and respectively. This may include at least the entry time values stored in the stack elements and respectively. In various embodiments the stack elements and may be removed from the stack . In some embodiments the persist index may be moved to the current subroutine call exit element .

In such an embodiment a new subroutine call entry element may be added to the array and the start index may be incremented. In various embodiments the entry timestamp and the value of the start index may be stored in the stack as stack element .

In the illustrated embodiment upon the exit of subroutine the recording structures or subroutine call information e.g. input arguments returned value etc. may be collected. In various embodiments this may be accomplished via the code injected into the subroutine .

In the illustrated embodiment the call of subroutine is judged to not be interesting and the subroutine call entry element is not selected for preservation. In such an embodiment the subroutine call entry element may be removed from the array and the data index decremented. The start index may be decremented.

In such an embodiment a subroutine call exit element may be added to the array . The start index may be incremented. In various embodiments the subroutine call exit element may include the subroutine call information associated with the subroutine call . This may include at least the entry time value stored in the stack element . In various embodiments the stack element may be removed from the stack . In some embodiments the persist index may be moved to the current subroutine call exit element .

Graph illustrates the subroutine relationships and calling patterns of that portion of the application. In various embodiments the array may include or point to the subroutine call information of all the preserved or resisted subroutines e.g. subroutines ad . Further in some embodiments this may have been done without storing the subroutine call information for each and every subroutine call except partially and temporarily on the stack and the corresponding processor and memory usage the creation and sorting of so many objects may have entailed. In such an embodiment the minimized or reduced system resource usage of the monitoring and pruning may allow for these activities to occur during or substantially simultaneously with the execution of the monitored software application.

In various embodiments the stack may be destroyed or de allocated. In another embodiment the stack or memory locations used to store the stack may be re allocated to a different thread monitoring operation. It is understood that the above are merely a few illustrative examples to which the disclosed subject matter is not limited.

In various embodiments the formatting phase may include a stage of processing in which the subroutine call array is parsed and converted into a subroutine call tree or other data structure .

In one embodiment the start index may be moved back to the start of the array . In some embodiments from that position the start index may be incremented or walked towards the persist index . In such an embodiment as a subroutine call entry element is passed a corresponding subroutine entry is formed in the subroutine call tree . In various embodiments upon the order of the subroutine call entry elements and the subroutine call exit elements a subroutine call hierarchy and parent child relationship status may be derived. This may be especially easy with applications based on programming languages that require a single root or top level subroutine e.g. main etc. .

For example subroutine call entry element may cause a root or top level subroutine call to be added to the tree . Likewise the subroutine call entry elements and may result in the creation of subroutine call and respectively.

Upon the traversal of a subroutine call exit element e.g. element the subroutine call information associated with the element may be retrieved. In one embodiment the subroutine call information may be included with the element . In another embodiment a pointer to the subroutine call information may be included with element . For example such a pointer may allow the formatting engine to retrieve the subroutine call information from a subroutine repository or data DB as described above. This subroutine call information may be added or associated with the respective subroutine calls of the tree .

In the illustrated embodiment a subroutine call entry element may indicate that a subroutine call is further down the hierarchy in the tree . For example the entry element after entry element indicates that subroutine is called by subordinate to or in a child relationship with the subroutine .

Conversely a second or subsequent subroutine call exit element may indicate that formatting engine may move up the hierarchy of the tree . For example the exit element after entry element indicates that the associated subroutine call information is also associated with subroutine which is on the same hierarchy level as the entry element . However as the second exit element in a row the exit element is associated with the subroutine call which is up one level from the prior subroutine call .

Likewise an entry element e.g. element after an exit element e.g. element may indicate that a new branch has started on the tree . For example entry element indicates that subroutine call should start in a new branch. As described above entry elements and are associated with subroutine calls and respectively. As described above the exit elements and are associated with the subroutine calls and respectively.

In various embodiments once the start index has been moved to the end of the array the generation of the subroutine call tree may be stopped. In another embodiment the stopping event may be when the start index and the persist index are equal. It is understood that the above are merely a few illustrative examples to which the disclosed subject matter is not limited.

In the illustrated embodiment the subroutine call tree has been pruned of uninteresting or unwanted subroutine calls. Specifically comparing the tree of to the graph of shows that the subroutines and have been pruned from the full subroutine s calls hierarchy.

Further in various embodiments as the formatting and generation of the subroutine call tree involved only the moving of indexes and the reassignment or copying of data the subroutine call information etc. as opposed to costly comparison of multiple data structures and the allocation of memory space for pruned objects the formatting and generation of the subroutine call tree may occur either while another portion of the application is being executed while the pruning process of is still going one e.g. in a pipelined fashion etc. or generally without the need for processing after the application has finished executing. It is understood that the above are merely a few illustrative examples to which the disclosed subject matter is not limited.

In one embodiment the MethodEntryPlacement class may be a class used for subroutine call entry elements. In the illustrated embodiment the MethodEntryPlacement class may include an empty or shell class. Further in various embodiments the MethodEntryPlacement class may be static or a singleton such that only one instance of the MethodEntryPlacement class may be created. In such an embodiment this may reduce the system resources required to place multiple subroutine call entry elements within the subroutine call array as all subroutine call entry elements may point to or reference a single object and no additional object creation may be required. It is understood that the above is merely one illustrative example to which the disclosed subject matter is not limited.

In one embodiment the MethodRecordData class may be a class used for subroutine call exit elements. In various embodiments the MethodRecordData class may define that it is configured to store at least portions of the subroutine call information e.g. subroutine call ID subroutine call start and exit time input arguments etc. .

In some embodiments classes NormalReturnMethodData and AbnormalReturnMethodData may be configured to store the data acquired at the exit of the subroutine call e.g. return values throw exceptions etc. . In various embodiments instances of these classes and may be included by the class .

In various embodiments the RecordingArrayElement class may be configured to provide subroutines and variables or properties for each sub class e.g. classes and . It is understood that the above is merely one illustrative example to which the disclosed subject matter is not limited.

It is understood that the above are merely a few illustrative examples to which the disclosed subject matter is not limited. In various embodiments other data structures may be employed. For example in various embodiments an object oriented set of classes may not even be used.

Block illustrates that in one embodiment the execution of at least a portion of a software application may be monitored as described above. In various embodiments monitoring may include injecting code into the plurality of subroutine calls for which execution data is collected as described above. In various embodiments one or more of the action s illustrated by this Block may be performed by the apparatuses or systems of the monitoring engine of as described above.

Block illustrates that in one embodiment subroutine call information regarding a plurality of subroutine calls included by the portion of the software application may be collected as described above. In various embodiments one or more of the subroutine calls may be selected for detailed data recording as described above. In some embodiments collecting subroutine call information may include collecting only for each subroutine call selected for detail data recording all of the input arguments passed to the subroutine call and a return value if any from the call of a respective subroutine as described above. In various embodiments collecting subroutine call information may include for each call to a subroutine call placing on a memory stack an entry time associated with the subroutine call and a pointer to a subroutine entry element included in an array and associated with the subroutine call. In various embodiments one or more of the action s illustrated by this Block may be performed by the apparatuses or systems of the monitoring engine and or pruning engine of as described above.

Block illustrates that in one embodiment as the software application is being executed a subroutine call tree may be pruned to include only the subroutine calls selected for detailed data recording and one or more parent subroutine calls of each subroutine calls selected for detailed data recording as described above. In some embodiments pruning a subroutine call tree may include maintaining an array of subroutine call elements. In various embodiments maintaining may include removing from the array subroutine call elements associated with subroutine calls to be pruned from the subroutine call tree as described above. In some embodiments maintaining may also include generating the subroutine call tree based upon the array of subroutine call elements as described above.

In various embodiments maintaining the array may include adding a subroutine call entry element when a respective subroutine is called and removing when the respective subroutine exits the subroutine call entry element if the subroutine entry element is not marked for preservation as described above. In some embodiments adding a subroutine entry element may include adding a pointer to a single shared subroutine call entry element as described above. In such an embodiment the single shared subroutine call entry element may be created only once and referenced by each subroutine call entry element included in the array as described above.

In another embodiment maintaining the array may include selecting a subroutine entry element for preservation if the subroutine entry element is associated with a subroutine call that is selected for detailed data recording or associated with a parent subroutine call of the subroutine call that is selected for detailed data recording as described above. In yet another embodiment maintaining the array may include if a subroutine call element is selected for preservation adding a subroutine exit element to the array as described above. In such an embodiment the subroutine exit element may include subroutine call information regarding a subroutine call associated with the subroutine call element that is selected for preservation as described above. In various embodiments one or more of the action s illustrated by this Block may be performed by the apparatuses or systems of the pruning engine and or formatting engine of FIG. as described above.

Implementations of the various techniques described herein may be implemented in digital electronic circuitry or in computer hardware firmware software or in combinations of them. Implementations may be implemented as a computer program product i.e. a computer program tangibly embodied in an information carrier e.g. in a machine readable storage device or in a propagated signal for execution by or to control the operation of data processing apparatus e.g. a programmable processor a computer or multiple computers. A computer program such as the computer program s described above can be written in any form of programming language including compiled or interpreted languages and can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.

Method steps may be performed by one or more programmable processors executing a computer program to perform functions by operating on input data and generating output. Method steps also may be performed by and an apparatus may be implemented as special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit .

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processors of any kind of digital computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. Elements of a computer may include at least one processor for executing instructions and one or more memory devices for storing instructions and data. Generally a computer also may include or be operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. Information carriers suitable for embodying computer program instructions and data include all forms of non volatile memory including by way of example semiconductor memory devices e.g. EPROM EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory may be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user implementations may be implemented on a computer having a display device e.g. a cathode ray tube CRT or liquid crystal display LCD monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input.

Implementations may be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation or any combination of such back end middleware or front end components. Components may be interconnected by any form or medium of digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN and a wide area network WAN e.g. the Internet.

While certain features of the described implementations have been illustrated as described herein many modifications substitutions changes and equivalents will now occur to those skilled in the art. It is therefore to be understood that the appended claims are intended to cover all such modifications and changes as fall within the scope of the embodiments.

