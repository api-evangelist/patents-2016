---

title: Scheduling of scenario models for execution within different computer threads and scheduling of memory regions for use with the scenario models
abstract: A method for testing a system-on-a-chip (SoC) is described. The method includes parsing a file to determine functions to be performed components of the SoC. The method further includes receiving a desired output of the SoC and generating a test scenario model based on the desired output of the SoC. The test scenario model includes a plurality of module representations of the functions and includes one or more connections between two of the module representations. The desired output acts as a performance constraint for the test scenario model. The test scenario model further includes an input of the SoC that is generated based on the desired output, the module representations, and the one or more connections. The test scenario model includes a path from the input via the module representations and the connections to the desired output.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09651619&OS=09651619&RS=09651619
owner: Breker Verification Systems
number: 09651619
owner_city: San Jose
owner_country: US
publication_date: 20160325
---
This application is a continuation of and claims the benefit of and priority to under 35 U.S.C. 120 to U.S. patent application Ser. No. 14 689 649 filed on Apr. 17 2015 and titled SCHEDULING OF SCENARIO MODELS FOR EXECUTION WITHIN DIFFERENT COMPUTER THREADS AND SCHEDULING OF MEMORY REGIONS FOR USE WITH THE SCENARIO MODELS which claims the benefit of and priority to under 35 U.S.C. 119 e to U.S. Provisional Patent Application No. 61 981 711 filed on Apr. 18 2014 and titled Graphics Based SOC Design Tool both of which are hereby incorporated by reference in their entirety.

The present embodiments relate to testing a system on a chip with portable scenario models and at different horizontal and vertical levels.

A system on a chip SoC integrates all components of a computer or another electronic system on a chip. The SoC includes software and hardware. The SoC is used with other SoCs to develop a system for performing a number of functions e.g. printing receiving data sending data receiving phone calls playing virtual games etc.

Hardware blocks of SoCs are designed using a software tool e.g. a computer aided design CAD tool. Also software drivers that control the hardware blocks are integrated within the design. The SoCs are verified for operation before being sent to a foundry. The verification is performed using one or more languages e.g. SystemVerilog SystemC and OpenVera. Any bugs found while verifying the SoC may be corrected.

However the verification of operations of the SoC may be performed during a later stage of development of the SoC. Traditionally engineers have employed simulation acceleration emulation and or a field programmable gate array FPGA prototype to verify and debug both hardware and software for SoC designs prior to tapeout. However the acceleration emulation and prototyping consume a large amount of time to create. This large amount of time increases time to market and reduces financial revenues.

Embodiments of the disclosure provide apparatus methods and computer programs for testing a system on a chip SoC with portable scenario models and at different horizontal and vertical levels. It should be appreciated that the present embodiments can be implemented in numerous ways e.g. a process an apparatus a system a device or a method on a computer readable medium. Several embodiments are described below.

Some engineers have verified designs using multiple efforts and tools. For example the engineers create tests that apply a constrained random input stimulus. A separate checker is also developed to see if a design under test DUT behaves correctly. Also a coverage model is created to measure if all aspects of the DUT are tested by the random input stimulus. This strategy has two draw backs. First three different efforts are made one to develop the random input stimulus another to create the checker and another to create the coverage model. Second the random input stimulus may not exercise all functions of interest to test the DUT.

Moreover as designs increase in complexity a large amount of design functions are not exercised using the random input stimulus. Engineers then manually develop many test cases as sequences of stimulus that exercise the design functions. This is expensive and time consuming.

Furthermore some verification test cases are tied to specific test benches and cannot be applied across all stages of a project. For example the verification test cases created at an intellectual property IP stage of a project cannot be used at a subsystem stage and an SoC stage e.g. a silicon full chip stage etc. of the project and new tests are developed at each stage. Redeveloping these tests for the different stages is expensive and time consuming.

Also different stages of the project use test cases with different formats and mechanics. For example a simulation stage an emulation stage a field programmable gate array FPGA prototype stage and a final silicon stage may all use the same design but use test cases with different formats and mechanics for efficient verification.

Also use of different test cases for different project stages may result in a bug that is not found until a later stage e.g. during the final silicon stage etc. of the project. Fixing the bug delays time to market potentially missing a market window completely and resulting in reduced financial revenues.

In one embodiment a method for testing the SoC or a design of the SoC is described. The method includes developing portable multiple scenario models to test various combinations of functions performed by components of the SoC. In one embodiment the various combinations cover all or a majority of or a pre determined number of functions that are performed by the components. The multiple scenario models include a list of functions of one or more of the combinations to be tested and or one or more input stimulus to be applied to execute during the test and or one or more expected outcomes for comparison with the results to determine whether the one or more combinations are operational.

It should be noted that some embodiments of systems and methods described herein as being applicable to the SoC are also applicable to a design e.g. a software model etc. of the SoC.

In an embodiment a method includes generating a scenario model. For example an expected output is back propagated from an output node of a function of the SoC via the function to be tested to generate an input e.g. a stimulus etc. of the function or via additional functions of the SoC to generate a stimulus. The stimulus that is generated is applied to test a performance scenario model.

In one embodiment a stimulus is generated without back propagating an expected output from a function of the SoC. The stimulus that is generated is applied to test an application scenario model.

In one embodiment a method for testing the SoC includes applying a stimulus to an input of the SoC or an input of a function within the SoC to generate a test output and comparing the test output with an expected output to determine whether the SoC passed or failed a test.

In an embodiment a method for generating a portable scenario model using a graph is described. The graph includes multiple sub module representations. Each sub module representation acts as a stimulus or a decision making sub module representation or a test output or a functional sub module representation.

In an embodiment a decision making sub module representation is a functional block that results in more than one test output.

In one embodiment an execution of a function sub module representation results in all functional sub module representations that are connected to the function sub module representation to be evaluated.

In an embodiment an execution of a function sub module representation results in one or more of functional sub module representations that are connected to the function sub module representation to be evaluated.

In one embodiment each scenario model described herein is a graph that includes a number of module representations and links between the module representations.

In an embodiment a scenario model is generated by applying one or more constraints to a graph. For example when a sub module representation of the graph is executed to test the SoC another sub module representation of the graph cannot be executed to test the SoC. As another example when a sub module representation of the graph is executed to test the SoC another sub module representation of the graph is to be tested to test the SoC.

In one embodiment a method is performed to determine that all input nodes of a design of an SoC or an SoC are checked based on expected outputs. For example when an SoC has eight input nodes it is determined by a processor that expected outputs are back propagated to reach all the eight input nodes. If some of the input nodes cannot be reached by back propagation the input node is determined by a processor to be an illegal input node or an input node that is missing from a portable scenario model.

In an embodiment a method includes determining a coverage of portable scenario models. A processor determines a number of paths e.g. paths providing portable scenario models etc. in a graph that are traversed during execution of a test of the SoC or a design of the SoC. The number of paths traversed relative to a total number of paths in the graph that may be traversed provides a coverage of portable scenario models in the graph.

In one embodiment when a number of paths in a graph is larger than a pre determined number to traverse during a test a processor identifies paths that are more crucial than others for traversal during a test of the SoC or a design of the SoC. In an embodiment instead of identifying paths a processor identifies sub module representations or module representations within a graph that are more crucial than other sub module representations or module representations of the graph. The processor then identifies paths that pass through the more crucial sub module representations or module representations. The identified paths are traversed during execution of a test of the SoC or a test of a design of the SoC.

In an embodiment a method includes using a portable scenario model to generate test cases for test benches at each stage of the project. For example at the IP stage a test file generated from the portable scenario model includes a transaction using inputs and outputs of an IP block of the IP stage and at the SoC stage includes the transaction using inputs and outputs and additional transactions that use a processor of the SoC stage and or that use I Os of the SoC. As another example the portable scenario model is used to test the SoC stage. In this example back door memory checks e.g. accessing data from a memory device of the SoC and checking against an expected output etc. are performed or a CPU of the SoC is used to compute checksums of data stored in the memory device to increase a rate of testing the SoC at the SoC stage of the project. The preceding example also applies the emulator stage of the SoC or the prototype stage of the SoC. An emulator of an SoC is checked at an emulation stage of the project and a prototype of the SoC is tested at the prototype stage of the project.

In an embodiment a method includes generating application scenario models or performance scenario models from multiple driver scenario models. For example portable driver scenario models for individual functions e.g. for each IP of the SoC etc. are combined e.g. connected together via links etc. to define application scenario models or performance scenario models. In one embodiment the application scenario models or the performance scenario models include application of all functions or a majority of functions of the SoC.

In one embodiment a method includes scheduling tests e.g. generating test files for execution etc. across multiple processors.

In an embodiment a consumer scenario model e.g. a driver scenario model etc. is scheduled to start after finish of execution of a producer scenario model e.g. a driver scenario model etc.

In one embodiment multiple threads e.g. multiple test files etc. are executed by a processor. For example multiple test files are scheduled to run concurrently e.g. to be executed in a multi tasking manner by a processor.

In an embodiment a visual representation of a schedule showing a timing relation between the producer and consumer scenario models is displayed by a graphical processing unit on a display device.

In an embodiment a method includes scheduling memory usage for operations within a test e.g. conducted using a test file etc. The memory usage involves using multiple memory regions.

In an embodiment a visual representation of a scheduling of use of multiple memory regions is displayed by the graphical processing unit on the display device.

In one embodiment a memory region is reused during a test based on locality of the memory region compared to other memory regions.

In an embodiment a method includes sending messages from a test file generation module executed on a processor to a test bench agent e.g. a bus verification intellectual property VIP a CPU etc. to coordinate operations between the test file generation module and an I O of an SoC. For example test file generation module executes a test file to program a universal asynchronous receiver transmitter UART of the SoC to transmit data wait till the transmission is complete and then sends a message to the test bench agent to check that the correct data was transmitted on the UART. In one embodiment such messages are used to generate debug messages e.g. messages indicating that the correct data was not transmitted etc. In an embodiment such messages are used to measure a level of concurrency that has been achieved in a test. For example the messages are used to determine how often two power domains have powered up within a thousand cycles of each other to facilitate an indication or a lack thereof of a brown out situation on a power grid.

In one embodiment a method for testing a system on a chip SoC is described. The method includes receiving a file describing the SoC and parsing the file to determine one or more functions to be performed by one or more hardware components of the SoC. The SoC is fabricated on one or more chips. The method further includes receiving a desired output of the SoC and generating a test scenario model based on the desired output of the SoC and the functions to be performed. The test scenario model includes one or more module representations of the functions and includes one or more connections between two of the module representations. Each connection provides a direction of flow of data between the two module representations. The desired output acts as a performance constraint for the test scenario model. The test scenario model further includes an input of the SoC that is generated based on the desired output the module representations and the one or more connections. The test scenario model includes a path from the input via the module representations and the connections to the desired output. The method is executed by a processor.

In an embodiment another method for testing an SoC is described. The method includes receiving one or more scenario models. Each scenario model provides a path of a direction of execution of one or more intellectual property IP blocks associated with an SoC. The method further includes generating one or more test files using the scenario models. The scenario models further include one or more inputs associated with the SoC that are generated based on one or more expected outputs associated with the SoC.

In one embodiment yet another method for testing an SoC is described. The method includes receiving multiple scenario models. Each scenario model is used for execution of one or more intellectual property IP blocks along a path. The path is used for generating a test output based on a stimulus that is received at an input of the path. The method also includes executing a first test bench to execute the at least one of the scenario models to further generate one or more test outputs and executing a second test bench to execute the at least one of the scenario models to further generate one or more test outputs. The method includes comparing the test outputs generated by executing the first test bench with one or more expected outputs to determine whether a system on a chip SoC passes a test at a first stage of a project. The method includes comparing the test outputs generated by executing the second test bench with one or more expected outputs to determine whether the SoC passes a test at a second stage of a project. The method is executed by a processor.

In one embodiment a method includes receiving multiple application scenario models which are generated for testing one or more systems on chips SoCs . The application scenario models include a plurality of driver scenario models and a plurality of sequences of execution of the driver scenario models. Moreover each application scenario model is generated by back propagating an expected output of the application scenario model to generate an input to be provided to the application scenario model during a test of the one or more SoCs. The method further includes splitting the application scenario models into a pre determined number of computer threads. Each computer thread includes at least one but not all of the driver scenario models. The method includes splitting the sequences into a plurality of flows between the driver scenario models of the computer threads. The method includes providing for testing of the one or more SoCs the driver scenario models within the computer threads and the plurality of flows between the driver scenario models of the computer threads.

In an embodiment a method includes receiving multiple application scenario models which include a plurality of driver scenario models and sequences of application of the driver scenario models. The application scenario models are used for testing one or more SoCs. Moreover each application scenario model is generated by back propagating an expected output of the application scenario model to generate an input to be provided to the application scenario model during a test of the one or more SoCs. The method further includes splitting multiple memory addresses into a plurality of memory regions. Each of the memory regions is exclusive of any other of the memory regions. Also one of the driver scenario models of one of the application scenario models includes reading data from one of the memory regions. Another one of the driver scenario models of the one of the application scenario model includes writing data to another one of the memory regions.

In one embodiment a system includes a memory device for storing application scenario models which are generated for testing one or more SoCs. The application scenario models include a plurality of driver scenario models and a plurality of sequences of execution of the driver scenario models. Each application scenario model is generated by back propagating an expected output of the application scenario model to generate an input to be provided to the application scenario model during a test of the one or more SoCs. The system further includes a processor coupled to the memory device. The processor receives the application scenario models. The processor further splits the application scenario models into a pre determined number of computer threads. Each computer thread includes at least one but not all of the driver scenario models. The processor further splits the sequences into a plurality of flows between the driver scenario models of the computer threads. The processor provides for testing of the one or more SOCs the driver scenario models within the computer threads and the plurality of flows between the driver scenario models of the computer threads.

In one embodiment a method includes generating a graphical display of multiple computer threads. Each computer thread includes one or more driver scenario models. Each driver scenario model includes a function associated with a test of one or more SoCs. The method further includes identifying a flow of execution of the driver scenario models from one of the computer threads to another one of the computer threads. The flow of execution provides a sequence in which the one of the computer threads and the other one of the computer threads are executed.

In an embodiment a method includes receiving multiple application scenario models which include a first driver scenario model and a second driver scenario model and a flow of execution of the first and second driver scenario models. The application scenario models are executed for testing one or more SoCs. The method further includes assigning the first driver scenario model to a first computer thread and the second driver scenario model to a second computer thread. The method also includes providing the first driver scenario model the second driver scenario model the flow of execution the assignment of the first driver scenario model to the first computer thread and the assignment of the second driver scenario model to the second computer thread for testing a design of the one or more SoCs. The method includes generating a graphical display of the first and second computer threads to indicate the flow between execution of the first and second driver scenario models.

In one embodiment a system includes a memory device for storing data associated with a graphical display of multiple computer threads. Each computer thread includes one or more driver scenario models. Each driver scenario model includes a function associated with a test of one or more SoCs. The system further includes a processor coupled to the memory device. The processor generates the graphical display and identifies a flow of execution of the driver scenario models from one of the computer threads to another one of the computer threads. The flow of execution provides a sequence in which the one of the computer threads and the other one of the computer threads are executed.

Some advantages of the embodiments described in the present disclosure include generation of a test file from scenario models by a processor verification of a chip design at a driver scenario model level and verification by a processor that a flow of data occurs between intellectual property IP blocks fabric module representations and memory device module representations.

Additional advantages of the embodiments described in the present disclosure include verification by a processor of power and clock management at one or more stages e.g. an IP stage a subsystem stage an SoC stage a simulation stage an emulation stage a prototyping stage a post silicon stage etc. of a project of developing an SoC. For example a system and power control module representation is executed by a processor to provide power to an IP block at the IP stage and is also executed to provide power to multiple IP blocks at the subsystem stage. An amount of the power provided is compared with an expected amount of power at each of the IP and subsystem stages to determine whether the amount of power matches or is within a pre determined range of the expected power to further determine whether the system and power control module representation is functioning at both the stages.

In one embodiment the amount of power provided by the system and power control module representation at the IP stage is compared with the amount of power provided by the system and power control module representation at the subsystem stage to determine whether the system and power control module representation is functioning.

In an embodiment the amount of power received by an IP block at the IP block stage is compared with the amount of power received by the IP block at the subsystem stage to determine whether the system and power control module representation is functioning.

As an example of verification by a processor of clock management at the one or more stages a clock module representation is executed by a processor at the IP stage to determine whether a clock signal that is generated and supplied by the clock module representation matches or is within a predetermined threshold of an expected clock signal output. As another example of verification by a processor of clock management at the one or more stages a clock module representation is executed by a processor at the simulation stage to determine whether a clock signal that is generated and supplied by the clock module representation matches or is within a predetermined threshold of an expected clock signal output. As yet another example of verification by a processor of clock management at the one or more stages a clock module representation is executed by a processor at the subsystem stage to determine whether a clock signal that is generated and supplied by the clock module representation matches or is within a predetermined threshold of a clock signal that is generated by the clock module representation during the IP block stage.

Further advantages of the embodiments described in the present disclosure include integrating one or more scenario models into a test bench verification by a processor of operations of one or more IP blocks at the one or more stages and verification by a processor of a width of a bus fabric module representation. For example to verify the width of the bus fabric module representation it is determined whether the bus fabric module representation hangs under stress. To further illustrate an amount of data that is greater than the width of the bus fabric module representation is passed through the bus fabric module representation to determine whether the bus fabric module representation manages the passage of data or becomes nonfunctional under stress.

Additional advantages of the embodiments described in the present disclosure include detection by a processor of failure of a memory device module representation e.g. a memory bank module representation a virtual memory etc. upon access by multiple IP blocks to the memory device module representation. Another advantage of the above described embodiments include determining by a processor whether an IP block of an SoC or a subsystem of the SoC or a simulation of the SoC or an emulator of the SoC or a prototype of the SoC or a post silicon SoC or a combination thereof hangs when there is a change in a state e.g. a change from a low state to a high state a change from the high state to the low state a change from 1 to 0 a change from 0 to 1 etc. of a clock signal that is supplied by the system and power control module representation.

Another advantage of the embodiments described in the present disclosure include revelation by a processor of an address decode bug when an address of a memory device module representation is accessed by multiple IP blocks. Another advantage of the embodiments described in the present disclosure includes graphical presentation of test cases and verification. For example the graphical presentation includes bar graphs that further include driver scenario models and a chain indicating a sequence of execution of the driver scenario models. Moreover the driver scenario models are coded based upon whether a driver scenario model has finished execution is waiting for execution or is hanging. In one embodiment the coding of the driver scenario models is based on different colors or different patterns or different shades of color. The graphical presentation allows a user to more quickly debug a test computer program code or a compiled computer program code than one without the graphical presentation.

Moreover another advantage of the embodiments described in the present disclosure includes execution of scenario models to capture knowledge of an SoC at the one or more stages of the project. An additional advantage of the embodiments described in the present disclosure include generation of a large number e.g. 1000 3000 1500 2000 etc. of test cases e.g. scenario models etc. for testing an SoC at the one or more stages of the project. Such generation of the large number of test cases is difficult when done by hand.

Furthermore an advantage of the embodiments described in the present disclosure is that the test cases are executed by multiple processors and or in multiple threads to mimic an actual performance of an SoC. For example when the SOC includes three processors the test cases are generated to include three processor module representations. As another example when the SOC executes 10 threads on one processor the test cases are generated to include 10 threads executed by one central processing unit CPU module representation.

Another advantage of the embodiments described in the present disclosure include exercising with the test cases of end to end use of multiple driver scenario models to measure performance of the multiple driver scenario models during the end to end use. For example at one end of an application scenario model of a digital camera is a driver scenario model that includes a charge coupled device CCD module representation and at another end is a driver scenario model that includes a secure digital SD card module representation. Between the CCD module representation and the SD card module representation is a camera module representation an image processor module representation and an SD card controller module representation. The CCD module representation is coupled to the camera module representation which is coupled to the image processor module representation. The image processor module representation is coupled to the SD card controller module representation.

Yet another advantage of the embodiments described in the present disclosure includes automated generation of test cases by a processor from modified scenario models. Another advantage of the embodiments described in the present disclosure includes that the test cases are optimized for rapid runtime.

An advantage of the embodiments described in the preset disclosure includes allowing a single portable scenario model that describes functions expected outcomes and or stimulus instead of three separate efforts to create random stimulus checks and a coverage model.

Another advantage of the embodiments described in the preset disclosure is that back propagating from an expected outcome via a feature e.g. module representation sub module representation functional block etc. to generate a stimulus to create a scenario model that exercises the feature in a focused manner instead of relying on random chance to create a sequence to exercise the feature. Use of the scenario models to cover different features of the SoC to systematically satisfy a coverage target further reduces a number of redundant tests that are run.

An advantage of the embodiments described in the preset disclosure is that by using reachability analysis e.g. generation of a stimulus from an expected outcome etc. on the portable scenario models it is possible to analyze an amount of verification intent that is covered by the scenario models before any tests are run. Previously tests were run to collect coverage data to further understand a quality of test coverage.

Yet another advantage of the embodiments described in the preset disclosure is that IP driver scenario models are combined to generate application scenario models to further test interactions between the IPs instead of having to manually develop new test cases that combine the IPs.

Another advantage of the embodiments described in the preset disclosure is that the same portable scenario model can be used to generate tests for test benches at different stages of the project e.g. tests for I O transactions at an IP block stage of the project tests at the SoC stage etc. The same portable scenario model is used to generate test cases optimized for each stage of the project without having to develop new tests.

An advantage of the embodiments described in the preset disclosure is that concurrent operations can be scheduled across a plurality of processors and or threads.

Other aspects will become apparent from the following detailed description taken in conjunction with the accompanying drawings.

The following embodiments describe systems and methods for testing a system on a chip SoC with scenario models and at different horizontal and vertical levels. It will be apparent that the present embodiments may be practiced without some or all of these specific details. In other instances well known process operations have not been described in detail in order not to unnecessarily obscure the present embodiments.

In one embodiment the SoC is an integrated circuit IC that integrates all components e.g. a memory device a processor an input output a bus etc. of a computer or another electronic system into a chip. For example the SoC includes digital analog mixed signal and often radio frequency functions all on a chip substrate. In an embodiment the SoC includes a microcontroller.

In an embodiment instead of the SoC a system in package SIP is used. The SIP includes a number of chips in a single package. In a number of embodiments instead of the SoC a package on package stacking is used during circuit board assembly. For example the package on package stacking includes the SoC chip which further includes processors and numerous digital peripherals and comes in a ball grid package with lower and upper connections. The lower balls connect to the board and various peripherals with the upper balls in a ring holding memory buses used to access memory devices e.g. a flash memory a register a flip flop a virtual memory a read only memory ROM and a random access memory RAM . Other examples of memory devices include a read only memory a volatile memory a non volatile memory a redundant array of storage disks a hard disk etc.

The file defines the SoC. For example the file includes a description of components of the SoC connections between the components one or more output nodes of each component one or more input nodes of each component functions performed by the components and functions performed by the connections. Examples of the components include a processor a page translation unit a cache a clock a power management device a memory device a controller an input output I O device a bus a fabric a switch a charge coupled device CCD etc.

In one embodiment the description of the components of the SOC in the file is in a programming language e.g. a C programming language a C programming language etc. In an embodiment the description of the SoC is performed using graphics that show the components and connections between the components.

The processor parses the file to identify the output nodes of each component and to further identify the functions of the components. Examples of the output nodes include output node output node and so on until output node N where N is a number of the components. Moreover examples of the functions include a function a function and so on until a function N.

In one embodiment each component performs more than one function e.g. a primary function a secondary function etc. and has a number of output nodes that matches the number of functions performed by the component. In the embodiment a number of functions performed do not match a number of components. For example the number of functions e.g. M functions etc. performed by a component is greater than or less than a number of the components where M is an integer greater than one.

In an embodiment functions of components of the SoC are received by the processor from the user via an input device which is coupled to the processor via an input output interface e.g. a universal serial bus USB interface a parallel port a serial port etc.

The processor generates a module representation for each function. For example upon parsing the file the processor generates a module representation for the function and generates a module representation N for the function N. As another example the processor generates a module representation that portrays a read controller corresponding to a function of reading data from a memory device. As yet another example the processor generates a module representation that describes an image encoder for a function of encoding image data. The modules thru N form a graphical layout.

Each module representation is connected by the processor to one or more output nodes e.g. the output node the output node etc. based on a relationship between a corresponding component and one or more outputs e.g. signals data values etc. of the component. An output is generated by a component by performed one or more functions. Examples of outputs of a module representation include an image that is displayed on a display device an image that is stored in a memory device and multimedia that is stored in a memory device or is displayed on a display device etc. Examples of multimedia include a combination of audio and video or a combination of an image and audio a combination of an animation and audio a picture in a picture etc. The connection between the module representation and one or more of the output nodes is performed to include the one or more of the output nodes as a part of the module representation. For example upon determining that a component of the SoC has two outputs the processor integrates a module representation of the component with two output nodes e.g. an output node and an output node . It should be noted that in an embodiment the output nodes and are sub nodes of the output node . As another example upon determining that a component of the SoC produces a number of outputs the processor integrates a module representation of the component with the same number of output nodes.

The processor identifies an output node from the output nodes that are connected to the module representations. The output node identified is an output associated with an application of one or more functions of the SoC. For example the processor identifies the output node N which is generated by displaying an image on a display device. As used herein examples of a display device include a display device of a camera a display device of a computer a display device of a cell phone a display device of a smart phone a display device of a tablet etc. Further examples of a display device include a liquid crystal display LCD a light emitting diode LED display a plasma display etc. As another example the processor identifies the output node which is generated from an application of capturing an image and storing the image in a memory device.

It should be noted that in an embodiment some of the output nodes thru N affect one or more of the remaining of the output nodes thru N. For example an output at one of the output nodes thru N adds a constraint to an output at another one of the output nodes thru N. Both the output at the output node that affects the output at the other output node of the thru N output nodes by adding the constraint and the output that is affected are associated with the same application. To further illustrate when an output at one of the output nodes thru N is achieved an output at another one of the output nodes thru N cannot be achieved. As another illustration when a high quality picture is displayed on a display device a low quality image cannot be displayed on the display device. As yet another illustration when a car is controlled to be turned on the car cannot be controlled to be turned off. As another illustration at a time a cell phone screen is displaying a video the cell phone screen cannot display another video.

In one embodiment an output at one of the thru N output nodes that affects an output at another output node of the thru N output nodes by adding the constraint and the output that is affected are associated with different applications. For example when a camera is displaying an image the camera cannot capture an image. As another example when a cell phone is displaying a video the cell phone cannot capture another video of an environment surrounding the user. The user operates the cell phone.

The processor uses one of the thru N output nodes that is identified and a number of applications to be achieved to generate a number of scenario models for the output node. Examples of the scenario models include a performance scenario model an application scenario model a driver scenario model DSM etc. Examples of the applications include storing an image capturing an image writing reading encoding an image decoding an image transferring an image any of the functions described herein a combination of the functions described herein etc.

In an embodiment the processor combines two or more of the functions to generate an application from the combination. In one embodiment an application to be performed using the one or more of the module representations thru N is received from the user via the input device.

It should be noted that a performance scenario model is similar to the application scenario model except that in the performance scenario model a test output is compared with an expected output to determine whether an SoC or a design of the SoC passed a test. In the application no such comparison is performed after generating a test output and the test output is manually analyzed. Examples of the performance scenario model the application scenario model and the driver scenario model are provided below.

A scenario model is generated based on the one of the thru N output nodes that is identified one of more of the module representations thru N and the one or more applications of an SoC. For example the processor retrieves the Nth output node that is identified from a memory device provides a seed as an expected output of the Nth output node to achieve an application and applies a function of the Nth module representation having the Nth output node to generate an input at an input node of the Nth module representation. Examples of the seed include an image image data multimedia data video video data an expected output etc. As another example when an application is that of capturing and storing an image the seed is the image. As yet another example when an application is that of writing data to a memory device the seed is the data. In one embodiment the seed is provided within the file that is parsed by the processor . In an embodiment the seed is provided by the user via the input device to the processor . The input node of the Nth module representation is an output node of the N 1 th module representation.

The processor further determines based on a function that precedes a function performed by the Nth module representation the application and the seed that the N 1 th module representation is to be connected to the Nth module representation. The input at the input node of the Nth module representation is further used by the processor as an output of the N 1 th module representation. An input at an input node of the N 1 th module representation is generated by the processor based the output at the output node of the N 1 th module representation. In such a manner the processor back propagates the output at the output node of the Nth module representation to achieve an application.

The processor back propagates the output at the output node of the Nth module representation to generate the scenario model which includes a group of the N module representations and links between a number of the N module representations. To illustrate the processor generates the scenario model as a group of the Nth module representation and the N 1 th module representation and a link between the N 1 th module representation and the Nth module representation. In one embodiment a link has a direction opposite to that of the back propagation. For example a link is forward propagating between the N 1 th module and the Nth module representation when an input of the Nth module is back propagated to generate an input e.g. a stimulus etc. of the N 1 th module representation. To further illustrate a link points from the N 1 th module to the Nth module when an input of the Nth module is back propagated to generate an input of the N 1 th module representation. In an embodiment a link is bi directional.

As another example of generation of the scenario model the processor retrieves from a memory device module representation a quality of a decoded image to be displayed on a display device generates a display controller module representation to facilitate rendering of the decoded image on the display device determines that a decoder module representation be connected to the display controller module representation to decode encoded image data to achieve the quality of the decoded image and connects the decoder module representation to the display controller module representation. The processor generates decoded image data at an input node of the display controller module representation based on the quality of the decoded image to be displayed and based on the decoded image data generates the encoded image data at the input of the decoder module representation. In this example the display controller module representation is an example of the Nth module representation and the decoder module representation is an example of the N 1 th module representation. The processor generates the scenario model as a group of the decoder module representation and the display controller module representation and a link connecting the decoder module representation to the display controller module representation.

An example of the scenario model is illustrated as a scenario model in . The scenario model includes module representations A B C D E F and G. For example the module representation D is an example of the Nth module representation and the module representation C or G is an example of the N 1 th module representation. Moreover the scenario model includes links l l l l l l and l each of which is an example of a direction of flow.

The processor determines whether additional output nodes of the SoC are identified from the parsed file. In response to determining that the additional output nodes are identified from the parsed file the processor generates additional scenario models for additional applications of the SoC from the additional output nodes in a manner similar to that described above.

In one embodiment an output of the Nth module representation is back propagated by the processor via the Nth module representation to generate an input of the Nth module representation. Similarly the input which is an output of the N 1 th module representation is back propagated by the processor via the N 1 th module representation to generate an input of the N 1 th module representation. By progressively generating an input of a module representation from an output of the module representation a stimulus e.g. an input etc. of a scenario model is determined by the processor .

As shown in the scenario models that are to be executed by a test bench are generated by the processor from the parsed file. It should be noted that in one embodiment scenario models are generated manually by the user via an input device e.g. a keyboard a stylus a mouse a touch screen a keypad etc. of a computing device in which the processor is implemented. For example the scenario models as described herein are generated by the user and received by the processor from the user to generate one or more test files. Examples of the computing device include a desktop computer a laptop computer a cell phone a smart phone a tablet etc.

In one embodiment one or more test files store one or more scenario models to facilitate availability of the one or more scenario models to a computer program e.g. a test bench etc. In an embodiment one or more test files are modified or deleted by using a computing device.

In an embodiment multiple test files are compiled by the processor or by another processor to generate a compiled file which is provided by the processor to a test file generation module .

In one embodiment a module as used herein is a computer software that is executed by a processor or is hardware or a combination thereof. Examples of a hardware of a module include an ASIC a PLD etc.

The processor executes the test file generation module to parse a compiled file that includes the scenario models to further generate one or more test files. Each test file includes a scenario model. For example the processor parses a compiled file that includes multiple scenario models to generate a test.c file or a test.C file that includes one the scenario models and to further generate another test.c file or a test.C file that includes another one of the scenario models. The processor executes a compiler program to compile each test file into a compiled file.

The compiled files generated from the test files are provided by the processor to a test bench program. The test bench program is a virtual environment used to verify functioning or soundness of the scenario models. In one embodiment the test bench program is executed by the processor . In another embodiment the test bench program is executed by a processor other than the processor that generates a compiled file.

In an embodiment the test bench program executes module representations of the components of the SoC. A path from an input node of one of the module representations to an output node of the same or another module representation is provided by a scenario model to the test bench program.

The test bench program is executed to execute the scenario models. For example the processor provides an input that is determined as the input of the Nth module representation from the output at the Nth output node as a stimulus to execute one of the scenario models. As another example the processor provides an input that is determined as the input of the N 1 th module representation from the output at the N 1 th output node as a stimulus to execute one of the scenario models. As another example the processor provides an input that is determined at the input of the 1module representation from an output at the 1output node as a stimulus to execute one of the scenario models.

When the test bench program is executed a number of test outputs are generated by the processor . For example when the test bench program is executed a test output is generated at the Nth output node based on the stimulus provided to the Nth module representation. As another example upon execution of the test bench program a test output is generated at the N 1 th output node based on a stimulus provided as an input to the N 1 th module representation. As yet another example upon execution of the test bench program a test output is generated at the Nth output node based on a stimulus provided as an input to the N 1 th module representation. As still another example in response to execution of the test bench program a test output is generated at the Nth output node based a stimulus provided as an input to the 1module representation.

In an embodiment a number of stimulus provided is equal to a number of applications of the SoC. For example when the SoC is to be tested for a decoding application and an encoding application two stimulus s are provided. In this example one stimulus includes an encoded image to test the decoding application and another stimulus includes a decoded image to test the encoding application.

The processor compares the test output to a corresponding expected output. The processor parses a compiled file that is generated from a test file to retrieve the one or more expected outputs. It should be noted that an expected output corresponds to the test output when the expected output is at the same node as that of the test output. For example an expected output at the Nth output node corresponds to a test output when the test output is at the Nth output node.

The processor determines whether a test passed or failed based on a result of the comparison of the test output with the corresponding expected output. For example the processor determines whether the test output matches the corresponding expected output. Upon determining that the test output matches the corresponding expected output the processor determines that the test passed. On the other hand upon determining that the test output does not match the corresponding expected output the processor determines that the test failed. As another example the processor determines whether the test output is within a pre determined threshold of the corresponding expected output. The pre determined threshold is provided by the user via the input device to the processor . In one embodiment the processor randomly generates the pre determined threshold. Upon determining that the test output is within the pre determined threshold of the corresponding expected output the processor determines that the test passed. On the other hand upon determining that the test output is outside the pre determined threshold of the corresponding expected output the processor determines that the test failed.

The scenario models include a memory map e.g. a link etc. between a module representation and a memory device module representation e.g. an address a set of addresses. As an example a memory map includes identifications of registers and fields that support each intellectual property IP block and available instances of each memory device module representation with available base addresses of the memory device module representations. In one embodiment an IP block is a module representation except for a memory device module representation. As another example a memory map includes a cache line size of a cache module representation that supports an IP block a number of cache lines of the cache module representation set associativity of the cache module representation a cache index hash function of the cache module representation etc. The memory device module representation is used for storing an input or an output of an IP block. It should be noted that a function of a memory device module representation is to store an input or an output. The scenario models further include one or more driver scenario models one or more application scenario models and one or more performance scenario models.

In one embodiment the scenario models include a number of driver scenario models or a number of application scenario models or a number of performance scenario models or one or more stimulus or one or more expected outputs or a combination thereof.

In an embodiment an application scenario model includes a number of driver scenario models. As an example a driver scenario model is a model of a function that is used with other functions of an application scenario model. In one embodiment a performance scenario model includes a number of driver scenario models.

In an embodiment a scenario model that is of a lower level than a higher level model provides randomized services to the higher level model and the higher level model applies a number of constraints to the lower level models. For example an output of an application scenario model applies a constraint on a driver scenario model which is included within the application scenario model. In this example the driver scenario model is not executed or is executed based on limited data values as a result of the constraint. As yet another example a performance scenario model is at a higher level than an application scenario mode which is at a higher level than a driver scenario model.

When one or more scenario models are generated before a test that applies the scenario models is executed using a test bench constraints associated with a driver scenario model is generated before the test is executed. This prior generation of scenario models and of constraints yields tests that are individual light weight repeatable and simple to debug.

In an embodiment one of the scenario models includes obtaining a response from an IP block that is powered down or disabled. The IP block is powered down when the IP block is not provided power by a system and power control module representation which is further described below.

The test file generation module receives the scenario models in a compiled file and parses the compiled file to generate one or more test files . For example the test files include a test file A a test file B and a test file C. Each test file A B and C includes a scenario model. For example the test file A stores one of the scenario models the test file B stores another one of the scenario models and the test file C stores yet another one of the scenario models .

In an embodiment an event file further described below includes a number of expected outputs associated with the number of scenario models.

A hierarchy of the lower and higher levels of the scenario models is used by the test file generation module for generation of the one or more test files . For example one test file stores a driver scenario model and another test file stores an application scenario model that includes the driver scenario model. As another example one test file stores a performance scenario model and another test file stores an application scenario model.

In one embodiment a first test file generated by the test file generation module is compiled by a first compiler executed by the processor and a second test file generated by the test file generation module is compiled by a second compiler executed by the processor or by another processor. For example the first test file is compiled by a compiler of the processor simultaneous with or sequential to compiling of the second test file by another compiler of the processor . The compilation of each of the test files by a different compiler is for a design of the SoC in which multiple processors are used. One of the multiple processors executes a function of or within a scenario model that is stored in the first test file and compiled by the first compiler and another one of the multiple processors executes a function of or within another scenario model that is stored in the second test file and compiled by the second compiler.

Examples of the one or more test files include a C file and a C file. Other examples of the one or more test files include a Fortran file an Assembly language file a distribution application specific language DASL file a D file an objective C file etc. to name a few. It should be noted that in one embodiment the one or more test files are generated in any other programming language.

In one embodiment each of the one or more test files is executed randomly by the processor as a micro kernel running randomized applications e.g. driver scenario models etc. Each of the one or more test files when executed randomly calls a number of driver scenario models that is a portion of an application scenario model or a performance scenario model.

In one embodiment each test file A B and C stores a different type of scenario model. For example the test file A stores an application scenario model the test file B stores a driver scenario model and the test file C stores a performance scenario model. In an embodiment each test file stores the same type of scenario models. For example the test file A stores an application scenario model the test file B stores another application scenario model and the test file C stores yet another application scenario model.

Moreover the test file generation module parses the compiled file that includes the scenario models to generate one or more events files e.g. an event file A an event file B and an event file C. Each of the event files includes a number of expected outputs. For example the event file A includes an expected output for the same type of a scenario model as that of the event files B and C. To illustrate the event file A includes an expected output of an application scenario model the event file B includes an expected output for another application scenario model and the event file C includes an expected output for yet another application scenario model. As another illustration the event file A includes an expected output of a driver scenario model the event file B includes an expected output for another driver scenario model and the event file C includes an expected output for yet another driver scenario model. As another example the event file A includes an expected output for a different type of scenario model than that of the event files B and C. To illustrate the event file A includes an expected output of an application scenario model the event file B includes an expected output for a driver scenario model. As another illustration the event file A includes an expected output of a driver scenario model and the event file C includes an expected output for a performance scenario model.

Each event file is associated with a corresponding test file. For example the event file A stores an expected output of a scenario model that is stored within the test file A the event file B stores an expected output of a scenario model that is stored within the test file B and the event file C stores an expected output of a scenario model that is stored within the test file C.

In an embodiment an event file is associated with multiple test files. For example the event file A stores an expected output of a scenario model that is stored within the test file A stores an expected output of a scenario model that is stored within the test file B and stores an expected output of a scenario model that is stored within the test file C.

In one embodiment each event file includes a number of event identifications IDs which are further explained below.

The test files are compiled by a compiler to generate one or more compiled files. The compiler is executed by the processor . In an embodiment the compiler is executed by a processor other than the processor . The compiled files are provided by the compiler to a test bench which is executed by the processor or by another processor of a computing device.

In an embodiment a first one of the test files is compiled by a different compiler than a compiler that is used to compile a second one of the test files to generate compiled files for a test bench of the SoC in which multiple processors are used. A module representation within the test bench of one of the processors is used to execute at least a portion of a scenario model stored within the first one of the test files and a module representation within the test bench of another one of the processors is used to execute at least a portion of a scenario model within the second one of the test files .

In one embodiment a test bench as described herein is executed by a processor other than the processor that generates one or more test files. This separation saves a number of CPU cycles of the processor used and reduces load on the processor . In an embodiment a memory device used to store one or more test files is other than a memory device used to store a test bench described herein.

The compiled files that are compiled by the compiler are provided to the test bench to further execute one or more of the module representations A B C D E F and G and or to execute a fabric and or to execute a fabric . A number of the module representations A B C D E F and G executed within the test bench depends on whether the module representations are designated for execution in the one or more scenario models . It should be noted that each fabric and includes one or more links between two or more of the module representations A B C D E F and G. The test bench further includes a number of I O module representations.

In some embodiments the test bench is executed by a processor e.g. a CPU other than the processor . In various embodiments the test bench is executed by the processor .

A comparator is executed by the processor or by another processor of a computing device. In one embodiment the comparator is generated using a test programming language e.g. SystemVerilog language hardware description layer HDL language etc. The comparator receives the events files .

In one embodiment the events files include stimuli. The comparator parses the events files to determine the stimuli and provides the stimuli to one or more I O module representations of the test bench . For example the comparator provides the stimuli to one or more I O module representations A and C of the test bench.

In an embodiment each test file A B and C includes a stimulus for testing an SoC or a design of the SoC. For example the test file A includes a stimulus for providing to a first scenario model the test file B includes a stimulus for providing to a second scenario model and the test file C includes a stimulus for providing to a third scenario model.

Upon receiving stimuli from the comparator or from the compiled file that is received from the compiler the test bench executes one or more scenario models to generate a number of test outputs. For example as illustrated using a dashed line in the test bench the test bench forward propagates a stimulus from an input node of a module representation A and applies a function of the module representation A to the stimulus to generate an output at an output node of the module representation A. The dashed line provided a direction of execution of a path. The stimulus is received from the comparator . The output at the output node of the module representation A is forward propagated by the test bench via the fabric to an input node of a module representation D. The test bench applies a function of the module representation D to the output receive at the input node of the module representation D to generate an output at an output node of the module representation D. The test bench forward propagates the output at the output node of the module representation D via a link to an input node of a module representation E. The test bench further applies a function of the module representation E to the output received at the input node of the module representation E to generate an output at an output node of the module representation E. The output at the output node is forward propagated by the test bench via the fabrics and to an input node of a module representation B.

Continuing with the example the test bench applies a function of the module representation B to the output received at the input node of the module representation B to generate an output at an output node of the module representation B. The test bench also forward propagates the output at the output node of the module representation B via a link to an input node of a module representation C. Thereafter the test bench applies a function of the module representation C to the output received at the input node of the module representation C to generate an output at an output node of the module representation C. The output at the output node of the module representation C is forward propagated by the test bench via the fabrics and to an input node of a module representation F. The test bench applies a function of the module representation F to the output received at the input node of the module representation F to generate an output at an output node of the module representation F. The output at the output node F is forward propagated as a test output by the test bench via the I O module representation C to the comparator .

As another example as illustrated using a dotted line in the test bench the test bench forward propagates a stimulus from an input node of the module representation E and applies a function of the module representation E to the stimulus to generate an output at an output node of the module representation E. The dotted line provides a direction of execution of a path. The stimulus is received from the comparator . The output at the output node of the module representation E is forward propagated by the test bench via the fabrics and to an input node of the module representation B. The test bench applies a function of the module representation B to the output received at the input node of the module representation B to generate an output at an output node of the module representation B. The test bench forward propagates the output at the output node of the module representation B via a link to an input node of the module representation C. The test bench further applies a function of the module representation C to the output received at the input node of the module representation C to generate an output at an output node of the module representation C.

Continuing with the example the output at the output node of the module representation C is forward propagated by the test bench via the fabrics and to an input node of the module representation F. The test bench applies a function of the module representation F to the output receive at the input node of the module representation F to generate an output at an output node of the module representation F. The output at the output node F is forward propagated as a test output by the test bench via the I O module representation C to the comparator .

It should be noted that in one embodiment as indicated by the dashed line in the forward propagation from the module representation A via the module representations D E B C and F is an example of a first performance scenario model or an application scenario model. In this embodiment as indicated by the dotted line in the forward propagation from the module representation E via the module representations B and C to the module representation F is an example of a second performance scenario model or an application scenario model.

The comparator compares the test outputs received from the I O module representation C with corresponding expected outputs that are parsed by the comparator from the events files to generate a result e.g. test fail test pass etc. For example upon determining that a first one of the test outputs received from the I O module representation C matches the expected output of the event file A or are within a corresponding pre determined threshold of the expected output and upon determining that a second one of the test outputs received from the I O module representation C matches an expected output within the event file B or are within a corresponding pre determined threshold of the corresponding expected output the comparator determines that both the first and second performance scenario models passed a test. On the other hand upon determining that the first test output does not match or is not within the pre determined threshold of the expected output of the event file A the comparator determines that the first performance scenario model failed a test and upon determining that the second test output does not match or is not within the pre determined threshold of the expected output of the event file B the comparator determines that the second performance scenario model failed a test.

In an embodiment when both the first and second performance scenario models pass a test the SoC scenario models pass a test. In one embodiment when one or both the first and second performance scenario models fail a test the SoC scenario models fail a test.

In one embodiment a test output corresponds to an expected output when both the test output and the expected output have an event ID. For example the test file generation module generates the one or more events files which include event IDs for each expected output. Also the test file generation module generates the one or more test files which include the event IDs. When a scenario model is executed within a test bench one of the event IDs is generated and then sent with a test output having the event ID to the comparator . The comparator determines the corresponding expected output when the event ID received from the test bench matches that of expected output. In an embodiment each event ID is mapped to a scenario model by the processor .

In one embodiment the comparator determines which scenario model to execute based on an event ID of the scenario model. For example the comparator randomly identifies an event ID mapped to a scenario model and sends a signal to the test bench including the event ID for execution of the scenario model in the test bench.

In an embodiment the comparator is executed by a processor other than the processor and or a processor that executes a test bench. This saves CPU cycles by offloading result checks to the comparator . In one embodiment the one or more events files are stored in a memory device other than a memory device that stores a test bench and or a memory device that stores the one or more test files .

In one embodiment one or more test files described herein store a variety of information e.g. a sequence in which register operations are performed a sequence in which IP blocks are driven memory addresses that are to be used to perform a test functions performed by components of an SoC to which a test is to be applied a test bench identifier that identifies a test bench used to test the SoC a manner of logging messages regarding passage or failure of the test a manner of checking data etc.

In one embodiment a number of test files are generated in a manner described above for different test benches and for different SoCs. The generation of the test files allows for easy re use of the test files.

In an embodiment the SoC scenario models mimic a hierarchy of services that are provided by an operating system e.g. a Linux operating system an Android operating system a Windows operating system a Unix operating system a Chromium operating system an OS X operating system etc.

In one embodiment the comparator generates one or more debug messages that indicate a result of a comparison between a test output and an expected output. For example upon determining that a test output does not match a corresponding expected output the comparator generates a message indicating the same or that a test failed.

In an embodiment the comparator stores a debug message within one or more files. For example the comparator stores a message indicating that a scenario model of a file failed a test below or adjacent to the scenario model.

In one embodiment a comparison performed by the comparator is performed by the test bench instead of by the comparator . In this embodiment expected outputs that are within the events files are instead stored within the test files . For example an expected output of a scenario model is stored within the test file A that includes the scenario model. As another example an expected output of a scenario model is stored within the test file B that includes the scenario model.

In one embodiment the SoC scenario models include memory allocation of one or more memory devices or of one or more memory device module representations. For example when data is accessed from a memory device module representation and or is written to a memory device module representation and a limited number of memory device module representations are available for use with the SoC scenario models one or more of the memory device module representations are assigned to an IP block for writing data or for reading data.

In an embodiment the SoC scenario models include handling of interrupts. For example when a first one of the SoC scenario models is being executed a second one of the SoC scenario models interrupts the first SoC scenario model. The processor executes the second SOC scenario model before finishing execution of the first SOC scenario model.

In one embodiment the first SoC scenario model is executed by a first processor e.g. the processor and the second SoC scenario model is executed by a second processor of the computing device.

In an embodiment a first computer thread executed by the processor includes the first SoC scenario model and a second computer thread executed by the processor includes the second SoC scenario model.

In one embodiment the SoC scenario models include management of I Os and I O module representations. For example an I O module representation is used to transfer test output and or expected output. When a limited number of I O module representations is available for use with the SoC scenario models the I O module representations are managed based on a time of transfer of outputs. To further illustrate a module representation waits to use an I O module representation before another module representation completes sending or receiving an output via the I O module representation.

In an embodiment the SoC scenario models include debugging of an SoC or of modules within a test bench. The debugging is performed based on a result of a test. For example when a test fails the processor executes the SoC scenario models to debug a module within a test bench. The debugging is performed to fix the module to further facilitate passing of the test by the module.

In an embodiment one of the event files stores an expected output of a scenario model and one of the test files stores the scenario model. In this embodiment another one of the event files stores another expected output of another scenario model and another one of the test files stores the other scenario model.

In some embodiments the test file generation module and the compiler are executed by a processor that executes the test bench . For example instead of the processor executing the test file generation module and another processor executing the compiler both the test file generator module and the compiler are executed by a processor that executes the test bench .

It should be noted that in one embodiment the test file generation module is executed by a processor the compiler is executed by another processor and the test bench is executed by yet another processor.

The UVM test bench includes module representations which are examples of module representations of components of a digital camera. The module representations include a CPU module representation a memory device module representation an image processor module representation a camera module representation a display controller module representation and a secure digital SD card module representation. The module representations further include fabrics and and a system and power control module representation. The system and power control module representation provides power to the image processor module representation the memory device module representation the CPU module representation the SD card controller module representation the display controller module representation and the camera module representation and manages the provision of power. It should be noted that the CPU module representation is an example of the module representation A the memory device module representation is an example of the module representation B the image processor module representation is an example of the module representation C the camera module representation is an example of the module representation D the display controller module representation is an example of the module representation E the SD card module representation is an example of the module representation F and the system and power control module representation is an example of the module representation G .

In an embodiment a module representation includes sub module representations and sub links between the sub module representations. For example the camera module representation includes an analog to digital A to D converter sub module representation a gain amplifier sub module representation and a clock sub module representation. A digital end of the A to D converter sub module representation is connected via a sub module link to the gain amplifier sub module representation which is connected via a link to the CPU module representation and via another link to the display controller module representation. An analog end of the A to D converter sub module representation is connected via a sub link to a charge coupled device CCD . Moreover the clock sub module representation is connected via a link to the CCD to provide a clock signal to the CCD. The CCD converts light energy e.g. photons etc. into electrical energy e.g. electrons etc. The A to D converter performs a function of converting analog data that is received from the CCD into a digital signal that includes digital data. The gain amplifier sub module representation performs a function of amplifying a magnitude of the digital signal. In an embodiment the clock sub module representation performs functions of generating and providing a clock signal to the camera module representation and or to other module representations that are connected to the camera module representation.

In one embodiment the comparator is connected to one or more of the module representations A B C D E F and G that are being executed within a test bench to provide one or more stimulus to the one or more module representations and or to receive one or more test results from the one or more module representations. For example the comparator is connected to the processor module representation and or the memory device module representation and or the CPU module representation and or the SD card controller module representation or the display controller module representation and or the camera module representation and or the system and power control module representation. To further illustrate a test file includes a scenario model to be executed by one or more module representations of a test bench. The one or more module representations of the test bench are programmed to perform a function. The function indicates that the one or more module representations provide a signal to the comparator to receive data from the comparator . Upon receiving the signal the comparator provides the data to the one or more module representations of the test bench connected to the comparator to facilitate execution of the scenario model within the test bench. The scenario model is executed to test the one or more module representations. The comparator receives a test output generated by the module representations based on the scenario model within a test file and compares the test output with an expected output.

In an embodiment the comparator receives the test output from a memory location of a memory device of the computing device. The test output is stored in the memory location by one or more module representations of the test bench. A processor that executes the test bench is coupled to the memory device.

In one embodiment the comparator receives the test output from a memory queue of one or more memory devices of the computing device. The test output is stored in the memory queue by one or more module representations of the test bench. To illustrate during an emulation stage of a project which is further described below the comparator requests at pre determined intervals a processor executing the test bench to pause execution of the test bench to read the test output from the memory queue at the pre determined intervals. The processor that executes the test bench is coupled to the one or more memory devices having the memory queue.

In an embodiment the comparator receives the test output from a memory queue within an I O interface e.g. a UART etc. between the comparator and a processor that executes the test bench. The test output is stored within the memory queue of the I O interface by one or more module representations of the test bench. The processor that executes the test bench is coupled to the I O interface.

In one embodiment the comparator receives the test output e.g. messages etc. from a log file stored in a memory device that is coupled to a processor executing the test bench. The test output is stored in the log file by one or more module representations of the test bench. The test output is post processed by the comparator after execution of the test bench is completed to generate the test output. The processor that executes the test bench is coupled to the memory device.

Moreover another one of the application scenario models is illustrated by solid lines. The application scenario model is that of retrieving an image from the SD card to display on the display device. The SD card controller module representation reads via an I O module representation the encoded image data that is stored in the SD card. The SD card controller module representation sends the encoded image data to the image processor module representation via the fabrics and . The image processor module representation decodes the encoded image data and provides the decoded image data to the memory device module representation for storage. The display controller module representation reads the decoded image data from the memory device module representation via the fabrics and and sends the decoded image data via an I O module representation to the display device. The display device receives the decoded image data and renders the decoded image data for displaying an image.

A second one of the application scenario models is reading the encoded image data from the SD card for display of an encoded image on the display device. In one embodiment instead of reading the encoded image data decoded image data that is stored in the SD card is read. The SD card controller module representation reads the encoded image data from the SD card. The display controller obtains the encoded image data from the SD card controller module representation and provides the encoded image data to the display device for display of the encoded image on the display device.

A third one of the application scenario models is capturing image data and encoding the image data for storage in an SD card. A CCD captures image data by converting photons into electrons. A camera module representation processes e.g. converts from an analog form into a digital form provides a gain etc. to the image data that is captured and provides the processed image data to the image processor module representation. The image processor module representation encodes the processed image data to generate encoded image data. The SD card controller module representation obtains the encoded image data from the image processor module representation and writes the encoded image data to the SD card.

A fourth one of the application scenario models is capturing image data and storing the image data. The CCD module representation captures the image data. The camera module representation processes the image data that is captured to generate processed image data. The SD card controller module representation obtains the processed image data from the camera module representation and writes the processed image data to the SD card.

A fifth one of the application scenario models is capturing image data and displaying the image data. The CCD module representation captures the image data. The camera module representation processes the image data that is captured to generate processed image data. The display controller module representation accesses the processed image data from the camera module representation and displays the processed image data as an image on the display device.

The power management application scenario is generated by the processor based on a use application scenario to be tested by the UVM test bench . For example upon determining by the processor that the use application scenario does not involve using the camera module representation the processor determines that power is not to be provided by the system and power control module representation to the camera module representation. The provision of power to the camera module representation is not made a part of the power management application scenario by the processor . Moreover the processor determines that the use application scenario involves decoding imaged data or encoding image data or reading image data from the SD card or writing image data to the SD card or displaying an image. Upon determining that the use application scenario involves decoding imaged data or encoding image data the processor determines that the power management application scenario involves provision of power by the system and power control module representation to the image processor module representation. Similarly upon determining that the use application scenario involves reading image data from the SD card or writing image data to the SD card the processor determines that the power management application scenario involves provision of power by the system and power control module representation to the SD card controller module representation. Moreover upon determining that the use application scenario involves displaying an image the processor determines that the power management application scenario involves provision of power by the system and power control module representation to the display controller module representation.

The application scenario model includes the driver scenario models A B C D E and F and links between the driver scenario models. For example the application scenario model includes the driver scenario models A B C D E and F a link between the model A and the model B a link between the model B and the model C a link between the model C and the model D a link between the model D and the model E and a link between the model E and the model F.

It should be noted that the sub module representation A receives a expected output at an output node of the driver scenario model A. The sub module representation A is executed by the processor to generate an intermediate output to be provided to the sub module representation B for further processing and to generate another intermediate output to be provided to the sub module representation D for further processing. In this manner the expected output at the output node of the driver scenario model A is back propagated via the driver scenario model A to generate one or more test inputs at one or more input nodes of the driver scenario model A. The test input to driver scenario model A is the expected output of driver scenario model B. The expected outputs are provided to a sub module representation A of the driver scenario model B for further processing and back propagation. In this manner the expected output at the output node of the driver scenario model A is propagated via the driver scenario models B C D E and F to generate one or more test inputs at one or more input nodes of the driver scenario model F.

It should further be noted that the module representations B C D E F and G of the UVM test bench and connections between the module representations form a group .

The application scenario model is a part of an SoC scenario model which is an example of one of the SoC scenario models .

The test file generation module identifies the driver scenario model from a compiled file and provides the driver scenario model to a UVM test bench . The UVM test bench includes an IP block that is coupled to an I O module representation and to another I O module representation . It should be noted that in one embodiment an I O IP block is a bus verification intellectual property VIP . In an embodiment a VIP provides an abstraction of a stimulus and monitoring used to verify functioning e.g. operability etc. of a module representation. Each of the module representations A B C D E F and G is an example of the IP block.

In one embodiment instead of providing the driver scenario model to the UVM test bench the test file generation module generates a file that includes the driver scenario model and the file is compiled to generate a compiled file. The compiled file is provided to the UVM test bench for execution.

The IP block is tested in the UVM test bench when the processor applies the driver scenario model to the UVM test bench . For example a stimulus is provided to the IP block via the I O module representation . The UVM test bench is executed by the processor to apply a function of the IP block to the stimulus to generate a test output. The test output is retrieved via the I O module representation and compared with an expected output to determine whether the IP block passed a test. The UVM test bench is executed by the processor for testing the driver scenario model at an IP stage of the project.

In one embodiment the scenario model is a portion of the scenario model and is extracted by the test file generation module from the scenario model .

The SoC scenario model is identified from a compiled file by the test file generation module and is provided by the test file generation module to a UVM test bench . The UVM test bench is similar to the test bench except that in the UVM test bench the CPU module representation is replaced with a bus VIP. In one embodiment the bus VIP is less costly to build than the CPU module representation of the UVM test bench . Also the bus VIP allows for greater throughput faster simulation and easier debug than that allowed by the CPU module representation .

In one embodiment instead of providing the SoC scenario model to the UVM test bench the SoC scenario model is identified from a compiled file by the test file generation module to generate a test file and the test file is compiled by a compiler to generate a compiled file. The compiled file generated from the test file is provided by the compiler to the UVM test bench .

In an embodiment the bus VIP provides a lesser amount of functionality compared to that of the CPU module representation in the UVM test bench and the bus VIP is easier to construct and use compared to construction and use of the CPU module representation. The bus VIP is connected to the module representation B and to the fabric .

The SoC scenario model identified from a compiled file by the test file generation module and provided to the UVM test bench is also provided to the test bench . It should be noted that the UVM test bench is applied to the SoC scenario model at a subsystem stage of the project and the UVM test bench is applied to the SoC scenario model at an SoC stage of the project. It should be noted that the IP the subsystem and the SoC stages are simulation stages of the project.

In one embodiment instead of providing the SoC scenario model to the UVM test bench the compiled file generated based on the test file that is created by the test file generation module and provided to the UVM test bench is also provided to the test bench .

The vertical integration is provided when the same driver scenario model is applied at the IP subsystem and SoC levels of the project. Moreover the vertical integration is provided when the same SoC scenario model is applied at the subsystem and SoC levels of the project.

Also the SoC scenario model is identified from a compiled file by a test file generation module and the SoC scenario model is provided by the test file generation module to an emulator of the post silicon SoC. The test file generation module is executed by the processor or by another processor. The emulator is tested using the SoC scenario model .

In one embodiment instead of providing the SoC scenario model to the emulator the compiled file that includes the SoC scenario model is parsed by a test file generation module to generate a test file and the test file is compiled by the test file generation module to generate a compiled file. The compiled file generated from the test file is provided to the emulator of the post silicon SoC

In one embodiment the emulator is a hardware e.g. silicon chip silicon chip with integrated circuits etc. or software or both that duplicates the functions of the post silicon SoC. When the emulator is hardware it is controlled by the processor or by another processor. In this embodiment a behavior of the emulator closely resembles that of the post silicon SoC. The testing of the emulator is performed using the SoC scenario model at the emulation stage of the project.

Moreover the scenario model that is identified by the test file generation module from a compiled file is provided by the processor to a prototype of the post silicon SoC. In one embodiment the prototype of the post silicon SoC is more customized to the post silicon SoC than the emulator. For example the emulator is commercially available and has a limited number of sizes of memory devices and the post silicon SoC is built in a lab with a higher variety of sizes of memory devices. As another example the emulator has buses that have a limited number of speeds of transfer of data and the prototype includes custom designed buses that operate at a higher number of speeds of data transfer. The prototype is tested using the same scenario model used to test the emulator. The testing of the prototype using the SoC scenario model is performed at a prototyping stage of the project. In an embodiment during the prototyping stage instead of the prototype the post silicon SoC is used directly to enable the user to test the post silicon SoC at a real world operating frequency of the post silicon SoC with real world stimulus.

Furthermore the SoC scenario model used to test the emulator and the prototype is also used to test the post silicon SoC. The testing of the post silicon SoC is performed using the SoC scenario model at a post silicon stage of the project.

In one embodiment instead of providing the SoC scenario model to the prototype of the post silicon Soc the compiled file that includes the SoC scenario model is parsed by the test file generation module to generate a test file and the test file is compiled by the test file generation module to generate a compiled file. The compiled file generated from the test file is provided to the prototype of the post silicon SoC.

In an embodiment instead of providing the SoC scenario model to the post silicon Soc the compiled file that includes the SoC scenario model is parsed by the test file generation module to generate a test file and the test file is compiled by the test file generation module to generate a compiled file. The compiled file generated from the test file is provided to the post silicon SoC. In one embodiment a scenario model that is used to test the emulator the prototype and the post silicon SoC is similar to a scenario model that is applied to the UVM test bench and to the UVM test bench except that the scenario model for the emulator the prototype and the post silicon SoC excludes expected outputs. The expected outputs are stored within a memory device of the emulator or the prototype or the SoC. In this embodiment the emulator is made of hardware or a combination of hardware and software.

In one embodiment a scenario model that is used to test the UVM test bench the emulator the prototype and the post silicon SoC is stored within a different test file for provision to each of the UVM test bench the emulator the prototype and the post silicon SoC. For example the SoC scenario model is stored within a test file that is provided to the UVM test bench the SoC scenario model is stored within another test file that is provided to test the emulator the SoC scenario model is stored within yet another test file that is provided to test the prototype and the SoC scenario model is stored within still another test file that is provided to test the post silicon SoC.

The horizontal integration is provided when the SoC scenario model is used to test the emulator the prototype and the post silicon SoC and the UVM test bench .

It should be noted that in one embodiment a re use of SoC scenario models at various stages of the project results in a structured approach to SoC function verification. For example each component of an SoC is individually tested and tested in conjunction with use of other components of the SoC. To further illustrate when each driver scenario model is individually tested each component of an SoC is individually tested at a software level and when each application scenario model is tested use of the component with one or more of remaining components of the SoC is tested at a software level.

In one embodiment the SoC scenario model includes a module representation of a processing function of a CPU and the processing function is performed by the bus VIP of the test bench or by the CPU module representation of the test bench .

In an embodiment the same direction of execution of a path is used within both the UVM test bench and the UVM test bench . For example a direction of execution of a path that is shown by the dashed line in is used in both the UVM test bench and the UVM test bench .

In one embodiment a test file is not generated by the test file generation module and is not provided to a UVM test bench e.g. the UVM test bench the UVM test bench etc. A VIP e.g. bus VIP I O VIP etc. of the UVM test bench is not able to execute a computer program e.g. a scenario model etc. but is able to follow instructions e.g. Assembly language instructions etc. The instructions are generated by the test file generation module based on a scenario model. For example an instruction includes reading a register writing to a register reading from a memory address moving data jumping to a memory address initiating a variable resetting a register enabling a module representation disabling a module representation changing a configuration of a module representation changing a configuration of a sub module representation changing a manner in which a sub module representation completes execution of its function etc. To further illustrate an instruction includes a function of a sub module representation. The instructions are received from the test file generation module by the VIP of the UVM test bench. Moreover the test file generation module does not generate an event file for providing to the UVM test bench. The VIP of the UVM test bench executes the instructions to generate a test result. The test result is received from the VIP by the test file generation module and a comparison of the test result with an expected output is performed by the test file generation module to determine whether an SoC passed a test based on a scenario model. The scenario model is constructed based on the SoC.

Comparatively in one embodiment a CPU of the UVM test bench receives a compiled file that includes the scenario model and executes the scenario model to generate a test output. The test output is compared by the comparator with an expected output of one of the events files to determine whether the SoC passed a test.

The SoC scenario model is provided within a compiled file to the test file generation module . The test file generation module parses the compiled file to generate a test file having the driver scenario model that includes use of the C module representation and the test file is compiled to test the driver scenario model in a UVM test bench which is an example of the UVM test bench . The test file excludes the remaining module representations A B E F G and H.

In one embodiment the test file generation module parses the compiled file to identify a scenario model which is provided to the UVM test bench for testing without generating a test file including the scenario model.

The test file that stores the scenario model is compiled by a compiler. The compiled test file is provided by the compiler to the UVM test bench for applying the scenario model .

In one embodiment instead of the compiled test file the scenario model is provided by the test file generation module to the UVM test bench for applying the scenario model .

Moreover the same compiled file that is provided to the UVM test bench is provided to the UVM test bench . Furthermore the one or more events files are generated by the test file generation module from the scenario model . One or more test outputs generated from the UVM test bench are compared by the comparator to corresponding one or more expected outputs to determine whether an SoC passed a test.

It should be noted that the same scenario model is used to generate test files for different test benches and .

In an embodiment the test file generation module generates different events files and different test files for different test benches. For example the test file generation module generates one or more test files for the test bench and generates one or more test files for the UVM test bench . Each test file for the test bench includes a scenario model that is executed within the test bench . Comparatively each test file for the UVM test bench includes a scenario model that is executed within the UVM test bench . As another example the test file generation module generates one or more event files for the test bench and generates one or more events files for the UVM test bench . Each events file for the test bench includes an expected output for a scenario model that is executed within the test bench . Comparatively each events file for the UVM test bench includes an expected output for a scenario model that is executed within the UVM test bench .

In one embodiment the use of the scenario model in the UVM test bench to generate one or more test outputs which are compared to corresponding expected outputs is an application of a performance scenario model. On the other hand use of the scenario model in the UVM test bench is an application of an application scenario model. It should be noted that in this embodiment there is no comparison of test outputs generated using the test bench with expected outputs to determine whether a performance constraint is achieved.

In one embodiment the SoC scenario models are used to test the emulator or the prototype instead of or in addition to testing the post silicon SoC. The SoC scenario models are provided to the test file generation module which generates a test file for each of the SoC scenario models . In one embodiment a test file stores any number of scenario models.

The test file generation module generates one or more test files and each test file stores one of the SoC scenario models and or one or more stimulus associated with the SoC scenario model. Moreover the test file generation module identifies one or more expected outputs from the SoC scenario models in a manner similar to that described above with reference to . The test file generation module generates one or more events files that include the expected outputs identified from the SoC scenario models . It should be noted that in one embodiment the test file generation module performs the operations of concurrent scheduling memory allocation interrupt handling I O management debugging and or result checking on the SoC scenario models to generate the one or more test files and or the one or more events files .

The one or more events files are provided by a processor of a host system to the comparator which is also executed by the processor of the host system . The comparator parses the one or more events files to identify one or more expected outputs. Examples of the host system include a desktop computer a laptop computer a computing device a tablet a smart phone a smart television etc. In one embodiment the host system is implemented on a circuit board.

In one embodiment the compiled file includes one or more stimulus for stimulating an input node of an integrated circuit of the SoC .

The one or more test files are provided to the compiler . In one embodiment the compiler is executed by the processor of the host system . In an embodiment the processor is the processor of the host system .

The compiler generates a compiled file from the one or more test files and provides the compiled file to an SoC . When the compiled file is downloaded to the SoC the SoC scenario models are executed by the processor of the host system . The execution of the SoC scenario models include applying the one or more stimulus to one or more input nodes of an integrated circuit of the SoC . The one or more stimulus are received within the compiled file.

In one embodiment the one or more stimulus are received from the comparator via a debug access . In this embodiment the one or more stimulus are included within the one or more events files by the test file generation module .

In one embodiment an I O is an interface that has logic to interpret an address of an integrated circuit of the SOC and to interpret an address of the comparator . In one embodiment an I O converts serial data to parallel data and vice versa.

The application of the SoC scenario models to the SoC generates one or more test outputs. The one or more test outputs are provided by the processor of the host system via the debug access to the comparator . The comparator compares the one or more test outputs with corresponding one or more expected outputs to determine whether the SoC passed a test. For example upon determining that one of the test outputs does not match or is not within the pre determined threshold of a corresponding one of the expected outputs the comparator determines that the SOC failed the test. As another example upon determining that one of the test outputs matches a corresponding one of the expected outputs or is within the pre determined threshold of a corresponding one of the expected outputs the comparator determines that the SOC passed the test.

It should be noted that in one embodiment the SOC is located outside the host system . For example the SOC connected to the host system via a USB port or a parallel port or a serial port etc. of the host system .

In one embodiment the scenario models include concurrent scheduling e.g. execution etc. of two or more scenario models. For example the processor concurrently executes two application scenario models of the scenario models . In an embodiment the scenario models include concurrent scheduling of two or more driver scenario models. In one embodiment the scenario models include concurrent scheduling of two or more performance scenario models.

In an embodiment the scenario models include concurrent scheduling of an application scenario model and a driver scenario model. In this embodiment execution of the driver scenario is not a part of execution of the application scenario model.

In one embodiment the scenario models include concurrent scheduling of a performance scenario model and an application scenario model. In this embodiment execution of the application scenario model is not a part of execution of the performance scenario model.

In an embodiment the scenario models include concurrent scheduling of a performance scenario model and a driver scenario model. In this embodiment execution of the driver scenario model is not a part of execution of the performance scenario model.

In one embodiment an application scenario model is similar to a performance scenario model except that there is no comparison between a test output of the application scenario and an expected output of the application scenario model. In an embodiment a driver scenario model tests a single integrated circuit and or a single module representation.

In one embodiment scheduling is concurrent when scheduling is performed at the same time or substantially at the same time e.g. within a pre determined time range etc.

In one embodiment the comparator is connected to a part of the SoC to provide a stimulus to the part and or to receive a test result from the part. For example the comparator is connected to the CPU and or the memory device and or the image processor and or the fabrics and or the camera and or the display controller and and or the SD card controller or a system and power controller. To further illustrate a test file includes a scenario model to be executed by one or more parts of the SoC . The one or more parts of the SoC are programmed by the scenario model to perform one or more corresponding functions. The one or more corresponding functions indicate that the one or more parts provide a signal to the comparator to receive data e.g. a stimulus etc. from the comparator . Upon receiving the signal the comparator provides the data to the one or more parts of the SoC connected to the comparator to facilitate execution of the scenario model by a test bench which includes the one or more parts. The scenario model is executed to test the one or more parts of the SoC . The comparator receives a test output generated by the one or more parts of the SoC based on the scenario model within a test file and compares the test output with an expected output.

In an embodiment a test file includes a condition for execution of an arbitrary operation. An example of the condition includes a change in an environmental condition e.g. temperature pressure etc. surrounding an SoC. The arbitrary operation is stored within an event file that corresponds to the test file. An example of an arbitrary operation includes an operation that is not executed using a scenario model which is stored within the test file. To illustrate an arbitrary operation includes generating an indication to disconnect a wire on a circuit board or resetting a dual in line memory module DIMM on a circuit board etc. The DIMM is an example of an SoC. The arbitrary operation is generated from a computer program code that is written by the user. Moreover the condition within the test file is also generated from a computer program code that is written by the user. The processor of the host system determines whether the condition is satisfied. Upon determining that the condition is satisfied the arbitrary operation is accessed by the processor of the host system from the events file and executed to determine an output. In an embodiment the output is provided to the user e.g. displayed via a display device of the host system via speakers of the host system etc. to indicate to the user to perform a manual operation e.g. disconnecting a wire on a circuit board etc. In one embodiment the processor of the host system sends a signal to the DIMM to reset the DIMM.

The circuit board is further connected via an in circuit emulator e.g. a joint test action group JTAG emulator etc. and a debugger interface to a second USB port of the computing device . A compiled file that includes the SoC scenario models is loaded from the computing device to the SoC via the second USB port of the computing device the debugger interface and the in circuit emulator . The SOC is tested using the SoC scenario models to generate one or more test outputs. The test outputs are provided via the UART and the first USB port to the computing device .

In one embodiment a compiled file that includes the SoC scenario models is loaded from the computing device to the SoC via the first USB port and the UART .

The test outputs are provided to the comparator . The comparator provides the test outputs to a graphical processing unit GPU of the computing device for display of one or more of progress bars PB PB and PBz on a portion A of a display screen of the computing device where z is an integer greater than zero.

In one embodiment eight progress bars are displayed on the display screen of the computing device . Four of the eight progress bars show progress of execution of four threads on one CPU e.g. the processor etc. of the computing device and the remaining four progress bars show progress of execution of four threads on another CPU of the computing device . When a first thread includes a driver scenario model that is next in sequence to a driver scenario model of a second thread the first thread is a consumer thread and the second thread is a producer thread. Moreover another portion B of the display screen displays a portion of a computer program code of one of the test files or a portion of a compiled file generated from the test file.

In an embodiment a thread is a subset e.g. a smallest sequence etc. of computer instructions that is managed independently by a scheduler. One or more threads are part of a process and share resources e.g. time share resources time division multiplex resources etc. and different processes do not share the resources. Examples of resources include memory devices addresses within one or more memory devices etc. In one embodiment threads of a process share instructions e.g. operands operands and data etc. of the process.

In one embodiment when a test is executed on an SoC or the prototype of the SoC or the emulator of the SoC the SoC or the emulator or the prototype is not able to communicate with the comparator . An application programming interface API e.g. a C API a C API etc. is applied by the computing device between the SoC or the emulator or the prototype and the comparator to enable the SoC or the emulator or the prototype and the comparator to communicate with each other.

In an embodiment a checking protocol e.g. checksum cyclic redundancy check CRC etc. is performed by Test File Generation Module Si on expected output data to be generated by the SoC to generate a first result which is stored in Events file . The checking protocol is applied on the actual output data by a processor of the SoC to generate a second result. The first and second results are compared with each other by the computing device to determine whether there is a match between the first and second results. Upon determining that the first and second results match the computing device determines that the SoC passed a test and on the other hand upon determining that the first and second results do not match each other the computing device determines that the SoC did not pass the test. In one embodiment the second result is stored within a memory device of the SoC for providing to the computing device via the UART . In an embodiment the second result is provided to the computing device via the UART without storing the second result within the memory device of the SoC to save memory device space on the SOC .

In one embodiment data is received in an order by the computing device from multiple channels that are coupled to a component of an SoC. The order of data is checked by a processor of the computing device against a pre stored order to determine whether the data is received according to the pre stored order.

The processor or another processor determines that expected outputs of the test include that the vehicle keeps moving forward or that the vehicle stops. The one or more inputs of the scenario model are constrained from execution by the processor based on the expected outputs of the scenario model. For example the one or more inputs are limited to an ignition of the vehicle being on the vehicle being in a drive gear and gas paddle being applied to achieve the expected output that the vehicle keeps moving forward. To test the vehicle the vehicle is driven in the drive gear the ignition is on and the gas paddle is applied. In this example the one or more inputs do not include the ignition being off the vehicle being in park the vehicle being in a reverse gear and applying a brake to the vehicle. As another example the one or more inputs are limited to an ignition of the vehicle being on and a brake paddle being applied to achieve the expected output that the vehicle stops. To test the vehicle the ignition is on and the brake paddle is applied. In this example the one or more inputs do not include the applying the gas paddle to the vehicle.

The one or more inputs generated after applying constraints are then used as one or more stimulus by the processor or by another processor to test the vehicle for overheating. The one or more stimulus are used to generate one or more test outputs which are compared to the expected outputs. For example when a test output is that the vehicle moves forward for a period of time of performance of the test the vehicle passes the test. As another example when a test output is that the vehicle has stopped during performance of the test the vehicle fails the test.

Each driver scenario model and includes sub modules. For example the driver scenario model includes a configuration sub module that is executed by the processor to configure the driver scenario model . The configuration of the driver scenario model is done to achieve a quality of encoding or decoding image data. Moreover the configuration of the driver scenario model is done to enable or disable functionality of the driver scenario model . As another example the driver scenario model includes a configuration sub module that is executed by the processor to configure the driver scenario model . The configuration of the driver scenario model is done to achieve a quality of image data that is stored in an SD card by the driver scenario model . Moreover the configuration of the driver scenario model is done to enable or disable functionality of the driver scenario model .

As yet another example the driver scenario model includes a completion sub module. The completion sub module is executed to determine whether a function executed by the driver scenario model is completed. The completion is indicated by the driver scenario model either by waiting for an interrupt or by changing a status of a status bit. In one embodiment the completion is sequentially followed by or preceded by checking of a memory device module representation that is connected to the driver scenario model or an I O module representation that is connected to the driver scenario model .

As another example the driver scenario model includes a completion sub module. The completion sub module is executed to determine whether a function executed by the driver scenario model is completed. The completion is indicated by the driver scenario model either by waiting for an interrupt or by changing a status bit. In one embodiment the completion is sequentially followed by or preceded by checking of a memory device module representation that is connected to the driver scenario model or an I O module representation that is connected to the driver scenario model .

As another example the driver scenario model includes a check sub module. The check sub module is executed to determine whether a memory device module representation of the driver scenario model is to be checked or a register module representation of the driver scenario model is to be checked or and I O module representation of the driver scenario model is to be checked. As another example the driver scenario model includes a check sub module. The check sub module is executed to determine whether a memory device module representation of the driver scenario model is to be checked or a register module representation of the driver scenario model is to be checked or and I O module representation of the driver scenario model is to be checked.

As yet another example each of the driver scenario models and includes a get source module that is executed by the processor . The get source module of the driver scenario model is executed to invoke functionality of the driver scenario model .

It should be noted that a quality of image data stored by the driver scenario model in an SD card provides a constraint to a quality of encoding or decoding performed by the driver scenario model .

In one embodiment a driver scenario model is accessed instead of being generated from a library of driver scenario models e.g. C code sequences etc. by the processor . In an embodiment a driver scenario model is accessed from the library and then customized by the processor or by the user to generate a semi customized driver scenario model. In one embodiment a driver scenario model is generated by the processor or by the user to generate a customized driver scenario model.

In an embodiment an application scenario model is formed by a combination of the driver scenario models and . Constraints are applied across the driver scenario models and to generate the application scenario model. The constraints are applied to achieve an expected outcome to further generate a stimulus.

It should be noted that each of quality sub module representation mode sub module representation and completion sub module representation is an example of a decision point. Each decision at a decision point is made by the processor to lead to one or more paths in a data flow e.g. a scenario model etc. An outcome of a decision is a vertex e.g. an output etc. For example each of high low a b interrupt and poll is an example of a vertex.

Moreover a selection of a vertex either by the processor or by the user via an input device results in a constraint in that another vertex cannot be reached during execution of a scenario model. For example when a selection is received that the driver scenario model is to complete its execution based on an interrupt the driver scenario model cannot complete execution via polling. As another example when a selection is received that the driver scenario model is to store image data having high quality the driver scenario model cannot store image data having a low quality. Such graphical based constraints result in rapid solving of complex scenario models compared to algebraic constraints.

Parameters of a display device provide a constraint to the video processor module representation. Examples of the parameters of a display device include a display resolution of the display device a size of the display device a processing speed of a GPU of the display device a size of a memory device of the display device etc. For example an aspect ratio of the display device controls a size of an image that is displayed on the display device . The size of the image is achieved by processing performed by the video processor module representation. As another example a display resolution of the display device controls an image resolution of an image that is displayed on the display device .

Moreover parameters of the video processor module representation constrain a USB controller module representation. Examples of parameters of the video processor module representation include a video resolution an image size a rate with which video data is encoded or decoded a rate at which a size of a video is changed etc. Examples of parameters of the USB controller module representation include a speed of transfer of image data a speed of transfer of video data serial transfer of data parallel transfer of data etc.

The parameters of the video processor module representation control the parameters of the USB controller module representation. For example when a rate of encoding or decoding video data is greater than a pre determined limit a rate of transferring the video data from the USB controller module representation to the video processor module representation is greater than a pre determined value. As another example when a rate of encoding or decoding video data is less than the pre determined limit a rate of transferring the video data from the USB controller module representation to the video processor module representation is less than the pre determined value.

The system also illustrates various application scenario models. One of the application scenario models includes receiving video data from the SD card controller module representation and processing the video data. The processing of the video data is performed by the video processor module representation. Furthermore the processed video data is sent by the video processor module representation to the display device which renders the video data to display a video.

Another one of the application scenario models includes receiving image data from the SD card controller module representation and encoding or decoding the image data. The encoding or decoding is performed by the image processor module representation. Furthermore the decoded or encoded image data is sent by the image processor module representation to a display device which renders the image data to display an image.

Yet another one of the application scenario models includes receiving video data from the USB controller module representation and processing the video data. For example the video data is received via a USB port module representation from a computer or a mobile device e.g. a cell phone a smart phone a tablet etc. The processing of the video data is performed by the video processor module representation. Furthermore the processed video data is sent by the video processor module representation to the display device which renders the video data to display a video.

Another one of the application scenario models includes receiving image data from the USB controller module representation and encoding or decoding the image data. The encoding or decoding is performed by the image processor module representation. Furthermore the decoded or encoded image data is sent by the image processor module representation to the display device which renders the image data to display an image.

The constraint regarding the quality of encoding or decoding is transferred from the image processor module representation to the memory device module representation MEM. The constraint regarding the quality of encoding or decoding is retrieved from the memory device module representation MEM by a configuration sub module representation of the camera module representation. Based on the retrieved determination the configuration sub module representation of the camera module representation is executed by the processor or by another processor to determine that a quality of processing done by the camera module representation will be lower than a predetermined quality. Examples of the processing done by the camera module representation are described as functions performed by the camera module representation above. The quality of processing is applied to an image captured by the CCD. The constraint regarding the quality of encoding or decoding retrieved from the memory device module representation MEM by the configuration sub module representation of the camera module representation constrains the quality of processing performed by the camera module representation.

In one embodiment the configuration sub module representation of the image processor module representation is executed to determine that a quality of encoding or decoding will be greater than the pre set value. The determination is transferred from the image processor module representation to the memory device module representation MEM. The determination is retrieved by the configuration sub module representation of the camera module representation. Based on the retrieved determination the configuration sub module representation of the camera module representation is executed by the processor or by another processor to determine that a quality of processing done by the camera module representation will be greater than a pre determined quality.

As another example the performance scenario model includes a constraint that the configuration sub module of the image processor module representation be configured to encode or decode in mode a. Examples of a mode of encoding or decoding image data include a deferred mode in which image data is encoded or decoded after a pre determined time period a current mode in which image data is encoded or decoded as soon as the image data is stored in a memory device module representation etc.

The constraints regarding completion of execution of the image processor module representation the mode of operation of the image processor module representation and a quality of encoding or decoding by the image processor module representation are stored within the memory device module representation MEM. The constraints stored within the memory device module representation MEM are used to constrain configuration and or completion of an operation of the camera module representation. For example the constraint regarding the interruption of the image processor module representation triggers a constraint within the camera module representation. The constraint triggered includes that when a completion sub module of the camera module representation is executed by the processor or by another processor the camera module representation is interrupted by another driver scenario model. As another example the constraint regarding the quality of encoding or decoding by the image processor module representation triggers a constraint within the camera module representation. The constraint triggered includes that the configuration sub module of the camera module representation be configured to process image data with a quality that is greater than a pre determined quality.

As yet another example the constraint regarding the mode of encoding or decoding by the image processor module representation triggers a constraint within the camera module representation. The constraint triggered includes that the configuration sub module of the camera module representation be configured to process image data in a mode a. Examples of a mode of processing image data using the camera module representation include a deferred mode in which image data is processed by the camera module representation after a pre determined time period or a current mode in which image data is processed by the camera module representation as soon as the image data is stored in a memory device module representation etc.

The constraints of the camera module representation are used to define constraints of the CCD module representation.

Other examples of a constraint of a module representation include checking a memory of the module representation checking a register of the module representation checking an I O of the module representation enabling the module representation to perform an operation disabling the module representation from performing an operation etc.

In one application scenario model a driver scenario model in which the camera module representation processes image data is executed by the CPU. Then as indicated by a dashed arrow in the application scenario model the processed image data is encoded by a driver scenario model that includes the image processor module representation. The driver scenario model that encodes the processed image data is executed by the CPU. Thereafter as indicated by another dashed arrow in the application scenario the encoded image data is sent to a driver scenario model that includes the SD card controller module representation for writing to an SD card. The SD card controller module representation is executed by the CPU .

Moreover in another application scenario model a driver scenario model in which the SD card controller module representation reads image data from an SD card is executed by the CPU. Then as indicated by a solid arrow in the application scenario model the read image data is decoded by a driver scenario model that includes the image processor module representation. The driver scenario model that decodes the image data is executed by the CPU. Thereafter as indicated by another solid arrow in the application scenario the decoded image data is sent to a driver scenario model that includes the display controller module representation. The display controller module representation is executed by the CPU.

Furthermore in yet another application scenario a driver scenario model in which the SD card controller module representation reads image data from an SD card is executed by the CPU. Then as indicated by a dotted arrow in the application scenario the read image data is received by a driver scenario model that includes the display controller module representation for display on a display device.

It should be noted that each empty region between driver scenario models that are displayed in the graph is a cell. A cell indicates a time during which a driver scenario model is not being executed by the processor or by another processor.

It should also be noted that a timeline progresses along the graph vertically from top to bottom. For example a driver scenario model in which the SD card controller module representation reads image data from an SD card is executed simultaneously with e.g. at the same time etc. a driver scenario model in which the camera module representation processes image data. As another example image data is processed by the camera module representation during a time period in which image data is read by the SD card controller module representation. As yet another example a driver scenario model in which an SD card controller module representation reads image data from an SD card is executed simultaneously with e.g. at the same time at substantially the same time etc. another driver scenario model in which an SD card controller module representation reads image data from the same or another SD card. To further illustrate an SD card controller module representation reads data from a memory region e.g. a memory bank a set of memory addresses a set of consecutive memory addresses etc. of an SD card simultaneous with reading by another SD card controller module representation of data from a memory region of the same or another SD card.

In one embodiment simultaneous as used herein means during a time or at the same or substantially at the same time. For example two operations are performed simultaneously when one operation is performed during performed of the other operation. As another example two operations are performed simultaneously when one of the operations is performed within a pre determined time interval of initiating performance of another one of the operations and before the other one of the operations has finished execution.

It should further be noted that in one embodiment when a first CPU executes a driver scenario model that is next in sequence to a driver scenario model executed by a second CPU the first CPU is a consumer CPU and the second CPU is a producer CPU.

In one embodiment instead of one or more CPUs executing one or more scenario models execution of the scenario models is divided among multiple threads that are executed by one or more CPUs e.g. CPUs of a computing device CPUs of an SoC etc. As an example a driver scenario model of an application scenario model is scheduled by the processor to be executed within one thread and another driver scenario model of the application scenario model is scheduled by the processor to be executed within another thread. For example execution of driver scenario models encompassed within two application scenario models is split into execution of multiple threads by the processor . To further illustrate one of the driver scenario models is executed within a first thread and another one of the driver scenario models is executed within a second thread. As another example the driver scenario models that are executed by the CPU in are executed within a first computer thread the driver scenario models that are executed by the CPU in are executed within a second computer thread and the driver scenario models that are executed by the CPU in are executed within a third computer thread.

The division to be performed of a scenario model into multiple threads is designated within a test file or within multiple test files by the processor . For example the processor designates that a test file that includes multiple scenario models be divided into multiple test files and each of the multiple test files includes one or more driver scenario models of one or more of the scenario models. A sequence of execution of driver scenario models within a scenario model becomes a flow e.g. a schedule etc. when the scenario model is split between multiple threads or between multiple CPUs for execution during a test.

In one embodiment the processor designates e.g. identifies etc. in one or more test files a CPU or a thread that is to execute a driver scenario model of an application scenario model. For example the processor designates within a test file that a driver scenario model in which the camera module representation processes image data is to be executed by the CPU or within a computer thread and a driver scenario model for encoding processed image data is to be executed by the CPU or within a computer thread .

In an embodiment a CPU executes any number of driver scenario models or any number of application scenario models or any number of performance scenario models.

In one embodiment a memory device is allocated to a CPU and access to the memory device is blocked to other CPUs.

In an embodiment a memory device is allocated to a scenario model and access to the memory device is blocked to other scenario models.

In one embodiment the CPU is a master CPU that executes a driver scenario model first and the execution triggers one or more driver scenario models in one or more of the other CPUs and . In an embodiment execution of all of the CPU the CPU and CPU is controlled by a master CPU. In this embodiment the master CPU does not execute a driver scenario model and co ordinates an order of execution of a number of driver scenario models by the CPU CPU and CPU.

In an embodiment the CPU communicates with an IP block to perform a task e.g. a transaction a read transaction a write transaction an encoding operation a decoding operation a capturing image operation a displaying image operation etc. The CPU waits for the IP block to finish the transaction either by polling for a done bit or by waiting for an interrupt from the IP block. The CPU also waits for a result of the task from the IP block and then checks the result against an expected outcome which is stored in a memory device. The IP block is executed by another CPU.

In one embodiment a processing capability of the CPU is used by a large number of IP blocks. Each IP block executes a thread on the CPU and a task performed by one IP block is distinguished from a task performed by another IP block. In this embodiment one thread is mutex protected from another thread. For example a spinlock is used by each thread to determine whether a producer operation has finished execution. The thread determines whether the spinlock is available before initiating its own execution. The thread waits for the other thread to finish execution before its own execution. In an embodiment instead of the mutex protection a memory device is allocated to a thread for a pre set time or until the thread finishes execution.

In an embodiment processing capability of the CPU is used by a large number of IP blocks. Each IP block acts a state machine each of which emulates the behavior of a thread.

In an embodiment a number of the CPUs and is the same as a number of CPUs in an SoC. In one embodiment a number of threads executed by one or more of the CPUs and is the same as a number of threads executed within an SoC.

In one embodiment execution of a driver scenario model by a first thread generates a constraint. As a result of the constraint another driver scenario model cannot be executed by a second thread. In this embodiment both the threads are executed using the same CPU. In an embodiment both the threads are executed using different CPUs.

The processor splits memory addresses of one or more memory devices into multiple memory regions for use during a test of an SoC or a model of the SoC.

In one embodiments a manner in which memory addresses of one or more memory devices are to be split is designated in a test file. For example a test file is generated by the processor to include that memory addresses be split into the memory region the memory region and the memory region during a test in which a scenario model is executed.

In one application scenario model illustrated by solid arrows a driver scenario model that includes the SD card controller module representation is executed by the processor to read data from an SD card VIP and to further write the read data as a joint photographic experts group encoded image JPEG encoded image to a portion of the memory region . The data is written via a direct memory access DMA .

In another application scenario model illustrated by dashed arrows another driver scenario model that includes the image processor module representation is executed by the processor to retrieve the JPEG encoded image data from the portion of the memory region to decode the JPEG encoded image data to generate decoded image data and to provide the decoded image data as a raw image data for storage in the memory region . Moreover in the application scenario a driver scenario model that executes the image processor module representation obtains the raw image data from the portion of the memory region and encodes the raw image to generate encoded image data and provides the encoded image data as a JPEG encoded image data to a memory region .

In one embodiment the memory region is a range of addresses within the same memory device that includes the memory regions and or . In an embodiment the memory region three is a range of addresses within a different memory device from a memory device that includes the memory region . In one embodiment the memory region three is a range of addresses within a different memory device from a memory device that includes the memory region .

In yet another application scenario illustrated by minutely dashed arrows a driver scenario model that includes the display controller module representation retrieves the raw image data from the portion of the memory region and provides the raw image data to a display VIP for display of an image.

In another application scenario illustrated by dotted arrows a driver scenario model that includes the camera module representation obtains image data from a CCD VIP processes the image data and provides the processed image data to the memory region for storage as the raw image data .

In still another application scenario illustrated by the cross arrows a driver scenario model that includes the SD card controller module representation reads the JPEG encoded image data from the memory region and writes the JPEG encoded image data to an SD card VIP.

It should be noted that in one embodiment a number of the memory regions displayed in the graph is the same as a number of memory regions in an SoC. In an embodiment a number of the memory regions displayed in the graph is different than a number of memory regions that an SoC.

In an embodiment a memory device module representation is allocated to a thread and access of the memory device module representation is blocked to other threads until the thread finishes use of the memory device module representation.

In a second scenario model a display controller module representation obtains the decoded data from the image processor module representation and renders the decoded data to generate an image on a display device .

In a third scenario model a USB controller module representation retrieves the decoded data from the image processor module representation and transfers the decoded data to a USB port for further transfer to a device e.g. a computing device a mobile device an integrated circuit etc.

In a fourth scenario model the SD card controller module representation retrieves the decoded data from the image processor module representation and transfers the decoded data to an SD card for storage.

In a fifth scenario model the image processor module representation obtains data that is received by the USB controller module representation from the USB port. In the fifth scenario model the image processor module representation decodes the obtained data to generate decoded data. In the fifth scenario model the display controller module representation obtains the decoded data from the image processor module representation and renders the decoded data to generate an image on the display device .

A sixth scenario model is similar to the second scenario model except that the sixth scenario model is performed using the decoded data that is generated from the data received from the USB port.

Moreover a seventh scenario model is similar to the third scenario model except that the seventh scenario model is performed using the decoded data that is generated from the data received from the USB port.

An eighth scenario model is similar to the fourth scenario model except that the eighth scenario model is performed using the decoded data that is generated from the data received from the USB port.

In a ninth scenario model the camera module representation processes image data that is captured using a CCD. The image processor module representation retrieves the processed image data from the camera module representation and decodes the image data to generate decoded image data. The decoded image data is sent to the display controller module representation in a manner described above in the first scenario model.

A tenth scenario model is similar to the second scenario model except that the tenth scenario model is performed using the decoded data that is generated from the data received from the camera module representation.

Moreover an eleventh scenario model is similar to the third scenario model except that the eleventh scenario model is performed using the decoded data that is generated from the data received from the camera module representation.

A twelfth scenario model is similar to the fourth scenario model except that the twelfth scenario model is performed using the decoded data that is generated from the data received from the camera module representation.

In a thirteenth scenario model the SD card controller module representation reads data from an SD card or an SD card module representation. In the thirteenth scenario model the video processor module representation obtains the read data from the SD card controller module representation and processes the read data to generate processed data. In the thirteenth scenario model the display controller module representation obtains the processed data from the video processor module representation and renders the processed data to generate a video on the display device .

In a fourteenth scenario model the display controller module representation obtains the processed data from the video processor module representation and renders the processed data to generate a video on the display device .

In a fifteenth scenario model the USB controller module representation retrieves the processed data from the video processor module representation and transfers the processed data to a USB port for further transfer to a device e.g. a computing device a mobile device an integrated circuit etc.

In a sixteenth scenario model the SD card controller module representation retrieves the processed data from the video processor module representation and transfers the processed data to an SD card for storage.

In a seventeenth scenario model the video processor module representation obtains data that is received by the USB controller module representation from the USB port. In the seventeenth scenario model the video processor module representation processes the obtained data to generate processed data. In the seventeenth scenario model the display controller module representation obtains the processed data from the video processor module representation and renders the processed data to generate a video on the display device .

An eighteenth scenario model is similar to the fourteenth scenario model except that the eighteenth scenario model is performed using the processed data that is generated from the data received from the USB port.

Moreover a nineteenth scenario model is similar to the fifteenth scenario model except that the nineteenth scenario model is performed using the processed data that is generated from the data received from the USB port.

A twentieth scenario model is similar to the sixteenth scenario model except that the twentieth scenario model is performed using the processed data that is generated from the data received from the USB port.

In a twenty first scenario model the camera module representation processes video data that is captured using the CCD. The video processor module representation retrieves the video data that is processed by the camera module representation and further processes the video data to generate further processed video data. The further processed video data is sent to the display controller module representation in a manner described above in the thirteenth scenario model.

A twenty second scenario model is similar to the fourteenth scenario model except that the twenty second scenario model is performed using the further processed data that is generated from the data received from the camera module representation.

Moreover a twenty third scenario model is similar to the fifteenth scenario model except that the twenty third scenario model is performed using the further processed data that is generated from the data received from the camera module representation.

A twenty fourth scenario model is similar to the sixteenth scenario model except that the twenty fourth scenario model is performed using the further processed data that is generated from the data received from the camera module representation.

The display screen displays a graphical portion and a textual portion . Both the graphical portion and the textual portion are displayed by the GPU of the computing device upon execution of a test. In one embodiment the portions and are generated after the comparator is executed. In the portion four threads e.g. T T T and T etc. are executed by the CPU. Moreover in the portion four additional threads e.g. T T T and T etc. are executed by the CPU. Each thread executes one or more driver scenario models. An application scenario model includes switching between driver scenario models. For example in an application scenario model a driver scenario model is executed within the thread T which is executed by the CPU. In the application scenario model upon execution of the driver scenario model within the thread T as indicated by an arrow execution switches to another driver scenario model which is a portion of the thread T which is executed by the CPU. Moreover in the application scenario model upon execution of the driver scenario model within the thread T by the CPU execution switches to executing yet another driver scenario model within the thread T which is executed by the CPU.

A flow of execution is illustrated using an arrow in . For example an arrow indicates a flow in which a driver scenario model is executed by the CPU within the thread T after a driver scenario model is executed within the thread T by the CPU. As another example an arrow indicates a flow in which a driver scenario model is executed by the CPU within the thread T after a driver scenario model is executed within the thread T by the CPU.

It should be noted that the darkened driver scenario models e.g. a darkened scenario model etc. in the display portion have completed execution. Moreover the dotted driver scenario models e.g. a dotted scenario model etc. in the display portion are awaiting execution. Also the empty scenario models with a darkened border e.g. an empty scenario model etc. in the display portion have paused execution as a result of a breakpoint. In one embodiment a breakpoint is an intentional stopping or pausing of a computer program code in a compiled file for debugging. In the embodiment the user inspects a test environment e.g. register module representations memory device module representations IP blocks etc. that is executed until the breakpoint to find out whether computer program code is functioning as expected.

Moreover the portion includes a portion of a computer program code e.g. a code of a test file a code of a compiled file etc. that includes a code of one or more of the driver scenario models that are shown in the portion . For example when there is an error during execution of one the scenario models on a test bench a computer program code for the one of the scenario models e.g. stored in one of the test files etc. is displayed in the portion . As another example when one the scenario models does not execute on a test bench a computer program code for the one of the scenario models is displayed as being highlighted in the portion . As yet another example upon receiving a selection of the empty scenario model the processor commands the GPU to display a portion of a code of a compiled file or of a source code file e.g. a test file etc. for execution of the empty scenario model . The selection is received from the user via the input device. The portion of the code is displayed in the portion . To illustrate the portion of the code is displayed as being highlighted or as zoomed in compared to remaining code that is displayed in the portion . In an embodiment the zoom in portion overlaps with a portion of the display portion .

In one embodiment the portion includes a computer code e.g. a source code a compiled code etc. for executing the driver scenario models that are displayed in the display portion . For example as a display of the driver scenario models changes in the display portion with execution of the driver scenario models a computer code for the driver scenario models also changes in the display portion . The changed computer code is that of the changed driver scenario models that are displayed in the display portion .

In an embodiment when a selection of a driver scenario model is received via the input device from the user a computer code for the driver scenario model is highlighted by the GPU in the portion compared to computer codes of other driver scenario models in the portion .

In an embodiment highlighted as used herein includes darkened or textured or shaded or displayed in a different color or zoomed in or zoomed out or a combination thereof.

It should be noted that in one embodiment a number of threads executed by a CPU displayed in the portion is the same as a number of threads executed by CPU of an SoC. The use of the same number of threads as that of the SoC allows for execution of a realistic test of the SoC. In an embodiment a number of threads executed by a CPU is displayed in the portion is the different from a number of threads executed by CPU of an SoC.

Each thread is represented as a vertical bar graph. For example the thread T that is executed by the CPU is represented as a vertical bar graph the thread T that is executed by the CPU is represented as a vertical bar graph etc. In an embodiment instead of a vertical bar graph a thread is displayed by the GPU of the computing device as a horizontal bar graph or as a diagonal bar graph.

In an embodiment a different display format that than illustrated is used to distinguish a driver scenario model that is awaiting execution from a driver scenario model that has completed execution and or from a driver scenario model that has reached a breakpoint. For example the GPU of the computing device displays a driver scenario model that has finished execution in a different texture or a different shade or a different color or a combination thereof than a driver scenario model that is to be executed. As another example the GPU of the computing device displays a driver scenario model that has reached a breakpoint using a different texture or a different shade or a different color or a combination thereof than a driver scenario model that is to be executed.

In one embodiment a number of CPUs displayed in the portion is the same as a number of CPUs of an SoC. The use of the same number of CPUs as that of the SoC allows for execution of a realistic test of the SoC. In an embodiment a number of CPUs displayed in the portion is different from a number of CPUs of an SoC.

In an embodiment a thread is executed to execute any number of driver scenario models or any number of application scenario models or any number of performance scenario models. In one embodiment a thread is executed to execute a portion of a driver scenario model. For example a first input provided to an arbiter scenario model which is further described below is processed in a thread and a second input provided to the arbiter scenario model is processed in another thread. This allows facilitating a resolution of non determinism of arbitration. For example when the thread associated with the first input wins arbitration the thread notifies the other thread associated with the second input of the same.

In one embodiment a first computer thread is executed by a first CPU and a second computer thread is executed by a second CPU. When the first and second computer threads use one memory device the memory device is mutex protected. For example the first computer thread locks a mutex e.g. a unique name a unique value etc. while the first computer thread is executing and using data from a memory device. Until the first computer thread uses the memory device and the mutex protection is enabled the second computer thread cannot use e.g. access data from write data to etc. the memory device. In an embodiment the mutex protection is tested using a test bench and a scenario model described herein. In one embodiment the mutex protection applies when the first computer thread is executed by the first CPU and the second computer thread is executed by the first CPU.

In an embodiment any element of a portion that is displayed on the display screen by the GPU is displayed by performing a rendering operation on data that is stored in a memory device e.g. a memory device of the computing device etc. For example the dotted scenario model is displayed by rendering data that is stored in a memory device of the computing device .

The path A is generated by the processor between the scenario model and the output A and the input A. Also the path A is between the scenario model the output A and the input C. It is indicated by the path A that the output A is based on the scenario model and the input A and C are based on the output A. The path B is generated by the processor between the scenario model and the expected output B and the input B. It is indicated by the path B that the expected output B is based on the scenario model and the input B is based on the expected output B. The user can view the paths A and B on a display screen of a computing device.

It should be noted that the output A is constrained by the processor from being achieved when the expected output B is to be achieved.

In one embodiment the path B is highlighted by the processor upon execution of a scenario model illustrated by the path B to facilitate the user to see the path B. The visualization helps the user to determine whether an application scenario model illustrated by the path B has completed execution.

In an embodiment any number of paths that have finished execution is highlighted by the processor . The user is able to see that multiple highlighted paths that coincide with each other to indicate to the user that cross coverage of scenario models is done. Each path indicates performance of a scenario model.

The path A is an example of an unexecutable test case based on a constraint that the output A cannot be achieved when the expected output B is achieved. In one embodiment instead of or in addition to highlighting the path A a path that includes one or more driver scenario models is highlighted by the processor . For example a path that links the empty scenario model to other driver scenario models is bolded or colored by the processor . In this example some of the other driver scenario models are connected to an input node of the empty scenario model and the remaining of the other driver scenario models are connected to an output node of the empty scenario model . To further illustrate the some of the other driver scenario models are linked as a chain to the input node of the empty scenario model and the remaining of the other driver scenario models are linked as a chain to the output node of the empty scenario model . In an embodiment the other driver scenario models and the empty scenario model are linked to form an application scenario model or a performance scenario model.

In an embodiment the path B is included in the screen shot and the path A is excluded from the screen shot to a display a performance constraint to the user.

In some embodiments a test constraint e.g. a performance constraint etc. is displayed as logic e.g. a computer program code etc. instead of in a graphical format illustrated in the screen shot .

In one embodiment the path that links the empty scenario model to the other driver scenario models includes sub module representations of the empty scenario model and the other driver scenario models.

In one embodiment the description of the component of the SoC is within the file that defines the SoC. For example the processor receives the file defining the SoC and the file includes a description of a function of a component of the SoC.

A queue is an example of a component of an SoC and has one input port and one output port. The queue generates an outcome e.g. a primary outcome a secondary outcome a test output etc. when a pre requisite e.g. an input a stimulus etc. is applied to the queue. In one embodiment the queue supports backpressure from a component that is connected to the output port of the queue. For example when a data rate of the component connected to the output port of the queue is less than a data rate of data that is output from the queue the component sends a message to the queue that the component cannot process data received from the queue. In an embodiment when the queue includes a memory device for internal storage of data data output from the queue is out of order compared to an order in which data is received at the input port of the queue.

In one embodiment a primary outcome of the queue is data that is output from the queue when data is input to the queue. A secondary outcome of the queue is an overflow or underflow of data within a memory device used for internal storage within the queue. The overflow or underflow occurs with respect to a rate of reception of data by the queue or a rate of transfer of data from the queue. Another secondary outcome of the queue is sending of data by the queue in a different order than in which the data is received by the queue.

A verification space Vqueue corresponding to the queue is generated by the processor from the queue. The verification space of the queue performs the same functions as that of the queue. In one embodiment the verification space Vqueue is defined by the processor as a scenario model for the queue. An outcome e.g. the primary outcome the secondary outcome etc. of the queue is determined to be an expected output by the processor or by another processor. In one embodiment the expected output of the queue is received within the file that defines the SoC.

The expected output of the queue is applied by the processor to the verification space Vqueue to determine the pre requisite of the queue. The pre requisite of the queue is then used as a stimulus during application of a scenario model in which the verification space Vqueue is applied. In one embodiment the pre requisite of the queue is used to generate a test output of the queue which is compared to the expected output of the queue to determine whether the queue passed a test. In an embodiment the pre requisite of the queue is used to generate a test output of a scenario model which is compared to an expected output of the scenario model to determine whether the scenario model passed a test.

Similarly an arbiter is a component of the SoC that receives two or more pre requisites for generating one outcome. The arbiter has a single output port fed by a number of input ports. In an embodiment the input ports support back pressure capability to inform requestors e.g. components of an SoC that generate a request etc. that an output port of the arbiter is unavailable for transferring data. The arbiter arbitrates between the two or more pre requisites that are received at about the same time e.g. concurrently within a pre determined time range etc. to determine which of the two or more pre requisites is to be allowed to be an output of the arbiter first or is allowed to be an output of the arbiter. For example the arbiter arbitrates based on a type of a requestor e.g. low priority high priority etc. a type of data e.g. low priority data high priority data etc. a time at which data is received from a requestor or a combination thereof.

A verification space Varbiter corresponding to the arbiter is generated by the processor and the verification space Varbiter is executed by the processor to perform the same functions as that of the arbiter. In one embodiment the verification space Varbiter is defined by the processor as a scenario model for the arbiter. The verification space Varbiter is used by the processor to generate the two or more pre requisites from an expected output of the Varbiter to further generate a test output. In one embodiment the test output of the Varbiter is compared by the comparator with the expected output of the Varbiter to determine whether the Varbiter passed a test.

In one embodiment a primary outcome of the arbiter is data that the arbiter is capable of providing at its output port. The data is provided based on a random selection of data from one of input ports of the arbiter or times of arrival of data at its input ports. In an embodiment a secondary outcome of the arbiter includes a combination of timings associated with a transfer of data via the arbiter and of priorities associated with the transfer of data. In one embodiment a secondary outcome of the arbiter is to create backpressure in a situation in which the arbiter becomes saturated e.g. overflows etc. from data received at its input ports.

Moreover a distributor distributes data e.g. a video stream a pre requisite an audio stream a multimedia stream etc. that is received as input by the distributor to a number of channels in the form of the number of outputs. The distributor has multiple output ports that are fed by a single input port. In one embodiment one of the input output ports is selected by the distributor based on a destination that is specified within data received at the input port of the distributor.

The distributor is a component of the SoC that receives one pre requisite for generating a number of outputs. The distributor distributes the pre requisite based on one or more conditions e.g. whether a component attached to the distributor is ready to accept an output an address of a destination component within a portion of the pre requisite etc. For example the distributor does not distribute a portion of the pre requisite to a component of the SoC until the distributor receives a backpressure from the component. A verification space Vdistributor that performs the same functions as that of the distributor is generated by the processor . In one embodiment the verification space Vdistributor is defined by the processor as a scenario model for the distributor. The verification space Vdistributor is used by the processor to generate the pre requisite from a number of expected outputs of the distributor to further generate the same number of test outputs. In one embodiment the test outputs of the Vdistributor are compared by the processor with corresponding expected outputs of the Vdistributor to determine whether the Vdistributor passes a test.

In one embodiment a primary outcome of the distributor is data at its output ports and a secondary outcome of the distributor is a rate at which the data is distributed at each of its output ports.

In an embodiment a verification space of a component of an SoC is coupled to another verification space for storing data e.g. a verification space Vreg of a register a verification space Vmem or a memory device etc. The verification space for storing data is generated by the processor based on functions performed by a memory device e.g. a RAM a ROM a memory device within a component of an SoC a register a flash memory a hard disk a compact disc a digital video disc a disk array a virtual memory region within a memory device etc. For example when a memory device is coupled to a component of the SoC the verification space for storing data is connected by the processor to the verification space having a functionality of the component. In one embodiment the verification space Vmem is defined by the processor as a scenario model for a memory device. Moreover in an embodiment the verification space Vreg is defined by the processor as a scenario model for a register. Also in an embodiment the verification space having a functionality of a component of an SoC is defined by the processor as a scenario model for the component. For example the verification space having a functionality of a component of an SoC is defined by the processor as a scenario model that includes an application of the functionality of the component.

In one embodiment a memory device module representation is used e.g. accessed for reading or writing etc. at a time by one scenario model. For example when a memory device module representation is accessed by an application scenario model at a time the memory device module representation cannot be accessed by another application scenario model or a driver scenario model or a performance scenario model at the same time. To avoid conflict between multiple scenario models that access the same memory device module representation the processor determines a time of access of the memory device module representation by each scenario model or informs a scenario model when the memory device module representation will be available for access by the scenario model.

The verification space for storing data is connected to provide an input to or receive an output from a verification space of a component of an SoC based on whether a memory device is connected at an input node or an output node of the component. For example if a memory device of the SoC is connected at an input node of a component of the SoC the verification space for storing data is connected to provide an input to a verification space of the component. As another example if a memory device of an SoC is connected at an output node of a component of the SoC the verification space for storing data is connected to receive an output from a verification space of the component.

In one embodiment a discrete memory element e.g. one or more memory addresses in a memory device one or more registers etc. is allocated by a discrete allocator to a first component of an SoC until a reference count reaches zero or a pre determined value. The processor keeps a log of the reference count. A second component of the SoC cannot access the discrete memory element for storage or data or for obtaining data until the discrete memory element is allocated to the first component and until the reference count reaches zero or a pre determined value. The reference count is a number of times the discrete memory element is accessed by the first component.

A primary outcome of the discrete allocator is to allocate the discrete memory element to a component that requests the discrete memory element or to decrement the reference count to reach zero or to increment the reference count to reach a pre determined value or to free the discrete memory element from being allocated to the component or a combination thereof. The primary outcome of the discrete allocator is used by the processor to determine pre requisites of the discrete allocator. The pre requisites of the discrete allocator include a definition of a pool of available resources for allocation by the discrete allocator configuration of the discrete allocator to define whether the discrete memory element can be allocated more than once to one component or configuration the discrete memory element or a combination thereof. Examples of a secondary outcome of the discrete allocator include a re use a recently freed discrete memory element and a permutation of e.g. re arrangement of allocation of etc. a pool of discrete memory elements to maximize use of the discrete memory elements. In one embodiment a resource and a memory device are used interchangeably herein. Another example of a resource includes a bus fabric.

A verification space Vdiscrete is generated by the processor based on functions performed by the discrete allocator. In one embodiment the verification space Vdiscrete is defined by the processor as a scenario model for the discrete allocator. In an embodiment a discrete memory element of a memory device module representation is allocated by a discrete allocator module representation to a first scenario model until a reference count reaches zero. A second scenario model cannot access the discrete memory element of the memory device module representation until the discrete memory element is allocated to the first scenario model and until the reference count reaches zero or reaches a pre determined value. The reference count is a number of times the discrete memory element is accessed by the first scenario model.

A verification space Vcontinuous is a verification space generated by the processor for a continuous allocator that allocates a continuous block e.g. region of sequential memory addresses etc. of elements within a memory device. In one embodiment the verification space Vcontinuous is defined by the processor as a scenario model for the continuous allocator. The continuous block is allocated to or freed from a requestor of the continuous block. The requestor specifies to the allocator whether the continuous block is to be allocated to the requestor or is already allocated to the requestor and is to be used by the requestor for multiple operations during the same data flow e.g. a scenario model etc. In case of multiple operations the requestor or the continuous allocator increments or decrements a number of the multiple operations.

In one embodiment the continuous allocator defines data in an allocated continuous block. For example the continuous allocator statically initializes e.g. resets sets etc. a block of memory elements in a continuous block or arranges for the memory elements to be initialized by another agent e.g. in case of a direct memory access to a memory device etc.

Examples of primary outcomes of the continuous allocator include allocation of a contiguous block of memory elements of a pre determined length incrementing or decrementing a reference count indicating a number of the multiple operations performed for a previously allocated block of memory elements freeing a previously allocated block of memory elements from being allocated to a requestor etc. Examples of pre requisites of the continuous allocator include a definition of available contiguous blocks in one or more memory devices static initialization of data in a contiguous block dynamic initialization of data in a contiguous block by another agent etc. Examples of secondary outcome of the continuous allocator include an arrangement of multiple contiguous blocks to test for nonexistence of overlap between the multiple contiguous blocks in case of read and write operations an arrangement of partial re use of a portion of a contiguous block when an agent e.g. requestor etc. fails to write back in time to a remaining portion of the contiguous block an arrangement for false sharing in which different agents use adjacent memory locations of a contiguous block to test cache coherency an arrangement for true sharing in which different agents use the same memory locations to test cache coherency tracking of a memory shadow state that is a state of a shadow of a memory device of an SoC etc.

The verification space Vreg is generated by the processor based on a register or a number of registers e.g. registers having a width of 32 bits or 64 bits or 128 bits or 256 bits etc. In one embodiment a register is a configuration register that is used to set up modes in which an SoC operates or includes a portion of an instruction to operate the SoC. In an embodiment a number of registers is organized by an instance of a component of an SoC. Each component instance has a base address and offsets for each register.

An example of primary outcomes of a number of registers includes register values stored in the registers. Other examples of primary outcomes of registers include register values that are obtained by the registers or by a component of an SoC from a number of shadow registers for storage in the registers. Examples of pre requisites of a number of registers include register address offsets base addresses for each instance of a component of an SoC ability to execute a read instruction ability to execute a write instruction etc. Examples of secondary outcomes of a number of registers include register values that are provided by the registers based on randomized timings to test for register pipeline issues and register values that are provided by the registers based on a random ordering of register operations to test for hardware dependencies on the register ordering.

A verification space Vstruct is generated by the processor based on a data structure or a number of data structures e.g. memory devices other than registers that store data etc. In one embodiment the verification space Vstruct is defined by the processor as a scenario model for a data structure. A format e.g. extensible markup language XML format tree graphical array etc. is used to define fields in data structures.

An example of primary outcomes of a number of data structures includes a values stored in the data structures. Other examples of primary outcomes of data structures include values that are obtained by the data structures or by a component of an SoC from a number of shadow registers for storage in the data structures. Examples of pre requisites of data structures include data structure address offsets base addresses of the data structures ability to execute a read instruction ability to execute a write instruction etc.

In an embodiment a module representation other than a memory device module representation has a primary outcome of transferring data from one memory device module representation to another memory device module representation or from a memory device module representation to an input output module representation or from an input output module representation to a memory device module representation. The module representation other than a memory device module representation has a secondary output to indicate backpressure to one or more input ports of the module representation and or to indicate signal interrupts and or to perform direct memory access DMA to or from a memory device module representation. For example a video decoder module representation has a primary outcome of storing decoded image data in a memory device module representation and a video display module representation has a primary outcome of producing a composite image for display on a display device.

In an embodiment a memory device module representation has a primary outcome of facilitating a read or a write and a secondary outcome of facilitating the read or write at a data rate e.g. a double data rate a data rate higher or lower than a double data rate etc. In one embodiment a cache module representation has a primary outcome of facilitating a read or a write and a secondary outcome of fetching data or snooping data from a main memory device module representation.

A verification space VB receives the intermediate value IV from the verification space VC and generates an intermediate value IV from the intermediate value IV. The verification space VB is generated by the processor from the module representation B. For example the verification space VB performs the same functions as that of the module representation B.

A verification space VA receives the intermediate value IV from the verification space VB and generates an input I which is an example of a stimulus from the intermediate value IV. The verification space VA is generated by the processor from the module representation A. For example the verification space VA performs the same functions as that of the module representation A.

The module representation A receives the stimulus I and generates the intermediate value IV from the stimulus I. The module representation B receives the intermediate value IV from the module representation A and generates the intermediate value IV from the intermediate value IV. The module representation C receives the intermediate value IV from the module representation B and generates the output O which is a test output. The test output O is compared to the expected output O to determine whether the test output O matches the expected output O or is within a pre determined threshold of the expected output O. Upon determining that the test output O is within the pre determined threshold of the expected output O or matches the expected output O the processor determines that the pipeline scenario model passes a test. On the other hand upon determining that the test output O is not within the pre determined threshold of the expected output O or does not match the expected output O the processor determines that the pipeline scenario model fails a test.

In one embodiment instead of the module representations A B and C a component of an SoC is used to describe . For example a component of an SoC from which the module representation A is generated is used instead of the module representation A to generate the intermediate value IV.

In an embodiment an intermediate value as described herein is an example of an expected outcome and the intermediate value is checked e.g. tested compared etc. against a test outcome.

The verification space VC receives the intermediate value IV from the verification space VD and generates the intermediate values IV and IV from the intermediate value IV. The verification space VA receives the intermediate value IV from the verification space VC and generates the input I and an input I which are examples of stimuli from the intermediate value IV. Moreover the verification space VB receives the intermediate value IV from the verification space VC and generates inputs I and I which are examples of stimuli from the intermediate value IV.

Moreover as shown the module representation A receives the input I and the input I and generates the intermediate value IV from the inputs I and I. Also the module representation B receives the inputs I and I and generates the intermediate value IV from the inputs I and I.

In one embodiment the intermediate value IV is the same or within a range of the input I. In an embodiment the intermediate value IV is the same or within a range of the input I. For example when the module representation A is a representation of an arbiter component e.g. a switch etc. of an SoC the arbiter component switches between providing the inputs I and I as the intermediate value IV. To illustrate the arbiter component outputs the input I as the intermediate value IV when there is no push back from a queue sub module of the module representation C or a queue sub module of the module representation D or a queue sub module of another module representation connected to the module representation D. In this illustration the arbiter component does not output the input I as the intermediate value IV when there is a push back from another queue sub module of the module representation C or another queue of the module representation D.

Moreover the module representation C receives the intermediate values IV and IV from the respective module representations A and B and generates the intermediate value IV from the intermediate values IV and IV. For example when the module representation C is generated based on functions performed by an arbiter the module representation C outputs the intermediate values IV or IV as the intermediate value IV based on the conditions. As another example when the module representation C is a summer or a multiplier or a divider the module representation C sums or multiplies or divides the intermediate value IV and IV to generate the intermediate value IV.

Furthermore the module representation D receives the intermediate value IV from the module representation C and generates the output O and an output O from the intermediate value IV. For example when the module representation D represents a distributor e.g. a de multiplexer a switch etc. the intermediate value IV is distributed to the outputs O and O which are test outputs.

The test output O is compared to the expected output O to determine whether the test output O matches the expected output O or is within a pre determined threshold of the expected output O. Similarly the test output O is compared to the expected output O to determine whether the test output O matches the expected output O or is within a pre determined threshold of the expected output O. Upon determining that the test output O is within the pre determined threshold of the expected output O or matches the expected output O and upon determining that the test output O is within the pre determined threshold of the expected output O or matches the expected output O the processor determines that the switch scenario model passes a test. On the other hand upon determining that the test output O is not within the pre determined threshold of the expected output O or does not match the expected output O and or upon determining that the test output O is not within the pre determined threshold of the expected output O or does not match the expected output O the processor determines that the switch scenario model fails a test.

In one embodiment instead of the module representations A B C and D a component of an SoC is used to describe . For example a component of an SoC from which the module representation C is generated is used instead of the module representation C to generate the intermediate value IV.

In an embodiment a switch scenario module representation has a primary outcome of routing a transaction to one of its output ports. The switch scenario module representation has a secondary outcome that asserts backpressure on its input ports and or has a secondary outcome that creates buffer overflow of a buffer module representation that is coupled to the switch scenario module representation and or has a secondary outcome that creates buffer underflow of the buffer module representation. The backpressure on the input ports indicates error conditions regarding transfer of data via the switch scenario model.

A verification space VBout receives the intermediate value IV as an input from the verification space VAout and generates the intermediate value IV from the intermediate value IV. The verification space VBout is generated by the processor from the module representation B. For example the verification space VBout performs one or more functions performed by the module representation B.

A verification space VCout receives the intermediate value IV from the verification space VBout and generates an intermediate value from the intermediate value IV. The verification space VCout is generated by the processor from the module representation C. For example the verification space VCout performs one or more functions performed by the module representation C.

A verification space VCin receives the intermediate value generated by the verification space VCout and generates the intermediate value IV from the intermediate value generated by the verification space VCout. The verification space VCin is generated by the processor from the module representation C. For example the verification space VCin performs one or more functions performed by the module representation C.

It should be noted that in one embodiment the verification space VCin performs a different function than that performed by the verification space VCout. In an embodiment the verification space VCin performs the same function as that performed by the verification space VCout.

A verification space VBin receives the intermediate value IV from the verification space VCin and generates the intermediate value IV from the intermediate value IV. The verification space VBin is generated by the processor from the module representation B. For example the verification space VBin performs one or more functions performed by the module representation B.

It should be noted that in one embodiment the verification space VBin performs a different function than that performed by the verification space VBout. In an embodiment the verification space VBin performs the same function as that performed by the verification space VBout.

A verification space VAin receives the intermediate value IV from the verification space VBin and generates the input I which is an example of a stimulus from the intermediate value IV. The verification space VAin is generated by the processor from the module representation A. For example the verification space VAin performs one or more functions performed by the module representation A.

It should be noted that in one embodiment the verification space VAin performs a different function than that performed by the verification space VAout. In an embodiment the verification space VAin performs the same function as that performed by the verification space VAout.

The stimulus I is forward propagated via the pipeline scenario model that involves the module representations A B and C to generate the output O. For example the module representation A receives the input I and generates the intermediate value IV from the input I. Moreover the module representation B receives the intermediate value IV from the module representation A and generates the intermediate value IV from the intermediate value IV. Furthermore the module representation C receives the intermediate value IV from the module representation B and generates the intermediate value IV from the intermediate value IV. Also the module representation B receives the intermediate value IV from the module representation C and generates the intermediate value IV from the intermediate value IV. The module representation A receives the intermediate value IV from the module representation B and generates the output O as a test output from the intermediate value IV.

The test output O is compared to the expected output O to determine whether the test output O matches the expected output O or is within a pre determined threshold of the expected output O. Upon determining that the test output O is within the pre determined threshold of the expected output O or matches the expected output O the processor determines that the pipeline scenario model passes a test. On the other hand upon determining that the test output O is not within the pre determined threshold of the expected output O or does not match the expected output O the processor determines that the pipeline scenario model fails a test.

In one embodiment instead of the module representations A B and C a component of an SoC is used to describe . For example a component of an SoC from which the module representation B is generated is used instead of the module representation B to generate the intermediate values IV and IV.

Upon determining that the expected output O is received from the second requestor the verification space VC generates the intermediate value IV from the output O and provides the intermediate value IV to the verification space VA. The verification space VA generates the input value I from the intermediate value IV and sends the input value I to the second requestor. Moreover upon determining that the expected output O is received from the second requestor the verification space VC generates data D and provides the data D to verification space VB which further sends the data D to the second requestor.

Moreover during the write operation the processor uses the output O as an expected output. The expected output O is received by a verification space VMEMY and is sent by the verification space VMEMY to the verification space VD. The verification space VMEMY is generated by the processor and has the same functions as that of a memory device module representation MemY. The verification space VD determines whether the expected output O is received from the first requestor or the second requestor. Upon determining that the expected output O is received from the first requestor the verification space VD generates the intermediate value IV from the output O and provides the intermediate value IV to the verification space VA. The verification space VA generates the input value I from the intermediate value IV and sends the input value I to the first requestor. Moreover upon determining that the expected output O is received from the first requestor the verification space VD generates the data D and provides the data D to the verification space VB which further sends the data D to the first requestor.

Upon determining that the expected output O is received from the second requestor the verification space VD generates the intermediate value IV from the output O and provides the intermediate value IV to the verification space VA. The verification space VA generates the input value I from the intermediate value IV and sends the input value I to the second requestor. Moreover upon determining that the expected output O is received from the second requestor the verification space VD generates the data D and provides the data D to verification space VB which further sends the data D to the second requestor.

During the write operation the inputs I I and the data D and D are forward propagated via the corresponding module representations A B C D MemX and MemY to generate test outputs e.g. the outputs O and O. During the write operation the input I is received from the first requestor e.g. an IP block etc. which provides an instruction to perform the write operation and indicates an address e.g. an address within a memory device module representation MemX an address within a memory device module representation MemY etc. at which data is to be written.

When the write operation is to be performed to the memory device module representation MemX the instruction for performing the write operation and the address of the write operation are provided as the intermediate value IV to the module representation C. The module representation C requests data to be written to the address from the module representation B and the module representation B further requests data D from the first requestor. The data D is provided via the module representations B and C to be written to the memory device module representation MemX. The data D is provided to the memory device module representation MemX as the output O.

If the write operation is to be performed by the first requestor to the memory device module representation MemY the instruction of performing the write operation and the address of the write operation are provided as the intermediate value IV to the module representation D. The memory device module representation D requests data to be written to the address from the module representation B and the module representation B further requests the data D from the first requestor. The data D is provided via the module representations B and D to be written to the memory device module representation MemY. The data D is provided to the memory device module representation MemY as the output O.

During the write operation the input I is received from the second requestor e.g. an IP block etc. which provides an instruction whether to perform a read operation or a write operation and indicates an address e.g. an address within a memory device module representation MemX an address within a memory device module representation MemY etc. at which data is to be written.

If the write operation is to be performed to the memory device module representation MemX by the second requestor the instruction of performing the write operation and the address of the write operation are provided as the intermediate value IV to the module representation C. The module representation C requests data to be written to the address from the module representation B and the module representation B further requests data D from the second requestor. The data D is provided via the module representations B and C to be written to the memory device module representation MemX. The data D is provided to the memory device module representation MemX as the output O.

If the write operation is to be performed by the second requestor to the memory device module representation MemY the instruction of performing the write operation and the address of the write operation are provided as the intermediate value IV to the module representation D by the module representation A. The memory device module representation D requests data to be written to the address from the module representation B and the module representation B further requests the data D from the second requestor. The data D is provided via the module representations B and D to be written to the memory device module representation MemY. The data D is provided to the memory device module representation MemY as the output O.

During the write operation a test output is compared by the processor with a corresponding expected output to determine whether the scenario model passed a test. For example it is determined by the processor whether the test output O is the same as or is within a pre determined threshold of the expected output O. Upon determining that the test output O is the same as or is within a pre determined threshold of the expected output O the processor determines that the scenario model passes a test for the write operation. On the other hand upon determining that the test output O is not the same as or is not within the pre determined threshold of the expected output O the processor determines that the scenario model fails a test for the write operation. As another example it is determined by the processor whether the test output O is the same as or is within a pre determined threshold of the expected output O. Upon determining that the test output O is the same as or is within a pre determined threshold of the expected output O the processor determines that the scenario model passes a test for the write operation. On the other hand upon determining that the test output O is not the same as or is not within the pre determined threshold of the expected output O the processor determines that the scenario model fails a test for the write operation.

In one embodiment instead of the module representations A B C D MemX and MemY components of an SoC are used to describe .

Upon determining that the expected output O is to be received from the second requestor for the read operation the verification space VC generates the intermediate value IV from the output O and provides the intermediate value IV to the verification space VA. The verification space VA generates the input value I from the intermediate value IV and sends the input value I to the second requestor. Moreover upon determining that the expected output O is to be received from the second requestor for the read operation the verification space VC sends a request for the data D and provides the request for the data D to the verification space VB which further sends the request to the second requestor to receive the data D from the second requestor.

The processor uses the output O as an expected output. It is determined by the verification space VD that the expected output O is to be provided to the verification space VMemY by the verification space VD. The verification space VD further determines whether the expected output O is to be received from the first requestor or the second requestor. Upon determining that the expected output O is to be received from the first requestor for the read operation the verification space VD generates the intermediate value IV from the output O and provides the intermediate value IV to the verification space VA. The verification space VA generates the input value I from the intermediate value IV and sends the input value I to the first requestor. Moreover upon determining that the expected output O is to be received from the first requestor for the read operation the verification space VD sends a request for the data D and provides the request for the data D to the verification space VB which further sends the request to the first requestor to receive the data D from the first requestor.

Upon determining that the expected output O is to be received from the second requestor for the read operation the verification space VD generates the intermediate value IV from the output O and provides the intermediate value IV to the verification space VA. The verification space VA generates the input value I from the intermediate value IV and sends the input value I to the second requestor. Moreover upon determining that the expected output O is to be received from the second requestor for the read operation the verification space VD sends a request for the data D and provides the request for the data D to the verification space VB which further sends the request to the second requestor to receive the data D from the second requestor.

During the read operation the inputs I I are forward propagated and the data D and D are backward propagated via the corresponding module representations A B C D MemX and MemY to generate test outputs e.g. the outputs O and O. During the read operation the input I is received from the first requestor indicating to perform the read operation and indicating an address e.g. an address within a memory device module representation MemX an address within a memory device module representation MemY etc. from which data is to be read.

When the read operation is to be performed from the memory device module representation MemX by the first requestor the instruction of performing the read operation and the address of the read operation are provided as the intermediate value IV to the module representation C. The module representation C requests data to be read from the address of the memory device module representation MemX. Upon receiving the request for reading the data the memory device module representation MemX provides the output O as data to the module representation C. Moreover the memory device module representation C determines that the first requestor requested the read operation and provides the read data to the module representation B for sending to the first requestor. The module representation B provides the data D as an output to the first requestor upon receiving the read data from the module representation C and upon receiving an indication that the read data is to be sent to the first requestor.

When the read operation is to be performed from the memory device module representation MemY by the first requestor the instruction of performing the read operation and the address of the read operation are provided as the intermediate value IV to the module representation D. The module representation D requests data to be read from the address of the memory device module representation MemY. Upon receiving the request for reading the data the memory device module representation MemY provides the output O as data to the module representation D. Moreover the module representation D determines that the first requestor requested the read operation and provides the read data to the module representation B for sending to the first requestor. The module representation B provides the data D as an output to the first requestor upon receiving the read data from the module representation D and upon receiving an indication that the read data is to be sent to the first requestor.

When the read operation is to be performed from the memory device module representation MemX by the second requestor the instruction of performing the read operation and the address of the read operation are provided as the intermediate value IV to the module representation C. The module representation C requests data to be read from the address of the memory device module representation MemX. Upon receiving the request for reading the data the memory device module representation MemX provides the output O as data to the module representation C. Moreover the memory device module representation C determines that the second requestor requested the read operation and provides the read data to the module representation B for sending to the second requestor. The module representation B provides the data D as an output to the second requestor upon receiving the read data from the module representation C and upon receiving an indication that the read data is to be sent to the second requestor.

When the read operation is to be performed from the memory device module representation MemY by the second requestor the instruction of performing the read operation and the address of the read operation are provided as the intermediate value IV to the module representation D. The module representation D requests data to be read from the address of the memory device module representation MemY. Upon receiving the request for reading the data the memory device module representation MemY provides the output O as data to the module representation D. Moreover the module representation D determines that the second requestor requested the read operation and provides the read data to the module representation B for sending to the second requestor. The module representation B provides the data D as an output to the second requestor upon receiving the read data from the module representation D and upon receiving an indication that the read data is to be sent to the second requestor.

A test output is compared by the processor with a corresponding expected output to determine whether the scenario model passes a test for the read operation. For example it is determined by the processor whether the test output O is the same as or is within a pre determined threshold of the expected output O. Upon determining that the test output O is the same as or is within a pre determined threshold of the expected output O the processor determines that the scenario model passes a test for the read operation. On the other hand upon determining that the test output O is not the same as or is not within the pre determined threshold of the expected output O the processor determines that the scenario model fails a test for the read operation. As another example it is determined by the processor whether the test output O is the same as or is within a pre determined threshold of the expected output O. Upon determining that the test output O is the same as or is within a pre determined threshold of the expected output O the processor determines that the scenario model passes a test for the read operation. On the other hand upon determining that the test output O is not the same as or is not within the pre determined threshold of the expected output O the processor determines that the scenario model fails a test for the read operation.

In one embodiment instead of the module representations A B C D MemX and MemY components of an SoC are used to describe .

The verification space Vmem is created by the processor based on a memory device that stores the decoded frame and is executed by the processor to store the decoded frame. For example the verification space Vmem performs the same functions as that performed by the memory device that stores the decoded frame. As another example the verification space Vmem is a scenario model for the memory device that stores the decoded frame. To further illustrate the verification space Vmem is a scenario model that has an application of functionality of the memory device that stores the decoded frame.

The decoded frame is encoded by a verification space Vdecode to generate an encoded frame. The verification space Vdecode is created by the processor based on a video decoder and is executed by the processor . For example the verification space Vdecode performs the same functions as that performed by the video decoder. As another example the verification space Vdecode is a scenario model for the video decoder. To further illustrate the verification space Vdecode is a scenario model that has an application of functionality of the video decoder. The encoded frame is stored in a verification space Vmem by the processor . The verification space Vmem is created by the processor based on a memory device that stores the encoded frame and is executed by the processor to store the encoded frame. For example the verification space Vmem performs the same functions as that performed by the memory device that stores the encoded frame. As another example the verification space Vmem is a scenario model for the memory device that stores the encoded frame. To illustrate the verification space Vmem is a scenario model that has an application of functionality of the memory device that stores the encoded frame.

The video decoder receives the encoded frame which is an example of the input I and decodes the encoded frame to generate the decoded frame which is an example of the intermediate value IV. The video display device receives the decoded frame and displays the video frame as the video which is an example of the output O.

In one embodiment the verification space Vdecode is executed in one thread e.g. a producer thread etc. and the verification space Vdisplay is executed in another thread e.g. a consumer thread etc.

In one embodiment all module representations described herein are generated and executed by the processor .

It should be noted that although some the above embodiments are described with respect to the computing device in an embodiment instead of the processors of the computing device processors of different computing devices are used. For example the processor of the computing device parses the file that defines the SoC and a processor of another computing device executes the comparator .

It is noted that although some of the above described embodiments are described with respect to the processor in one embodiment another processor is used to perform the operations described herein as being performed by the processor .

In an embodiment instead of a memory device a virtual memory device e.g. a range of memory addresses within a memory device etc. is used.

In one embodiment a scenario model that includes information that is not specific to an SoC e.g. a processor an integrated circuit etc. is applied by the processor to another SoC e.g. for testing the other SoC.

In one embodiment a scenario model is generated to achieve an extraordinary outcome which is an example of an expected output or a secondary outcome. For example a scenario model is generated to divide a number by zero. Another scenario model is generated to add two numbers to achieve a carry over. It should be noted that an ordinary outcome of a scenario model is an example of a primary outcome. For example a result of an addition that does not include a carry over is an ordinary outcome. As another example a division by a number that generates no remainder is an ordinary outcome.

In an embodiment multiple scenario models are executed in parallel to perform a test. For example a first application scenario model is executed simultaneously with a second application scenario model. In this example the first application scenario model is executed to generate a primary outcome or a secondary outcome and the second application scenario model is executed to generate a primary outcome or a secondary outcome. As another example a first driver scenario model is executed simultaneously with a second driver scenario model or an application scenario model. In this example the first driver scenario model is executed to generate a primary outcome or a secondary outcome and the second driver scenario model or the application scenario model is executed to generate a primary outcome or a secondary outcome. To illustrate inputs snoops to a cache module representation are set up simultaneously with executing a read or a write request to the cache module representation. As yet another example a first performance scenario model is executed at the same time as a second performance scenario model or an application scenario model or a driver scenario model. In this example the first performance scenario model is executed to generate a primary outcome or a secondary outcome and the second performance scenario model or the application scenario model or the driver scenario model is executed to generate a primary outcome or a secondary outcome.

In one embodiment a value of a primary outcome is used as a value of a secondary outcome. For example a memory address that is output from a cache module representation is used as a secondary outcome to generate a stimulus. The stimulus is generated by applying a function performed by the cache module representation different from a function performed to generate the memory address. To further illustrate the memory address output is generated by applying a primary function of the cache module representation of facilitating a read from or a write of data to the cache module representation and the stimulus is generated to fetch data from the memory address of a main memory device module representation.

It should further be noted that although some of the embodiments described above relate to the functions described above as being performed by a digital camera in one embodiment the embodiments equally apply to various other functions e.g. resetting registers resetting addresses within a memory device generating interrupts interrupt handling handling contention for shared resources committing write data to an address of a memory device before a read operation is to be performed generation of randomized page tables and selecting memory addresses to hit and miss in the page tables randomized switching between clock and power modes of the system and power control module representation controlling memory stall rates etc. The various other functions are performed by one or more components of an SoC.

Other examples of the various other functions include allocating memory buffers and freeing the buffers on demand random use of addresses of a cache to create cache line collisions to test cache coherency partial re use of recently freed buffers checking accessibility of a CPU to one or more registers checking accessibility of a CPU to one or more memory devices checking a component of an SoC to determine whether the component is able to drive an I O or generate an interrupt concurrent performance of multiple components of an SoC checking register values checking I Os sending data to an I O receiving data from an I O logging diagnostic messages on progress of threads logging diagnostic messages on a state of a memory device checking memory data buffers checking time elapsed between two events occurring using a number of scenario models etc. In one embodiment an event is a function that is performed to generate a test outcome.

Yet other examples of the various other functions include transferring data from a memory device via a component of an SoC to an output port of the SoC transferring data from the component to the output port transferring data from an input port of the SoC via a component of the SoC to the memory device transferring data from the input port to the component transferring data from one memory device to another memory device etc. In one embodiment a DMA agent is used to transfer data.

Further examples of the various other functions include sending an interrupt from an IP block to a CPU that services the interrupt. The interrupt is sent when the IP block finishes execution of its task. Moreover the CPU is assigned to the IP block for an amount of time the IP block finishes execution of the task. In an embodiment CPUs are not assigned to IP blocks. In this embodiment any CPU receives an interrupt from an IP block and upon receiving the interrupt sets a mutex for the interrupt so that another CPU is able to service a task to be performed by the IP block. In one embodiment an interrupt handler which is an example of a computer software program services an IP block until a task is finished execution by the IP block. The interrupt handler generates an interrupt when the IP block finishes execution of the task. In an embodiment the interrupt handler is executed under an operating system OS or a real time operation system RTOS .

It should further be noted that although some of the embodiments described above relate to functions performed by an SoC the embodiments apply to components that are located outside the SoC. For example asynchronous events e.g. external bus masters I Os external interrupts fault injections to or from an external component fault resets of an external component or received from an external component etc. that are associated with devices external to an SoC are tested using the embodiments described above. To further illustrate when a fault signal is sent to an external component and an acknowledgment of the fault signal is not received from the external component within a pre determined time period the processor determines that the external component fails a test.

In one embodiment an SoC is implemented within a computing device a mobile phone a home appliance a television a smart television a tablet the Internet a computer network an Intranet etc.

Moreover although the above embodiments are described with respect to a processor in one embodiment the functions described herein are being performed by the processor are performed instead by one or more virtual machines VMs or by one or more servers or by multiple processors.

In some embodiments a scenario model as used herein is a scenario. Moreover in these embodiments multiple scenarios form a scenario model.

In one embodiment any operations described herein as being performed by a GPU are performed by a processor e.g. the processor etc.

Embodiments described herein may be practiced with various computer system configurations including hand held hardware units microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like. In one embodiment the embodiments described herein are practiced in distributed computing environments where tasks are performed by remote processing hardware units that are linked through a computer network.

With the above embodiments in mind it should be understood that some of the embodiments employ various computer implemented operations involving data stored in computer systems. These operations are those physically manipulating physical quantities. Any of the operations described herein that form part of the embodiments are useful machine operations.

Some of the embodiments also relate to a hardware unit or an apparatus for performing these operations. The apparatus is specially constructed for a special purpose computer. When defined as a special purpose computer the computer performs other processing program execution or routines that are not part of the special purpose while still being capable of operating for the special purpose.

In one embodiment the operations described herein are processed by a computer selectively activated or configured by one or more computer programs stored in a computer memory cache or obtained over a computer network. When data is obtained over the computer network the data is processed by other computers on the computer network e.g. a cloud of computing resources.

In an embodiment one or more embodiments described above are fabricated as computer readable code on a non transitory computer readable medium. The non transitory computer readable medium is any data storage hardware unit e.g. a memory device etc. that stores data which is thereafter be read by a computer system. Examples of the non transitory computer readable medium include hard drives network attached storage NAS ROM RAM compact disc ROMs CD ROMs CD recordables CD Rs CD rewritables CD RWs magnetic tapes and other optical and non optical data storage hardware units. In an embodiment the non transitory computer readable medium includes a computer readable tangible medium distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion.

Although the method operations above were described in a specific order it should be understood that in various embodiments other housekeeping operations are performed in between operations or the method operations are adjusted so that they occur at slightly different times or are distributed in a system which allows the occurrence of the method operations at various intervals or are performed in a different order than that described above.

It should further be noted that in an embodiment one or more features from any embodiment described above are combined with one or more features of any other embodiment without departing from a scope described in various embodiments described in the present disclosure.

Although the foregoing embodiments have been described in some detail for purposes of clarity of understanding it will be apparent that certain changes and modifications can be practiced within the scope of appended claims. Accordingly the present embodiments are to be considered as illustrative and not restrictive and the embodiments are not to be limited to the details given herein but may be modified within the scope and equivalents of the appended claims.

