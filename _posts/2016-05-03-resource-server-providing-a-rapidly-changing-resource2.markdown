---

title: Resource server providing a rapidly changing resource
abstract: A computing device is provided that supports receipt and processing of blocks of streamed data associated with an event and provision of pre-rendered and compressed events to event client systems with a high-throughput. The computing device includes a compression optimizer module that determines how to make new compressed blocks of the right level of compression as the blocks of streamed data are received from an event publishing system. The compression optimizer module utilizes a tree map and unique identifiers to selectively compress, read, and recompress the blocks of streamed data associated with each event. To prevent duplicate work in compressing the streamed data, compressed blocks are re-used where possible to support requests from the event client systems. Each new block includes a unique identifier defined by the event publishing system that generated the event, so that a previous version of the event in a compressed block can be replaced.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09654586&OS=09654586&RS=09654586
owner: SAS Institute Inc.
number: 09654586
owner_city: Cary
owner_country: US
publication_date: 20160503
---
The present application is a continuation of U.S. patent application Ser. No. 14 790 563 that was filed Jul. 2 2015 the entire contents of which are hereby incorporated by reference. The present application further claims the benefit of 35 U.S.C. 119 e to U.S. Provisional Patent Application No. 62 020 451 filed Jul. 3 2014 to U.S. Provisional Patent Application No. 62 024 109 filed Jul. 14 2014 and to U.S. Provisional Patent Application No. 62 049 952 filed Sep. 12 2014 the entire contents of which are all hereby incorporated by reference.

An increasing number of distributed applications process continuously flowing data from geographically distributed sources perform analytics on the streamed data and provide analysis results to entities that may also be geographically distributed.

In an example embodiment a computer readable medium is provided having stored thereon computer readable instructions that when executed by a computing device cause the computing device to serve data resources from a publishing system to a client system. A block of streamed data is received. The block includes a value associated with an event and a unique identifier of the event. A pre allocated block of memory is selected. The pre allocated block of memory includes one or more previously compressed blocks. Each of the one or more previously compressed blocks includes an associated value and a different unique identifier. The received block is compressed with the one or more previously compressed blocks to create a new compressed block. The new compressed block is stored in the selected pre allocated block of memory. A reference to the selected pre allocated block of memory is stored in a tree map based on the unique identifier. A second block of streamed data is received. The second block includes a second value associated with the event and the unique identifier of the event. The second value is different from the value. The pre allocated block of memory is identified from the tree map using the unique identifier. The received block and at least one of the one or more previously compressed blocks is read from the identified pre allocated block of memory. A second pre allocated block of memory is selected. The received second block is compressed with the at least one of the one or more previously compressed blocks to create a second new compressed block. The second new compressed block is stored in the selected second pre allocated block of memory. A reference to the selected second pre allocated block of memory is stored in the tree map based on the unique identifier. A request for an update for the event based on the unique identifier is received from a requesting event client system. The stored second new compressed block is sent to the requesting event client system.

In another example embodiment a system is provided. The system includes but is not limited to a processor and a computer readable medium operably coupled to the processor. The computer readable medium has instructions stored thereon that when executed by the processor cause the system to serve data resources from a publishing system to a client system.

In yet another example embodiment a method of serving data resources from a publishing system to a client system is provided.

Other principal features of the disclosed subject matter will become apparent to those skilled in the art upon review of the following drawings the detailed description and the appended claims.

Referring to a block diagram of a stream processing system is shown in accordance with an illustrative embodiment. In an illustrative embodiment stream processing system may include a plurality of event publishing systems an event stream processing ESP device a resource server a plurality of event client systems and a network . In the terminology of representational state transfer REST stream processing system streams resource updates through a resource. The resource updates can be called events and they can be processed by the clients of event client systems as events. The client frequently requests a resource using a resource identifier and receives a representation of the event. The resource identifier describes a resource that is part of a larger resource and the described resource is the changes since a last change index as described further below.

For example the plurality of event publishing systems provide streamed data to ESP device . ESP device receives the streamed data performs analytic processing on the streamed data and provides processed streamed data to resource server . Resource server receives the processed streamed data pre renders and compresses the received streamed data and provides the pre rendered compressed data to one or more of the plurality of event client systems when requested. Each of the plurality of event publishing systems ESP device resource server and the plurality of event client systems may be composed of one or more discrete devices in communication through network .

Network may include one or more networks of the same or different types. Network can be any type of wired and or wireless public or private network including a cellular network a local area network a wide area network such as the Internet or the World Wide Web etc. Network further may comprise sub networks and consist of any number of devices.

The one or more computing devices of the plurality of event publishing systems may include computers of any form factor such as a server computer a desktop a smart phone a laptop a personal digital assistant an integrated messaging device a tablet computer etc. As shown referring to the plurality of event publishing systems can include any number and any combination of form factors of computing devices that may be organized into subnets. The computing devices of the plurality of event publishing systems send and receive signals through network to from another of the one or more computing devices of the plurality of event publishing systems and or to from ESP device . The one or more computing devices of the plurality of event publishing systems may communicate using various transmission media that may be wired and or wireless as understood by those skilled in the art. In an alternative embodiment stream processing system may not include ESP device and the computing devices of the plurality of event publishing systems send and receive signals through network to from resource server .

ESP device can include any type of computing device. For illustration represent ESP device as a server computer. In general a server computer may include faster processors additional processors more disk memory and more random access memory RAM than a client computer and support multi threading as understood by a person of skill in the art. ESP device sends and receives signals through network to from the plurality of event publishing systems and to from resource server . ESP device may communicate using various transmission media that may be wired and or wireless as understood by those skilled in the art.

Resource server can include any type of computing device. For illustration represent resource server as a server computer. Resource server sends and receives signals through network to from ESP device and to from the plurality of event client systems . Resource server may communicate using various transmission media that may be wired and or wireless as understood by those skilled in the art.

The one or more computing devices of the plurality of event client systems may include computers of any form factor such as a smart phone a desktop a server computer a laptop a personal digital assistant an integrated messaging device a tablet computer etc. As shown referring to the plurality of event client systems can include any number and any combination of form factors of computing devices. The computing devices of the plurality of event client systems may request data from resource server and in response receive data from resource server .

The computing devices of the plurality of event client systems send and receive signals through network to from resource server . The one or more computing devices of the plurality of event client systems may communicate using various transmission media that may be wired and or wireless as understood by those skilled in the art.

Referring to a block diagram of an event publishing system is shown in accordance with an example embodiment. Event publishing system is an example computing device of the event publishing systems . For example each of server computer desktop smart phone and laptop is an instance of event publishing system . Event publishing system may include an input interface an output interface a communication interface a computer readable medium a processor an event publishing application and data . Fewer different and additional components may be incorporated into event publishing system .

Input interface provides an interface for receiving information from the user for entry into event publishing system as understood by those skilled in the art. Input interface may interface with various input technologies including but not limited to a keyboard a mouse a display a track ball a keypad one or more buttons etc. to allow the user to enter information into event publishing system or to make selections presented in a user interface displayed on the display. The same interface may support both input interface and output interface . For example a display comprising a touch screen both allows user input and presents output to the user. Event publishing system may have one or more input interfaces that use the same or a different input interface technology. The input interface technology further may be accessible by event publishing system through communication interface .

Output interface provides an interface for outputting information for review by a user of event publishing system . For example output interface may interface with various output technologies including but not limited to display a speaker a printer etc. Event publishing system may have one or more output interfaces that use the same or a different interface technology. The output interface technology further may be accessible by event publishing system through communication interface .

Communication interface provides an interface for receiving and transmitting data between devices using various protocols transmission technologies and media as understood by those skilled in the art. Communication interface may support communication using various transmission media that may be wired and or wireless. Event publishing system may have one or more communication interfaces that use the same or a different communication interface technology. For example event publishing system may support communication using an Ethernet port a Bluetooth antenna a telephone jack a USB port etc. Data and messages may be transferred between event publishing system and ESP device or resource server using communication interface .

Computer readable medium is an electronic holding place or storage for information so the information can be accessed by processor as understood by those skilled in the art. Computer readable medium can include but is not limited to any type of random access memory RAM any type of read only memory ROM any type of flash memory etc. such as magnetic storage devices e.g. hard disk floppy disk magnetic strips . . . optical disks e.g. compact disc CD digital versatile disc DVD . . . smart cards flash memory devices etc. Event publishing system may have one or more computer readable media that use the same or a different memory media technology. For example computer readable medium may include different types of computer readable media that may be organized hierarchically to provide efficient access to the data stored therein as understood by a person of skill in the art. As an example a cache may be implemented in a smaller faster memory that stores copies of data from the most frequently recently accessed main memory locations to reduce an access latency. Event publishing system also may have one or more drives that support the loading of a memory media such as a CD or DVD an external hard drive etc. One or more external hard drives further may be connected to event publishing system using communication interface .

Processor executes instructions as understood by those skilled in the art. The instructions may be carried out by a special purpose computer logic circuits or hardware circuits. Processor may be implemented in hardware and or firmware. Processor executes an instruction meaning it performs controls the operations called for by that instruction. The term execution is the process of running an application or the carrying out of the operation called for by an instruction. The instructions may be written using one or more programming language scripting language assembly language etc. Processor operably couples with input interface with output interface with communication interface and with computer readable medium to receive to send and to process information. Processor may retrieve a set of instructions from a permanent memory device and copy the instructions in an executable form to a temporary memory device that is generally some form of RAM. Event publishing system may include a plurality of processors that use the same or a different processing technology.

Event publishing application performs operations associated with generating and or receiving data. The operations may be implemented using hardware firmware software or any combination of these methods. Referring to the example embodiment of event publishing application is implemented in software comprised of computer readable and or computer executable instructions stored in computer readable medium and accessible by processor for execution of the instructions that embody the operations of event publishing application . Event publishing application may be written using one or more programming languages assembly languages scripting languages etc.

Event publishing application may be implemented as a Web application. For example event publishing application may be configured to receive hypertext transport protocol HTTP responses and to send HTTP requests. The HTTP responses may include web pages such as hypertext markup language HTML documents and linked objects generated in response to the HTTP requests. Each web page may be identified by a uniform resource locator URL that includes the location or address of the computing device that contains the resource to be accessed in addition to the location of the resource on that computing device. The type of file or resource depends on the Internet application protocol such as the file transfer protocol HTTP H.323 etc. The file accessed may be a simple text file an image file an audio file a video file an executable a common gateway interface application a Java applet an extensible markup language XML file or any other type of file supported by HTTP.

The computing devices of the plurality of event publishing systems may receive data generated by a sensor generated or captured in response to occurrence of an event or a transaction generated by a device such as in response to an interaction by a user with the device etc. For example the computing devices of the plurality of event publishing systems may receive sales data as is it generated by a cash register may receive sensor data as it is sensed by a sensor may receive data generated by another device etc. Data may be sent to the plurality of event publishing systems from any data source and streamed to ESP device . As used herein data may include any type of content represented in any computer readable format such as binary alphanumeric numeric string markup language etc. The content may include textual information graphical information image information audio information numeric information etc. that further may be encoded using various encoding techniques as understood by a person of skill in the art. The computing devices of the plurality of event publishing systems further may generate data .

Referring to a block diagram of ESP device is shown in accordance with an illustrative embodiment. ESP device may include a second input interface a second output interface a second communication interface a second computer readable medium a second processor an ESP application and events . Fewer different or additional components may be incorporated into ESP device .

Second input interface provides the same or similar functionality as that described with reference to input interface of event publishing system though referring to ESP device . Second output interface provides the same or similar functionality as that described with reference to output interface of event publishing system though referring to ESP device . Second communication interface provides the same or similar functionality as that described with reference to communication interface of event publishing system though referring to ESP device . Data and messages may be transferred between ESP device and the event publishing systems and or resource server using second communication interface . Second computer readable medium provides the same or similar functionality as that described with reference to computer readable medium of event publishing system though referring to ESP device . Second processor provides the same or similar functionality as that described with reference to processor of event publishing system though referring to ESP device .

ESP device creates events from data received from event publishing systems . Second computer readable medium may provide the electronic storage medium for events .

ESP application performs operations associated with coordinating and controlling the performance of analytics on the data streamed from the plurality of event publishing systems and with sending the processed data to resource server based on a subscription request. ESP application may embed an ESP engine ESPE with its own dedicated thread pool or pools into its application space where the main application thread can do application specific work and the ESPE processes event streams at least by creating an instance of a model into processing objects. The operations may be implemented using hardware firmware software or any combination of these methods. Referring to the example embodiment of ESP application is implemented in software comprised of computer readable and or computer executable instructions stored in second computer readable medium and accessible by second processor for execution of the instructions that embody the operations of ESP application . ESP application may be written using one or more programming languages assembly languages scripting languages etc. ESP application for example may be implemented as a Web application. For illustration ESP application may be the SAS Event Stream Processing Engine developed and provided by SAS Institute Inc. of Cary N.C. USA.

Referring to example operations associated with ESP application are described. ESP application defines how input event streams from publishers are transformed into meaningful output event streams consumed by subscribers. Additional fewer or different operations may be performed depending on the embodiment. The order of presentation of the operations of is not intended to be limiting. A user can interact with one or more user interface windows presented to the user in a display such as display under control of ESP application independently or through a browser application in an order selectable by the user. Although some of the operational flows are presented in sequence the various operations may be performed in various repetitions concurrently and or in other orders than those that are illustrated. For example a user may execute ESP application which causes presentation of a first user interface window which may include a plurality of menus and selectors such as drop down menus buttons text boxes hyperlinks etc. associated with ESP application as understood by a person of skill in the art. As further understood by a person of skill in the art various operations may be performed in parallel for example using a plurality of threads.

In an operation ESP application defines and starts an ESP engine ESPE thereby instantiating an ESPE at ESP device . For example referring to the components of an ESPE executing at ESP device are shown in accordance with an illustrative embodiment. ESPE may include one or more projects . A project may be described as a second level container in an engine model managed by ESPE where a thread pool size for the project may be defined by a user. A value of 1 for the thread pool size indicates that writes are single threaded. Each project of the one or more projects may include one or more continuous queries that contain data flows which are data transformations of incoming event streams. The one or more continuous queries may include one or more source windows and one or more derived windows .

The engine container is the top level container in a model that manages the resources of the one or more projects . In an illustrative embodiment for example there can be only one ESPE for each instance of ESP application and ESPE has a unique engine name. Additionally the one or more projects may each have unique project names and each query may have a unique continuous query name and begin with a uniquely named source window of the one or more source windows . ESPE may or may not be persistent.

Continuous query modeling involves defining directed graphs of windows for event stream manipulation and transformation. A window in the context of event stream manipulation and transformation is a processing node in an event stream processing model. A window in a continuous query can perform aggregations computations pattern matching and other operations on data flowing through the window. A continuous query may be described as a directed graph of source relational pattern matching and procedural windows. The one or more source windows and the one or more derived windows represent continuously executing queries that generate updates to a query result set as new event blocks stream through ESPE . A directed graph for example is a set of nodes connected by edges where the edges have a direction associated with them.

An event object may be described as a packet of data accessible as a collection of fields with at least one of the fields defined as a key or unique identifier ID . The event object may be created using a variety of formats including binary alphanumeric XML etc. Each event object may include one or more fields designated as a primary identifier ID for the event so ESPE can support operation codes opcodes for events including insert update upsert and delete. Upsert opcodes update the event if the key field already exists otherwise the event is inserted. For illustration an event object may be a packed binary representation of a set of field values and include both metadata and field data associated with an event. The metadata may include an opcode indicating if the event represents an insert update delete or upsert a set of flags indicating if the event is a normal partial update or a retention generated event from retention policy management and a set of microsecond timestamps that can be used for latency measurements.

An event block object may be described as a grouping or package of event objects. An event stream may be described as a flow of event block objects. A continuous query of the one or more continuous queries transforms a source event stream made up of streaming event block objects published into ESPE into one or more output event streams using the one or more source windows and the one or more derived windows . A continuous query can also be thought of as data flow modeling.

The one or more source windows are at the top of the directed graph and have no windows feeding into them. Event streams are published into the one or more source windows and from there the event streams are directed to the next set of connected windows as defined by the directed graph. The one or more derived windows are all instantiated windows that are not source windows and that have other windows streaming events into them. The one or more derived windows perform computations or transformations on the incoming event streams. The one or more derived windows transform event streams based on the window type that is operators such as join filter compute aggregate copy pattern match procedural union etc. and window settings. As event streams are published into ESPE they are continuously queried and the resulting sets of derived windows in these queries are continuously updated.

ESP application may be developed for example using a modeling application programming interface API that provides a set of classes with member functions. As an example the SAS ESP Engine developed and provided by SAS Institute Inc. of Cary N.C. USA provides a modeling API that provides a set of classes with member functions. These functions enable ESP application to embed ESPE possibly with dedicated thread pools into its own process space. Alternatively ESPE can be embedded into the process space of an existing or a new application. In that case a main application thread is focused on its own chores and interacts with the embedded ESPE as needed.

Referring to in an operation the engine container is created. For illustration ESPE may be instantiated using a function call that specifies the engine container as a manager for the model. The function call may include the engine name for ESPE that is provided by a user or a developer and may be unique to ESPE .

In an operation the one or more continuous queries are instantiated by ESPE as a model. The one or more continuous queries may be instantiated with a dedicated thread pool or pools that generate updates as new events stream through ESPE . For illustration the one or more continuous queries may be created to model business processing logic within ESPE to predict events within ESPE to model a physical system within ESPE to predict the physical system state within ESPE etc. For example ESPE may be used to support sensor data monitoring and management e.g. sensing may include force torque load strain position temperature air pressure fluid flow chemical properties resistance electromagnetic fields radiation irradiance proximity acoustics moisture distance speed vibrations acceleration electrical potential or electrical current etc. capital markets trading systems fraud detection and prevention personalized marketing operational systems monitoring and management cyber security analytics etc.

To create a continuous query input event structures that are schemas with keys that flow into the one or more source windows may be identified. Output event structures that are also schemas with keys generated by the one or more source windows and or the one or more derived windows may also be identified. For example the block of code below illustrates creation of a compute window that normalizes a City field that is created for events in that window 

ESPE may analyze and process events in motion or event streams. Instead of storing data and running queries against the stored data ESPE may store queries and stream data through them to allow continuous analysis of data as it is received. The one or more source windows and the one or more derived windows may be created based on the relational pattern matching and procedural algorithms that transform the input event streams into the output event streams to model simulate score test predict etc. based on the continuous query model defined and application to the streamed data.

In an operation a publish subscribe pub sub capability is initialized for ESPE . In an illustrative embodiment a pub sub capability is initialized for each project of the one or more projects . To initialize and enable pub sub capability for ESPE a port number is provided. Pub sub clients can use a host name of ESP device and the port number to establish pub sub connections to ESPE . For example a server listener socket is opened for the port number to enable event publishing systems and resource server to connect to ESPE for publish subscribe services. The host name of ESP device and the port number to establish pub sub connections to ESPE may be referred to as the host port designation of ESPE executing at ESP device .

Publish subscribe is a message oriented interaction paradigm based on indirect addressing. Processed data recipients specify their interest in receiving information from ESPE by subscribing to specific classes of events while information sources publish events to ESPE without directly addressing the receiving parties. ESPE coordinates the interactions and processes the data. In some cases the data source receives confirmation that the published information has been received by a data recipient.

A publish subscribe API may be described as a library that enables an event publisher such as event publishing system to publish event streams into ESPE or an event subscriber such as resource server to subscribe to event streams from ESPE . For illustration one or more publish subscribe APIs may be defined. As an example a version of the SAS ESP Engine offered by SAS Institute Inc. can provide a C publish subscribe API and a Java publish subscribe API. Using the publish subscribe API event publishing application may publish event streams into a running event stream processor project source window of ESPE and resource server may subscribe to an event stream processor project source window of ESPE . The publish subscribe API provides cross platform connectivity and endianness compatibility between ESP application and other networked applications.

Referring again to operation initializes the publish subscribe capability of ESPE . In an operation the one or more projects are started. The one or more started projects may run in the background on ESP device .

In an operation an event block object is received from one or more computing device of the event publishing systems for example from event publishing system . An event block object containing one or more event objects is injected into a source window of the one or more source windows from an instance of event publishing application . The unique ID assigned to the event block object by event publishing system is maintained as the event block object is passed between the one or more source windows and or the one or more derived windows of ESPE . A unique embedded transaction ID further may be embedded in the event block object as the event block object is processed by a continuous query.

In an operation the event block object is processed through the one or more continuous queries . In an operation the processed event block object is output to resource server .

ESPE maintains the event block containership aspect of the received event blocks from when the event block is published into a source window and works its way through the directed graph defined by the one or more continuous queries with the various event translations before being output to subscribers such as resource server . Subscribers can correlate a group of subscribed events back to a group of published events by comparing the unique ID of the event block object that a publisher such as event publishing system attached to the event block object with the event block ID received by the subscriber.

In an operation a determination is made concerning whether or not processing is stopped. If processing is not stopped processing continues in operation to continue receiving the one or more event streams containing event block objects from the one or more computing devices of the event publishing systems . If processing is stopped processing continues in an operation . In operation the started projects are stopped. In operation ESPE is shutdown.

Referring to a block diagram of resource server is shown in accordance with an example embodiment. Resource server may include a third input interface a third output interface a third communication interface a third computer readable medium a third processor a resource service application a representation part space and one or more media types . Fewer different and additional components may be incorporated into resource server .

Third input interface provides the same or similar functionality as that described with reference to input interface of event publishing system though referring to resource server . Third output interface provides the same or similar functionality as that described with reference to output interface of event publishing system though referring to resource server . Third communication interface provides the same or similar functionality as that described with reference to communication interface of event publishing system though referring to resource server . Data and messages may be transferred between resource server and the event client systems and the plurality of event publishing systems or ESP device using third communication interface . Third computer readable medium provides the same or similar functionality as that described with reference to computer readable medium of event publishing system though referring to resource server . Third processor provides the same or similar functionality as that described with reference to processor of event publishing system though referring to resource server .

Resource service application may include one or more nozzles a response assembler and a request validator . The one or more nozzles response assembler and request validator of resource service application may be the same or different applications or part of an integrated distributed application. The streamed data may be received from ESP device or from one or more of the event publishing systems .

The one or more nozzles response assembler and request validator of resource service application perform operations associated with supporting receipt and processing of streamed data that includes events and provision of pre rendered and compressed events to one or more of the event client systems . Events define an event stream that may be described as a flow of event block objects where an event block object may be described as a grouping or package of event objects. A unique ID is assigned to the event block object and each event object of the event block object is also assigned a key or unique ID as discussed previously. The operations may be implemented using hardware firmware software or any combination of these methods. Referring to the example embodiment of the one or more nozzles response assembler and request validator of resource service application are implemented in software comprised of computer readable and or computer executable instructions stored in third computer readable medium and accessible by third processor for execution of the instructions that embody the operations of resource service application . The one or more nozzles response assembler and request validator of resource service application may be written using one or more programming languages assembly languages scripting languages etc. The one or more nozzles response assembler and request validator may be written using different languages. One or more of the nozzles response assembler and request validator of resource service application may be implemented as Web applications.

Execution of resource service application may instantiate a microservice that serves resources that rapidly change. For example resource service application provides high throughput event streams to user interface UI clients executing at one or more client system of the event client systems . The resource is representation part space where a new event object includes a unique key such as the key or unique ID defined by the event publishing system that generated the event object and maintained through ESPE so that resource service application can replace a previous version of the event object. The possible scenarios supported by resource service application may arise from two dimensions a refresh rate supported by a client system of the event client systems and a number of concurrent client systems of the event client systems that are using stream processing system . The number of concurrent client systems is bounded only by hardware capacity so more devices of the event client systems can be served by scaling vertically and or horizontally.

Resource service application can be used for example to support a stock ticker at a low refresh rate to any number of computing devices of event client systems . Resource service application further can be used for example to support real time visualization applications such as augmented reality to any number of computing devices of event client systems over network . For example visualizations may appear and disappear rapidly based on head movement.

In an illustrative embodiment resource service application fits the REST architectural style language as a connector of type server. Resource service application may co exist with the other connector types client cache resolver and tunnel subject to the REST architectural style the HTTP and HTTPS protocols and the potentially changing architecture of network .

Referring to a block diagram of an event client system is shown in accordance with an example embodiment. Event client system is an example computing device of the event client systems . For example each of smart phone desktop server computer and laptop is an instance of event client system . Event client system may include a fourth input interface a fourth output interface a fourth communication interface a fourth computer readable medium a fourth processor a client application one or more events schemata and data . Fewer different and additional components may be incorporated into event client system .

Fourth input interface provides the same or similar functionality as that described with reference to input interface of event publishing system though referring to event client system . Fourth output interface provides the same or similar functionality as that described with reference to output interface of event publishing system though referring to event client system . Fourth communication interface provides the same or similar functionality as that described with reference to communication interface of event publishing system though referring to event client system . Data and messages may be transferred between resource server and event client system using fourth communication interface . Fourth computer readable medium provides the same or similar functionality as that described with reference to computer readable medium of event publishing system though referring to event client system . Fourth processor provides the same or similar functionality as that described with reference to processor of event publishing system though referring to event client system .

Client application may include a poller a response handler and a request dispatcher . Poller response handler and request dispatcher of client application may be the same or different applications or part of an integrated distributed application.

Poller response handler and request dispatcher of client application perform operations associated with requesting new events and receiving pre rendered and compressed events from resource server . The operations may be implemented using hardware firmware software or any combination of these methods. Referring to the example embodiment of poller response handler and request dispatcher of client application are implemented in software comprised of computer readable and or computer executable instructions stored in fourth computer readable medium and accessible by fourth processor for execution of the instructions that embody the operations of client application . Poller response handler and request dispatcher of client application may be written using one or more programming languages assembly languages scripting languages etc. Poller response handler and request dispatcher of client application may be written using different languages. One or more of poller response handler and request dispatcher of client application may be implemented as Web applications.

Client application may adhere to the REST architectural style. The REST uniform contract is based on three fundamental elements 

An event schema provides a description of the semantics and format of a type of event event block object . An event of events agrees with an event schema of events schemata that affects a state change. Representation part space contains a set of uniquely keyed event objects for the type of event. In REST terms an event is PUT into representation part space . Representation part space may be a REST resource and an event space resource can be part of an encompassing resource. The latter arrangement allows for pertinent metadata to be shared and for multiple event spaces to be passed to event client system in a single response. Each event schema of events schemata codifies an event type for the type of event.

A media type of media types is a RESTful media type that describes the semantics and format of a type of representation. A representation is a RESTful representation that represents a resource at a point in time based on a media type. A media type contains one or more event schemas of events schemata . Both serve as a contract between client application and resource service application . Representations contain events of one or more media type. Example media types include JavaScript object notation JSON plain text XML an image file format such as JPG etc. Media types can also be developed for specific cases. For example a JSON media type can represent the layout of an industrial space. A representation of the media type may represent a particular layout of a particular industrial space.

JSON is an open standard data interchange format that uses human readable text to transmit data objects consisting of attribute value pairs. JSON is used primarily to transmit data between a server and a web application and as an alternative to XML. Although originally derived from the JavaScript scripting language JSON is a language independent data format.

JSON is built on two structures 1 a collection of name value pairs and 2 an ordered list of values. In various languages the collection of name value pairs is realized as an object record struct dictionary hash table keyed list or associative array. In most languages the ordered list of values is realized as an array vector list or sequence. These are universal data structures supported by virtually all modern programming languages in one form or another.

In JSON an object is an unordered set of name value pairs. An object begins with a left brace and ends with a right brace . Each name is followed by a colon and the name value pairs are separated by a comma in the form string value string value . . . string value .

Referring to a block diagram illustrating the interactions between the components of resource server and each event client system of the event client systems is shown in accordance with an illustrative embodiment. Events are received from ESP device or from the event publishing systems .

Nozzles make representations of each event object of events for a particular media type of media types and store the representations in representation part space . Nozzles may be pluggable for the different media types. Nozzles operate in the same address space as the rest of the components of resource service application and are called via a by reference as opposed to a by value API. A nozzle of nozzles pre renders parts of a representation in accordance with the event schema and media type of the event object. The nozzle pre rendering includes rendering of compressed blocks. For example gzip compression may be used to minimize the amount of redundant compression work.

Poller repeatedly polls for the latest version of a resource event object of representation part space . For UIs the polling for the resource may correspond to the refresh rate or frame rate of the display connected through output interface or communication interface of event client system . Each representation is a snapshot of a stream resource at a point of time. Each event client system of the event client systems may receive the same or a different series of representation parts. Poller triggers request dispatcher to dispatch a request e.g. a GET to resource server . Multiple requestor threads can dispatch simultaneous requests from request dispatcher .

Request validator receives the request from request dispatcher and validates the request. An authorization service may confirm that each event client system of the event client systems is authorized to receive events from representation part space initially using a separate service. The authorization information may be injected into request validator for processing. Request validator may be pluggable using a by reference API. New methods for validating requests can be introduced by adding a new request validation method to request validator .

Response assembler receives the validated request and selects one or more events from representation part space to send to the requesting event client system . The request may include parameters that exclude events from the response. For example some events may not be within a graphics clipping region and as a result do not need to be included and sent to the requesting event client system because the requesting event client system will not use the event object. The appropriate nozzle of nozzles is called by response assembler to make representations of the selected one or more representation parts representing events based on the media type of the nozzle. Response assembler very quickly assembles the representation out of pre rendered parts.

A handler of response handler receives the representations from response assembler and handles the representation for example by using events schemata to define data that may be consumed by another application such as a UI application. Response processing may be handled on a main thread of event client system which may apply the response to an object model. A renderer may read the object and operate using WebGL to affect graphics managed by a graphical processing unit GPU on the display accessible by event client system .

To optimize the throughput the representation or data structure defining the event object based on the media type is optimized. There are two parts to the optimization optimizing the creation of the representation and optimizing the handling of the representation. Resource service application and client application create optimized media types and plug them into already optimized frameworks for creating and consuming the media types. This flexibility means that performance does not suffer due to a sub optimal least common denominator media type. Creating the final representation in response to a request occurs on a separate thread from that executing nozzles as discussed further below.

Stream processing system performs better when optimized data structures that can be quickly rendered by graphics software on event client system are used. The client processing capacity of event client system should be minimally occupied with transformation from one data structure format to another. Instead the media type is optimized so that application of the representation to the geometric data structures supported by event client system is fast. Thus the definition of the media type can be primarily driven by performance considerations of rendering the graphics. The nozzle handles the optimizations when the events are being readied for transmission to requesting event client system for example as JSON. The events may be sensor data streamed in a binary format that is converted to JSON by the nozzle before transmission to event client system .

Referring to example operations associated with execution of resource service application are described. Additional fewer or different operations may be performed depending on the embodiment. The order of presentation of the operations of is not intended to be limiting. Although some of the operational flows are presented in sequence the various operations may be performed in various repetitions concurrently and or in other orders than those that are illustrated. As further understood by a person of skill in the art various operations may be performed in parallel for example using a plurality of processors and or a plurality of threads.

In an operation a request validator instance of request validator is instantiated to receive requests from request dispatcher executing at event client system . In an operation a response assembler instance of response assembler is instantiated to assemble and send the response to response handler executing at event client system . The instantiated request validator instance and the instantiated response assembler instance may be associated with one or more nozzle instance of nozzles .

In an operation a request is received by the request validator instance from request dispatcher . The resource requested is modified with changes since followed by a last event index. For example changes since 0 includes the last event index of 0 and returns all of the events in representation part space . The last event index indicates the last change index that the requesting event client system has received.

In an operation a determination is made concerning whether or not the request is for a new resource. For example a first request for the resource may be sent as part of an initial communication between resource server and event client system . If the request is for a new resource processing continues in an operation . If the request is not for a new resource processing continues in an operation .

In operation ESPE is queried for example to discover names of projects of continuous queries of windows of window schema and of window edges currently running in ESPE . The host name of ESP device the engine name of ESPE and the port number opened by ESPE may be provided as an input to the query and a list of strings may be returned with the names to the projects continuous queries windows window schema and or window edges.

In an operation a nozzle instance is instantiated for the resource and mapped to the base URI for the stream that the nozzle instance serves. While a nozzle is specific to a particular media type there may be multiple streams that are expressed as the same media type. For example each nozzle instance is associated with a media type of media types . The media type may include one or more event object type schemas.

For example the event type may be defined for a type of commodity and is keyed with a commodity symbol. The type is implemented as a string variable and a map of value names and values. Within a JSON media type the event schema could be realized as an array of JSON objects as shown for illustration below 

Alternatively the event data could be communicated in a tabular form. In this case one object in the JSON document defines the column names for all symbols 

Depending on factors related to event client system including parsing implementation and expected programmatic use of the objects the best form can be selected by the API developer.

Each nozzle of nozzles is an independent component that handles the preparation of representations of each event object for a particular media type. By being independent a new media type can be plugged in to resource server without requiring changes to the rest of the infrastructure.

Referring to each nozzle includes an abstract nozzle implementation and a concrete nozzle implementation. A new media type can be introduced by adding a new nozzle to nozzles . A new nozzle is a new class that inherits from abstract nozzle implementation . A plurality of nozzles nozzle nozzle . . . nozzle n may be instantiated at resource server to each process a different media type of media types . For example each nozzle of the plurality of nozzles nozzle nozzle . . . nozzle n is based on abstract nozzle implementation and a corresponding concrete nozzle implementation concrete concrete . . . concrete n respectively based on a media type media type . . . media type n respectively.

Multi threading and concurrency are handled by abstract nozzle implementation while rendering of representation parts is handled by concrete concrete . . . concrete n determined from a corresponding event schema of events schemata . Each nozzle of nozzles is encoded with specific knowledge of a media type the event schemas of the incoming stream and the equivalent event schema of the media type. Concrete concrete . . . concrete n derive from abstract nozzle implementation which is common to all nozzles . Abstract nozzle implementation controls the thread so that concrete concrete . . . concrete n can focus solely on making representation parts for each event object of the event.

For illustration referring to abstract nozzle implementation is based on an abstract nozzle class and each of concrete concrete . . . concrete n are based on a concrete nozzle class . Concrete nozzle class may include a renderEvent method . Abstract nozzle class may include a run method a queueEvent method a drainEvents method a writeChangedEvents method a readOnlyTreeMap member and a writeOnlyTreeMap member . Concrete nozzle class may include a renderEvent method . Abstract nozzle class further may include a queue object created when each concrete nozzle is instantiated based on a queue object class and a tree map created when each concrete nozzle is instantiated based on a tree map class . Queue object class may include a readOnlyQueue member and a writeOnlyQueue member .

 run method executes a body of an infinite loop of a rendering thread. The core of the method is a call to drainEvents method followed by a call to writeChangedEvents method . The remainder of run method performs error handling.

 queueEvent method is called on a subscriber thread and appends a single event object on a write only queue identified by a value of writeOnlyQueue member .

 drainEvents method drains events from a read only queue identified by a value of readOnlyQueue member .

 writeChangedEvents method writes the representation parts that represent the events so that they are available for requests.

 renderEvent method is implemented by a concrete nozzle to render a single event object to a representation part. For example the incoming event is a commodity trading symbol and includes several updated values pertaining to the commodity in a certain market. Event client system has a unique n dimensional visualization for the commodity such as a polyhedron with spikes representing n 3 values and a position of the polyhedron representing the remaining 3 values. A developer only needs to write an implementation for renderEvent method to be able to communicate an optimal data structure over the standard Web in fixed memory event space with the possibility of scaling to an unbounded number of users at high throughput rates.

Abstract nozzle implementation defers to the concrete nozzle implementation for rendering the incoming event object as a representation part according to the rules of the event schema for the nozzle s media type. For example an event block of events that carries a payload of 10 numeric values of different numeric types and 2 character fields may be rendered as a textual JSON snippet. Each of the twelve event objects includes a different key. Each event object may be updated at different times.

The components of stream processing system understand how to interact with abstract nozzle implementation and a new nozzle acts concretely for a given media type and specific event schemas. Each nozzle instance runs on its own thread and receives events and renders them in a logical form that is ready for compression and encryption. For example for a JSON based media type that transports numerical event data the nozzle renders incoming data that may be in various formats as character data agreeing with the rules of JSON as well as rules of the media type.

Referring again to in an operation the queue object is created for the nozzle instance such as for concrete inheriting from abstract nozzle implementation as part of processing by run method . In an operation the read only queue and the write only queue are created for the queue object of the nozzle instance. The write only queue is contained inside the queue object and is paired with the read only queue. The value of readOnlyQueue member includes a reference or a pointer to the created read only queue. The value of writeOnlyQueue member includes a reference or a pointer to the created write only queue.

The queue object manages these two queues on behalf of the nozzle. For example referring to a queue object is created by nozzle that is an instance of concrete based on media type . Queue object may include a read only queue and a write only queue . Each nozzle creates its own queue object and corresponding read only queue and write only queue.

In an operation subscription services are initialized for the nozzle instance. For example a subscription capability is initialized to each project of the one or more projects of ESPE based on the request from event client system .

In an operation a subscriber thread is created and started that is dedicated to receiving events from ESP device for handling by the nozzle instance. The subscriber thread is started for the subscription connection to ESPE . The initialized subscription services are started for the subscriber thread. To start the subscriber thread and the initialized subscription services a port number is provided. For example the request from event client system may include a host name of ESP device and the port number to establish a subscription connection to ESPE .

Referring to operations to are executed by the started subscriber thread. Each nozzle instance runs a loop on its subscriber thread that may consume all available central processing units CPUs for the thread or that may be throttled to limit the consumption of available CPUs by the nozzle. The throttling can be configured by a user such as a system administrator by defining a period of time for the subscriber thread to sleep before beginning a new cycle of its work loop. By default the sleep time is zero so that the subscriber thread consumes as much processor time as allowed. Throttling increases a latency of event delivery but allows stream processing system to handle more event streams.

In an operation an event block of events is received by the started subscriber thread from ESPE . As discussed previously the event block includes a unique identifier of a type of event and the subscriber thread of the nozzle instance is configured to process the event block based on a media type of the type of event indicated by the unique identifier.

In an operation an event object is selected from the received event block that may contain one or more event objects. Each event object in the received event block has an event schema of events schemata and a key that is unique across representation part space .

For example a symbol for a commodity can be a key for a current price of the commodity on a market. Keys can also be compound. Client systems that wish to render multi dimensional displays of values can utilize compound keys. For example a plane on a client can display a 3D heat map where each vertex expresses two current social media quantitative values such as interactivity level and predilection to buy a certain type of service in aggregate at the intersection of two dimensions such as household income and education level. One quantitative level is expressed as the z value for each plane vertex where the x and y values of the vertices represent the two dimensions. The event key could be a compound key of the two dimensions household income and education level.

In an operation the selected event object is written to the write only queue. For example nozzle writes the selected event object to write only queue with a change index value.

In an operation a change index value is incremented so that a unique value is associated with each received event object. The change index value for a new incoming event object is one greater than the last change index value for the event stream. To maximize incoming throughput event objects are not checked to see if they are redundant at this point two events with the same key may exist in the write only queue.

In an operation a determination is made concerning whether or not the received event block includes another event object. If the received event block includes another event object processing continues in operation to select the next event object from the received event block and write the next event object to the write only queue. If the received event block does not include another event object processing continues in an operation .

In operation a determination is made concerning whether or not a request to drain the queue has been received as discussed further below. If a request to drain the queue has been received processing continues in an operation . If a request to drain the queue has not been received processing continues in operation to continue accumulating event block objects onto the write only queue such as write only queue

In an operation the queue object such as queue object toggles read only queue and write only queue by making the current write only queue read only queue and by making the cleared read only queue the current write only queue . For example the values of readOnlyQueue member and writeOnlyQueue member are switched.

In an operation the current write only queue is unblocked and processing continues in operation to continue accumulating event block objects onto the write only queue such as write only queue that was previously read only queue before the toggle or switch.

Referring again to in an operation a rendering thread is started for the nozzle instance. Referring to operations to may be executed by the started rendering thread. The rendering thread is dedicated to processing received events stored for example in write only queue

In an operation the request to drain the queue is sent to the subscriber thread. For example the request to drain the queue is sent when nozzle asks queue object for access to read only queue

In an operation the rendering thread acquires a write only tree map. For example referring to the rendering thread of nozzle acquires a write only rendered event tree map using writeOnlyTreeMap member .

In an operation an event object is read from the read only queue. For example the rendering thread of nozzle reads from read only queue which was just toggled from write only queue and contains the event objects received since the last request to drain the queue was sent in operation .

In an operation the rendering thread renders the read event object from the read only queue into its representation form such as a JSON snippet. For example nozzle renders the read event object based on the event type of the event object using renderEvent method according to the rules of the event schema for the nozzle s media type. The event schema is a definition that is encompassed in the definition of the overall media type. For example an event object may have an event schema that defines five named values that are a mix of numeric and character types. Such an event can be rendered as a JSON array. Representation part space for such events can be rendered as an array of arrays. An additional JSON object can specify the names common to the values of all of the events. An event schema can be shared across more than one media type.

An event type is a data structure native to a programming language. It can be sent to resource server in any number of formats including binary formats specific to the programming language used. In a system that needs to minimize latency the original event type may be binary and optimized for minimal travel time from the original source such as a sensor. To reach requesting event client system that is a web browser compressed JSON may be the best data structure format because web browsers are optimized to handle input as JSON after the text has been decompressed. Sending binary data to the web browser may be more optimal but the binary data is transformed into Javascript native data structures by a Javascript interpreter. JSON on the other hand is already native to Javascript. Thus transforming the event from a programming language data type to a JSON data type may be performed by the nozzle to ensure optimized transfer of an event object from a source through analytics and to requesting event client system that is a web browser.

In operation a determination is made concerning whether or not the event object includes a new key. If the event object includes a new key processing continues in an operation . If the event object does not include a new key processing continues in an operation .

In operation the rendering thread allocates a character buffer in representation part space and identifies a pointer to the allocated character buffer when JSON objects are used to represent the event. The buffer may include other data types based on the media type definition of the event type of the event object.

In an operation a reference to the allocated character buffer is added to the write only tree map such as write only tree map

In operation the rendering thread stores or updates the rendered event in the allocated character buffer in representation part space . The allocated character buffer is updated when the event object does not include a new key. Redundant events in the queue are not included in the write only tree map because only the last event object for a particular event key is added to the write only tree map.

In an operation the change index value associated with the allocated character buffer is updated to the change index value associated with the event object read in operation . The most recent event object representation in the write only tree map can be indexed by both the event key and the change index.

In an operation a determination is made concerning whether or not the read only queue includes another event object. If the read only queue includes another event object processing continues in operation to select and render the next event object from the read only queue. If the read only queue does not include another event object processing continues in an operation .

A read only tree map is also created by each nozzle within third computer readable medium . For example referring to the rendering thread of nozzle can also create and acquire a read only tree map using readOnlyTreeMap member . After the concrete nozzle has rendered a representation part for each event in the read only queue such as read only queue control returns to the abstract nozzle to commit write only tree map

Referring again to in an operation the rendering thread blocks incoming requests to the write only tree map. In an operation the rendering thread toggles for example read only tree map and write only tree map by making the current write only tree map read only tree map and making the cleared read only tree map the current write only tree map . For example the values of readOnlyTreeMap member and writeOnlyTreeMap member are switched. This process may be referred to as committing write only tree map

In an operation the write only tree map is unblocked and processing continues in operation to commit the next event objects to the write only tree map. Read only tree map is now ready to service requests from request dispatcher for ordered lists of events.

As discussed earlier the committing occurs as the last step of taking the events in the read only queue and putting them in the write only tree map based on their keys. The committing is a function of how quickly events are coming into the read only queue and how long it takes to put all of them into the write only tree map. While committing is taking place events continue to queue in the write only queue. Operations handle a great deal of the work of publishing events that is typically handled by a requestor thread while minimizing the blocking of both incoming event receipt and requests from the requestor thread. While only one nozzle may be the writer for any particular write only tree map multiple nozzles of nozzles may write and commit rendered events to multiple write only tree maps.

Referring again to in an operation a requestor thread is acquired from a pool of threads that may have been created when the response assembler was instantiated.

In an operation one or more rendered event objects that are responsive to the received request may be selected by the requestor thread. For example response assembler requests a list of keys from the read only tree map whose representation parts have changed since the last change index that the requesting event client system received and that was identified in the request. An example requesting event client system can provide filter parameters in the request that exclude representation parts by criteria related to the key. For example a viewer type of requesting event client system may determine that certain representation parts would never be rendered because they are outside a clipping region so clipping region identification information is included in the request as a filter.

In an operation a determination is made concerning whether or not an existing compressed block exists that includes the one or more rendered event objects that are responsive to the received request. If an existing compressed block exists that includes the one or more rendered event objects that are responsive to the received request processing continues in operation . If an existing compressed block exists that includes the one or more rendered event objects that are responsive to the received request processing continues in an operation .

In an operation the selected one or more rendered events are read from the representation part space using the references identified from the read only tree map. Response assembler requests each representation part in the ordered list from the read only tree map that is current at the time of the request using a key included in the request to lookup the reference to the allocated character buffer in which the key s data is stored. In assembling the representation requests may be made against multiple read only tree maps as the rendering thread may be toggling the write only and read only tree maps in operation while the response is being assembled. The media type can optionally define a change index field for each representation part so that a client can sort the representation parts by change indices.

This design allows resource server to work with fixed memory while maintaining low latency to support UI clients that make figurative displays from high data volume that is quickly changing. For example requesting event client system may render thousands or even millions of data values each second.

In an operation the read one or more rendered events are compressed optionally encrypted and stored in third computer readable medium for potential reuse.

Response assembler defers to the nozzle instance for the compression encryption and concatenation of representation parts. For example for a JSON based media type that encodes the event space as an array of arrays the nozzle instance handles the placement of a comma between arrays.

Blocks of compressed representations of the rendered events may be stored in third computer readable medium . For example the compression may follow the gzip standard which is the prevalent compression standard for the Internet. Gzip blocks are 32 kilobytes or less in size. A compression optimizer module may be included as a sub component of response assembler . The compression optimizer module determines how to make new compressed blocks of the right level of compression. The correct level of compression is a balance between having large blocks that compress better and smaller blocks that are less likely to be invalidated by the arrival of a new event. The compression optimizer module which can be plugged in can use static settings for optimal and mandatory block sizes or can derive them using knowledge of the event content observation of actual data compression etc. If the compression optimizer module knows that the space of possible event values is small a smaller dictionary results which can extend across larger blocks. Conversely a larger space could mean that smaller blocks would work better. If the compression optimizer module detects or is told that a large portion of an event space is slowly changing that part of the representation can be compressed in a larger set of blocks. Beyond what can be detected or known based on data structure the compression optimizer module can also observe how well the data is compressing and experiment on different block sizes until better compression is achieved.

The compression optimizer module also balances compression optimization with inbound event throughput. On a busy system many requests may come in between commits of the write only tree map. While initializing event client systems may need to retrieve all of the rendered events stored in representation part space most of event client systems will have already started polling and only need changes that have not yet been seen by that event client system.

To prevent duplicate work in compressing the data compressed blocks may be re used in a lazy fashion. An incoming request uses an available compressed block if available. If not available a new compressed block is simultaneously written to the output stream and to a new compressed block which is then available for re use.

The compression optimizer module begins with knowledge of the number of representation parts or unique keys. On the initial creation of blocks all of the blocks may be the optimum size until the end of the list. The final block can be created such that it is within the minimum size value and the maximum size value. On subsequent passes the index of the next block is compared to the next keys in the list. If they don t match the block is invalidated. Each mismatch is one less representation part in a new block. When there are so many mismatches that the minimum size has been reached a new block is created. When the reconstruction of the invalid block completes the index of the next block is used and the process repeats.

Blocks tend to get smaller until they reach the minimum size and are then combined. Response assembler can combine blocks between optimum and minimum size on a pass at the cost of adding latency of event delivery when adjacent blocks whose contents can be combined into optimum or near optimum size regardless of whether the contents need to be updated. The content of the adjacent blocks are copied to the new block and the old blocks are deleted. The near optimum range can be configured by a system administrator with a range of 0 tuning the behavior.

The range can also be computed. One possible way to compute the range is to observe the time cost of sending smaller blocks that are less compressed versus optimally sized blocks and comparing that time cost to the latency introduced by taking the time to combine blocks.

Referring again to at commit time a first block includes the value of keys A B and C a second block includes the value of keys D E and F and a third block includes the value of keys G H I and J . The first second and third blocks are valid after commit time .

At commit time a single new event object was received and processed. The value of key I is changed from zero to one. The change index 8 is no longer valid and the block that includes I is invalidated even though the value of keys G H and J have not changed.

The arrows between cells illustrate the blocks that a new event client system of event client systems receives when connecting and sending changes since 0 after commit time and before commit time . The first block that includes keys A B and C and the second block that includes keys D E and F blocks are re used while two new blocks are generated. A fourth block is created that contains only keys G and H even though those values haven t been changed. A fifth block is created that contains keys J and I even though only key I has changed. The first second fourth and fifth blocks are valid after commit time .

After commit time and before commit time keys B C and D changed which results in two new blocks and the re use of two blocks. A sixth block is created that contains keys A E and F so that the block has an optimal size of 3 and includes the unchanged keys. The fourth block and the fifth block can be re used. A seventh block is created that contains keys B C and D . The fourth fifth sixth and seventh blocks are valid after commit time .

After commit time and before commit time only key I has changed. This invalidates the fifth block. Key J must be combined in a block with another value or it will be in a block with less than the minimum size. An eighth block is created that contains keys J and B because B is in the last created block and achieves the minimum size value. This invalidates the seventh block. A ninth block is created that contains keys C D and I . . The fourth sixth eighth and ninth blocks are valid after commit time .

After commit time all of the blocks are invalidated because a value changed in the sixth block key E the fourth block key G the eighth block key I and the ninth block key C .

The polling rate may be non deterministic so that each event client system of event clients systems can have a different request rate. For example four different event client systems of event clients systems initiate at commit time zero but each can make their next call at a different time. Each would ask for changes since 9 but each receives a different response based on the time of the request. If the requests are received at times 150 ms 250 ms 350 ms and 450 ms respectively the fastest client client would make its next request as changes since 10 . If its rate holds constant it would come in at time and make the request changes since 14 . The slowest client would make its next request as changes since 9 and its subsequent request as changes since 18 .

In general client requests other than initial requests will not align with block boundaries such that the first block almost always need to be generated in an ad hoc manner. Memory permitting the initial ad hoc block can be stored for example in third computer readable medium for possible re use by other client requests that make exactly the same request during the same commit time period.

Resource server may not guarantee delivery of any particular event to any particular client system of event clients systems nor does resource server guarantee delivery of a particular event to a particular client system. An event client system of event clients systems is less likely to receive all events when representation part space is changing more rapidly and or the event client system is polling less frequently.

The event flow is expected to be non deterministic. Representation part space can change more frequently than any event client system of event clients systems polls for changes. Each event client system of event clients systems can be expected to have widely varying refresh rates due to networking speeds processing speeds and other factors. For a particular event client system a particular event could be 

In some cases though the event stream is slow enough and the event client systems of event client systems are fast enough such that each event client system receives responses for all events.

A RESTful caching intermediary may hold a cached copy of rendered events but a fast moving stream means less caching unless there is a very large number of clients. The resource that is being requested is changes since last event index N and different event client systems of event client systems likely request and process rendered events at different rates. When N is the same and within a small timeout window the cache copy may be used.

For any particular commit the efficiency of compression block re use is dependent on the events that are received. For example the commit at commit time invalidates every block. Smaller block sizes are better for re use because a block is less likely to be invalidated. But gzip compressed blocks are better compressed if they are larger dependent on the data.

Optionally resource service application can persist each rendered event that has had at least one request at the cost of some dedicated processor time possibly consuming entire processors increased memory usage to store representation part space possibly increased latency of streaming events greater system complexity and compression minimization.

In an operation a response shown with reference to is created from the stored compressed read one or more rendered events. Response assembler may combine the selected compressed blocks and possibly data directly from read only tree map . Response assembler may merge the representation of events with template content. Template content includes generally static information sent initially to the requesting event client system from event publishing systems . One example of a template is a diagnostic template versus an optimized template. The diagnostic template substitutes in diagnostic values such as queue lengths and a duration of a response assembly at an end of the representation while the optimized template does not. Other templates may include differing links to other resources where the links are global to the resource and not specific to individual events.

In an operation the response that includes one or more compressed blocks is sent to response handler executing at event client system that originated the received request. For example the requesting event client system is sent response over HTTP or HTTPS after being compressed as discussed previously. When response is received response handler hands individual events to an event feed that may send the events to an object model. The object model updates values. The next time a renderer at event client system is called the updated values may be rendered by the GPU of event client system .

In an operation a determination is made concerning whether or not processing is stopped. If processing is not stopped processing continues in operation to continue receiving requests for resources. If processing is stopped processing continues in an operation . In operation the connection made between resource service application and ESPE is disconnected the started threads are stopped etc.

Any type of event client system that is tolerant of a non deterministic stream can utilize resource server . Resource server can be used to provide a real time detail oriented highly figurative interactive view of a data stream using video game technologies and techniques including 3D graphics in HTML5 web browsers using WebGL and immersive virtual reality. A UI event client system purposed for presentation of information to human users at frame rate are naturally tolerant of a non deterministic stream. Poller and a renderer of event client system can be thought of as two gears working in concert to get events to the human eye.

A DataWorld is a world made out of data. The techniques of gaming and virtual worlds are utilized to afford new ways of perceiving data. In appearance and functionality a DataWorld is most similar to virtual worlds but the DataWorld concept overlaps with that of a virtual world rather than being a type of virtual world.

The renderer presents a high throughput stream with highly interactive 3D techniques common to gaming based on receipt of responses . Sensors that provide data need not be physical sensors they can be software sensors embedded in operational software systems such as an e commerce web site a firewall or real time fraud detection system etc.

For example the renderer may present a visual presentation of data received in responses that is somewhat similar to an office window looking out onto a factory floor. The elements that contain sensors may be arranged relative to an XZ plane just as the factory floor is an XZ plane. Real time analytics are displayed in a manner similar to augmented reality. The data values are connected to and contextualized by the graphic elements which are presented using virtual world techniques. Users explore their DataWorld by navigating a camera in 3D selecting elements and value ranges for emphasis and varying the UI between broad situational awareness and focus on specific details.

Users bind an instance of their DataWorld to a particular stream by selecting a stream URI and mapping the stream metadata to visual elements. The visual elements are bound to image URIs for example high contrast low detail technical diagrams that illustrate the locations of individual sensors.

Each graphical object of the UI event client system may have a single event rendering thread but an overall object graph does not necessarily need to be consistent. Thus the UI event client system can include multiple event rendering threads that can consume an entire processor or that can share processors. For any sub graph that must be consistent all objects in such a sub graph share a single event rendering thread. Feeder threads can pipeline object state changes. Feeder threads can act as single event rendering threads on any streaming objects.

Localization of string labels can be approached in one of several ways depending on the characteristics of labels for the data. First the localized labels can simply arrive in the event payload and no localization is required. The nozzle passes them on as if they were any other data. This approach has the disadvantage of possibly repeatedly sending the same label data over and over. For a label heavy system this may affect performance.

Alternatively a bundle of localized string labels can be its own resource or resources that the event client system accesses prior to needing any labels. The labels are referenced with keys that are known to the event producer. The nozzle passes the keys along which are matched to labels by requesting event client system . This works when all possible labels that requesting event client system may need are known beforehand and there are a relatively small number.

Another option is to involve the nozzle in providing the labels during processing. When encountering a field that is designated as a label field the concrete nozzle defers to the abstract nozzle to ensure that a link to a resource containing the correct label for the language used by requesting event client system is provided in the representation. Requesting event client system can access the resource containing localization if it does not already have the resource or if it has a stale copy in accordance with the rules of HTTP.

By utilizing event processing system events from data streams can modify arbitrary geometries that are developed in an ad hoc fashion. A developer can create a media type that best fits the new geometry along with the graphics coding to render the geometry across different graphics platforms including fully immersive VR headset environments broadly available web browsers supporting WebGL and any other high performance 2D or 3D graphics rendering technology. The nozzle takes care of translating the event to media type representation parts and the rest of the system ensures low latency and scalability to an unbounded number of users.

For example a DataWorld can consist of an unbounded number of polyhedrons that each express n dimensions with spikes originating from the center. Each polyhedron is grouped into one space of an unbounded number of spaces and positioned along relative XYZ coordinates in that space. Each space is positioned by XYZ coordinates relative to the parent space. Spaces can recurse until the absolute space of the graphics renderer is reached. The polyhedrons can be connected with lines that cross spaces. An orthogonal surface can cross the spaces. The relative Z value of each vertex represents the value of the XY pair.

On the event side each polyhedron spike could represent a normalized value for a category of a business object such as an account. The hierarchy of geometric spaces mirrors a hierarchy of accounts such as the management hierarchy of a financial institution s organization serving the accounts. The position in relative space is an additional 3 dimensions for each account such as account lifespan fraud propensity score and current value of account assets. The orthogonal plane shares the Y axis fraud propensity score and indicates a granular likelihood based on history for the score at a particular spot in space. The connections between polyhedrons represent active business between the accounts.

The event type of the first can be a data structure with characteristic name and account id. The media type can be JSON space accountTeamJ objId account41101913441 accountIrregularityScore 0.3423

The media type is designed like this so that the graphics rendering client can easily map to the space id and to the object. The nozzle handles the space lookup which the originating event stream has no knowledge of.

The other geometries and media types work similarly. The client follows links in the RESTful hypermedia as the engine of application state HATEAOS style and follows links to the representation of each stream effectively rotating between them. For another example the media type for the predictive orthogonal plane could be lifespanDays 59 curAssetVal 6493482 space accountTeamJ projected PropensityFraudValue 0.253

Referring to a DataWorld client can utilize a scheme as illustrated in the unified modeling language UML diagram. DWUniverse is a top level client object that allows for aggregation of separately defined DataWorlds. Each DataWorld is a resource which is fetched via a ResourceRequestor. A RequestDispatcher handles the polling of the resources as well as the ordering and timing of requests. The DataWorld is one of several realizations of DWObject. Other realizations of DWObject are Space VizPrimitive Plane and Polyhedron. Space represents a coordinate system relative to a parent. VizPrimitive is an arbitrary 3D object that may have been created using a 3D modeling tool. Plane is an object that may be data driven in which case it is a DataPlane or which could be a Billboard that renders static content including text.

DWObjects are all realizations of a Projectable interface. These projectable realizations have one or more Axes a Scale and a DataProjector that maps from business values to geometric values.

A ConnectorTemplate defines connections between objects. A Vantage defines a position in space as well as a direction and field of view of the camera.

UIHandlers are attached to each DWObject and know how to translate a UI event to an actionable event that modifies one or more objects in the view in some manner. The modified objects need not include the target object. A UI Controller dispatches events to UIHandlers.

Some aspects of the described embodiments may utilize the Internet of Things IoT where things e.g. machines devices phones sensors can be connected to networks and the data from these things can be collected and processed within the things and or external to the things. For example with the IoT there can be sensors in many different devices and high value analytics can be applied to identify hidden relationships and drive increased efficiencies. This can apply to both Big Data analytics and realtime streaming analytics.

In an augmented reality AR DataWorld the view could be across a factory floor with various real time metrics floating above equipment indicated on the factory floor in 3D space. Alternatively the view could be across a retail space that shows consumer traffic patterns and inventory turnover. The physical space being viewed may use IoT via sensors and computer vision. Streams of data from the IoT are analyzed condensed and fed back for example to AR glasses to augment reality analytically.

In an augmented virtual reality DataWorld reality has not just the physical reality in front of a spectator. There are many realities and the physical world can be a hindrance in discovering the most important meanings. Instead of the physical layout of the factory floor defining the view it may be more informative to see the layout of flows and signals between the equipment. For such cases augmented virtual reality may better suit user needs especially when the connected equipment is spread across the globe or the interesting objects exist only in an n dimensional cyberspace. The DataWorld is virtual reality augmented with analytics. Take the factory equipment represent the objects and their connections in virtual reality in any arrangement desired and augment it with data visualizations. The real time data visualizations follow any rearrangement.

Some systems may use Hadoop an open source framework for storing and analyzing big data in a distributed computing environment. Some systems may use cloud computing which can enable ubiquitous convenient on demand network access to a shared pool of configurable computing resources e.g. networks servers storage applications and services that can be rapidly provisioned and released with minimal management effort or service provider interaction. Some grid systems may be implemented as a multi node Hadoop cluster as understood by a person of skill in the art. Apache Hadoop for example is an open source software framework for distributed computing. Some systems may use the SAS LASR Analytic Server in order to deliver statistical modeling and machine learning capabilities in a highly interactive programming environment which may enable multiple users to concurrently manage data transform variables perform exploratory analysis build and compare models and score with virtually no regards on the size of the data stored in Hadoop . Some systems may use SAS In Memory Statistics for Hadoop to read big data once and analyze it several times by persisting it in memory for the entire session. Some systems may be of other types designs and configurations.

The word illustrative is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as illustrative is not necessarily to be construed as preferred or advantageous over other aspects or designs. Further for the purposes of this disclosure and unless otherwise specified a or an means one or more . Still further using and or or in the detailed description is intended to include and or unless specifically indicated otherwise. serving data resources from a publishing system to a client system

The foregoing description of illustrative embodiments of the disclosed subject matter has been presented for purposes of illustration and of description. It is not intended to be exhaustive or to limit the disclosed subject matter to the precise form disclosed and modifications and variations are possible in light of the above teachings or may be acquired from practice of the disclosed subject matter. The embodiments were chosen and described in order to explain the principles of the disclosed subject matter and as practical applications of the disclosed subject matter to enable one skilled in the art to utilize the disclosed subject matter in various embodiments and with various modifications as suited to the particular use contemplated.

