---

title: Telecommunication and multimedia management method and apparatus
abstract: A telecommunication and multimedia management apparatus and method that supports voice and other media communications and that enables users to: (i) participate in multiple conversation modes, including live phone calls, conference calls, instant voice messaging or tactical communications; (ii) review the messages of conversations in either a live mode or a time-shifted mode and to seamlessly transition back and forth between the two modes; (iii) participate in multiple conversations either concurrently or simultaneously; (iv) archive the messages of conversations for later review or processing; and (v) persistently store media either created or received on the communication devices of users. The latter feature enables users to generate or review media when either disconnected from the network or network conditions are poor and to optimize the delivery of media over the network based on network conditions and the intention of the users participating in conversations.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09621491&OS=09621491&RS=09621491
owner: Voxer IP LLC
number: 09621491
owner_city: San Francisco
owner_country: US
publication_date: 20160906
---
This application is a Continuation of U.S. application Ser. No. 15 238 962 filed on Aug. 17 2016 which is a continuation of U.S. application Ser. No. 14 799 528 filed Jul. 14 2015. U.S. application Ser. No. 14 799 528 is a continuation of U.S. application Ser. No. 14 198 043 filed on Mar. 5 2014 now U.S. Pat. No. 9 154 628 which is a continuation of U.S. application Ser. No. 13 555 034 now U.S. Pat. No. 8 705 714 filed Jul. 20 2012 which is a continuation of U.S. patent application Ser. No. 12 037 256 now U.S. Pat. No. 8 243 894 filed on Feb. 26 2008 which is a continuation of U.S. patent application Ser. No. 12 028 400 now U.S. Pat. No. 8 180 029 filed on Feb. 8 2008 which claims the benefit of U.S. Provisional Patent Application Nos. 60 937 552 filed Jun. 28 2007 and 60 999 619 filed on Oct. 19 2007. All of the foregoing applications are incorporated herein by reference in their entirety for all purposes.

This invention pertains to telecommunications and more particularly to a telecommunication and multimedia management method and apparatus that enables users to review the messages of conversations in either a live mode or a time shifted mode and to transition the conversation back and forth between the two modes participate in multiple conversations and to archive the messages of conversations for later review or processing.

The current state of voice communications suffers from inertia. In spite of automated switching high bandwidth networks and technologies such as satellites fiber optics Voice over IP VoIP wireless and cellular networks there has been little change in how people use telephones. One is still required to pick up the phone dial another party wait for a connection to be made and then engage in a full duplex synchronous conversation with the dialed party. If the recipient does not answer no connection is made and the conversation does not take place.

At best a one way asynchronous voice message may be left if the recipient has voice mail. The process of delivering the voice mail however is burdensome and time consuming. The caller is required to wait for the phone on the other end to stop ringing transition into the voice mail system listen to a voice message greeting and then leave the message. Current voice mail systems are also inconvenient for the recipient. The recipient has to dial a code to access their voice mail navigate through a series of prompts listen to any earlier received voice messages in the queue and then finally listen to the message of the sender.

Another drawback with typical voice mail systems is the inability to organize or permanently archive voice messages. With some voice mail systems a user may save a message but it is automatically deleted after a predetermined period of time and lost forever.

Yet another problem with current voice mail systems is that a connection must be made between the caller and the voice mail system before a message can be left. If no connection is made there is no way for the caller to leave a message.

Current telephone systems are based on relatively simplistic usage patterns real time live calls or disjointed voice mail messages which are typically deleted as they are heard. These forms of voice communications do not capture the real power that can be achieved with voice communication or take advantage of the advances of network speed and bandwidth that is now available. Also if the phone network is down or is inaccessible e.g. a cell phone user is in an area of no coverage or the phone lines are down due to bad weather no communication can take place.

In general telephone based communications have not kept pace with the advances in text based communications. Instant messaging emailing faxing chat groups and the ability to archive text messages are all commonplace with text based communications. Other than voice mail there are few existing tools available to manage and or archive voice messages. In comparison the tools currently available to manage telephone communications are primitive compared to text communications.

The corporate environment provides just one example of the weakness in current voice communication tools. There is currently no integrated way to manage voice communications across an organization as a corporate asset. Employees generally do not record or persistently store their phone conversations. Most business related voice communication assets are gone as quickly as the words are spoken with no way to manage or store the content of those conversations in any manageable form.

As an illustrative example consider a sales executive at a company. During the course of a busy day the executive may make a number of calls and close several sales with customers over the phone. Without the ability to organize store and later retrieve these conversations there is no way for the executive to resolve potential issues that may arise such as recalling the terms of one deal versus another or challenging a customer who disputes the terms of a previously agreed upon sale. If this executive had the ability to easily retrieve and review conversations these types of issues could be easily and favorably resolved.

Current tactical radio systems such as those used by the military fire police paramedics rescue teams and first responders also suffer from a number of deficiencies. Most tactical radio communication must occur through a live radio connection between the sender of a message and a recipient. If there is no radio connection between the two parties there can be no communication. Urgent messages cannot be sent if either the sender or the receiver does not have access to their radio or a radio circuit connection is not established. Tactical communications are therefore plagued with several basic problems. There is no way i to guarantee the delivery of messages ii for a recipient to go back and listen to a message that was not heard in real time iii to control the granularity of the participants in a conversation iv for the system to cope when there is a lack of signal integrity for a live conversation. If a message is not heard live it is missed. There are no tools for either the sender or a recipient to manage prioritize archive and later retrieve i.e. time shift the messages of a conversation that were previously sent.

Yet another drawback with tactical radio communication systems is that only one message can be sent at a time per channel. Consider an example of a large building fire where multiple teams of fire fighters police and paramedics are simultaneously rescuing victims trapped in the building fighting the fire providing medical aid to victims and controlling bystanders. If each of the teams is using the same channel communications may become crowded and chaotic. Transmissions get stepped on when more than one person is transmitting at the same time. Also there is no way to differentiate between high and low priority messages. A team inside the burning building fighting the fire or rescuing trapped victims should have a higher priority over other teams such as those controlling bystanders. If high priority messages are stepped on by lower priority messages it could not only hamper important communications but could endanger the lives of the fire fighters and victims in the building.

One possible solution to the lack of ability to prioritize messages is to use multiple channels where each team is assigned a different channel. This solution however creates its own set of problems. How does the fire chief determine which channel to listen too at any point in time How do multiple teams communicate with one another if they are all on different channels If one team calls for urgent help how are other teams to know if they are listening to other channels While multiple channels can alleviate some issues it can also cause confusion creating more problems than if a single channel is used.

The lack of management tools that effectively prioritize messages that allow multiple conversations to take place at the same time that enable the time shifting of messages to guarantee delivery or that support archiving and storing conversations for later retrieval and review all contribute to the problems associated with tactical radios. In first responder situations such as with the military police and fire effective communication tools can literally mean the difference between life and death or the success or failure of a mission. The above burning building example is useful in illustrating just some of the issues with current tactical radio communications. Similar problems exist with the military police first responders and others who use tactical communications.

With packet based networks commonly used protocols include Transmission Control Protocol TCP and User Datagram Protocol UDP . UDP offers the advantage of fast delivery of data but at the expense of completeness. Packets may be dropped in transit and not available when attempting to render the data as soon as possible at the destination. In spite of the shortcomings UDP is the standard for Voice over Internet Protocol VoIP transmissions due to its speed attributes. On the other hand TCP does guarantee the delivery of perfect i.e. an exact copy of the transmitted data data but at the expense of latency. All packets are delivered regardless of how long it takes. This delay makes TCP impractical for use with live phone calls. Currently there are no known protocols that offer the performance advantages of both TCP and UDP where good enough media can be transmitted for rendering as soon as possible with the eventual delivery of a perfect copy of the media. Also there is no protocol that determines how much information should be sent over the network based on the presence of recipients on the network and their intentions to render the data either live or in a time shifted mode. In addition other factors commonly considered such as network latency network degradation packet loss packet damage and general bandwidth conditions are used in determining how much data to transmit. Prior art systems however do not consider the presence and intentions of recipients. As a result the default assumption is that the data is rendered by the recipient in real time. When a recipient is not going to render data immediately these prior art systems unnecessarily use bandwidth when it is not needed degrading the overall performance of the network.

For the reasons recited above telephone voicemail and tactical voice communications systems are inadequate. An improved voice and media communication and management system and method and improvements in delivering voice and other media over packet based networks is therefore needed.

The above described problems are solved by a communication application method and apparatus that supports new modes of engaging in conversations and or managing multiple conversations using a variety of media types such as voice video text location sensor information and other data. Users can engage in conversations by sending messages to designated recipients. Depending on preferences and priorities the recipient s might participate in the conversation in real time or they might simply be notified that the message is ready for retrieval. In the latter case the recipient participates in the conversation in a time shifted mode by reviewing and replying to the recorded message at their convenience.

Users are empowered to conduct communications in either i a near synchronous or live conversation providing a user experience similar to a standard full duplex phone call or ii in a series of back and forth time delayed transmissions i.e. time shifted mode . Further users engaged in a conversation can seamlessly transition from the live mode to the time shifted mode and back again. This attribute also makes it possible for users to engage in multiple conversations at the same time by prioritizing and shifting between the two modes for each conversation. Two individuals using the system can therefore send recorded voice messages back and forth to each other and review the messages when convenient or the messages can be sent at a rate where they essentially merge into a live synchronous voice conversation. This new form of communication for the purposes of the present application is referred to as Voxing. 

When you Vox someone the conversation consists of a series of discrete recorded messages which are recorded in a number of locations which may include the encoding device of the sender e.g. a phone or computer servers on multiple transmission hops across the network and the receiver s rendering device. Unlike a standard phone call or voice mail the system provides the following features and advantages i the conversation can transition between live and time shifted or vice versa ii the discrete messages of the conversation are semantically threaded together and archived iii since the messages are recorded and are available for later retrieval attention can be temporarily diverted from the conversation and then the conversation can be later reviewed when convenient iv the conversation can be paused for seconds minutes hours or even days and can be picked up again where left off v one can rejoin a conversation in progress and rapidly review missed messages and catch up to the current message i.e. the live message vi no dedicated circuit is needed for the conversation to take place as required with conventional phone calls and vii lastly to initiate a conversation one can simply begin transmitting to an individual or a group. If the person or persons on the other end notice that they are receiving a message they have the option of reviewing and conducting a conversation in real time or reviewing at a later time of their choice.

The communication media management system also supports new modes of optimizing the transmission of data over a network. The system actively manages the delivery of payloads to a recipient engaged in a conversation in real time when network conditions are less than ideal. For example when network conditions are poor the system intentionally reduces the quality of the data for transmission to the point where it is good enough to be rendered upon receipt by the recipient allowing the real time participation of the conversation. The system also guarantees the eventual delivery of an exact copy of the messages over time. The system and method therefore provides the advantages of both speed and accuracy. The utilization of network bandwidth is optimized by making tradeoffs between timeliness and media quality using the presence and intentions of whether or not recipient s intend to review to the message immediately in real time as well as measures of network latency network degradation packet loss or damage and or current bandwidth conditions.

It should be noted that the messages of conversations may contain voice only or voice video and other data such as sensor information. When the messages are reviewed they are listened to or visually reviewed or a combination thereof depending on the type of media contained in the messages. Although as of the filing of the present application most conversations are voice only it is intended that the communication system and method described herein broadly includes conversations including multiple media types such as voice and video for example.

The invention will now be described in detail with reference to various embodiments thereof as illustrated in the accompanying drawings. In the following description specific details are set forth in order to provide a thorough understanding of the invention. It will be apparent however to one skilled in the art that the invention may be practiced without using some of the implementation details set forth herein. It should also be understood that well known operations have not been described in detail in order to not unnecessarily obscure the invention.

An improved voice and other media communication application method and apparatus is disclosed which provides one or more of the following features and functions 

In various embodiments some or all of the numerous features and functions listed above may be implemented. It should be understood however that different embodiments of the invention need not incorporate all of the above listed features and functions.

Prior to explaining the details of the invention it is useful to define some of the terms and acronyms used throughout the written description. This glossary of terms is organized into groups of System Components Media Media Management People and Conversation Management.

Client A Client is the user application in the communication system which includes a user interface persistent data storage and Voxing functionality. Users interact with the Client application and the Client application manages all communications messages and signals and payload Media transfers that are transmitted or received over a network. The Client supports encoding of media e.g. the capturing of voice video or other data content and the rendering of media and supports security encryption and authentication as well as the optimization of the transmission of data across the network. A Client may be used by one or multiple Users i.e. multi tenant .

Device A physical device that runs the Client application. A User may be actively logged into a single Device or multiple Devices at any given point of time. In various embodiments a Device may be a general purpose computer a portable computing device a programmable phone a programmable radio or any other programmable communication device.

Servers A computer node on the communication network. Servers are responsible for routing Messages sent back and forth between Users over the network and the persistent storage and archiving of Media payloads. Servers provide routing transcoding security encryption and authentication and the optimization of the transmission of data across the network.

Message An individual unit of communication from one User to another. Each Message consists of some sort of Media such as voice or video. Each Message is assigned certain attributes including i the User sending the message ii the Conversation it belongs to iii an optional or user created Importance Tag iv a time stamp and v the Media payload.

Conversation A thread of Messages identified persistently stored grouped and prioritized between two or more Users on their Devices. Users generally participate in a Conversation using their Devices by either Reviewing Messages in real time or in a time shifted mode or creating and sending Messages of a Conversation as desired. When new Messages are created they either define a new Conversation or they are added to an existing Conversation.

Head of a Conversation The most recent Message of a conversation that has been encoded by the most recent speaker. It is where a User is positioned in a Conversation when reviewing live or where one jumps to if the Jump To Live feature is used.

Multiple Conversation Management System or MCMS An application that runs as part of a Client application which enables a User to engage in multiple Conversations using a variety of Media types. With the MCMS application a User selects one Conversation among the multiple Conversations as current where only the Messages of current conversation are rendered. For the selected current Conversation the User may transition from a series of back and forth Messages in time shifted mode to near synchronous live mode similar to a standard telephone conversation and back again. The Messages of the non selected Conversations are in a paused state. Messages associated with the non selected Conversion will accumulate if others are still participating in those Conversations. The User may selectively transition the current Conversation among the multiple Conversations and Review the accumulated Messages of the selected current Conversation.

Multiple Conversation Management System Consecutive or MCMS C Similar to MCMS with the added feature of rendering and enabling Users to manage and participate in multiple Conversations consecutively through a hierarchical system of Priorities and time shifting which are automatically managed by the system. The MCMS C application allows the Messages of consecutive Conversations to be rendered in a prioritized order as opposed to MCMS where only the Messages of the currently selected Conversation are rendered. MCMS C is particularly applicable in situations where it is important that the Messages of the consecutive Conversations are rendered in the prioritized order and or the receipt of all Messages even those belonging to lower priority Conversations is more important than receiving the Messages in real time. Examples of situations where MCMS C may be suitable include but are not limited to hospitals taxi fleet management or tactical communications.

Multiple Conversation Management System Simultaneous or MCMS S Similar to MCMS with the added feature of enabling With MCMS S multiple Conversations are selected for simultaneous rendering as opposed to MCMS where the Messages of only the selected current Conversation are rendered. The MCMS S application is particularly applicable in situations where a User is listening to multiple Conversations at the same time such as a trader listening to multiple brokers on different exchanges and periodically sending trading requests to one or multiple of them simultaneously. MCMS S may also be suitable for tactical communications as well.

Priority The mechanism through which the system determines which Message to render next when a User is participating in MCMS C. Priority is automatically managed by the system. A User can set default Priorities or a predetermined set of system Priorities may be used. In the event of a conflict where more than one Message is ready to be rendered at the same time the system resolves the conflict at least partly based on Priority to determine what Message to render immediately and what Message to time shift.

Tags a set of attributes a User or the system may assign to a Conversation or a message such as a topic a company name a directive action items a indicator conversation summary or any other label by which one might want to search or organize the data.

Importance Tags A special Message attribute that enables a sender to specify when a Message is to be rendered regardless of other Priority settings. An urgent Importance tag will override other Priorities for example. This feature is critical for tactical systems though any system can be configured to use or disable this feature.

Packet Any unit of binary data capable of being routed through a computer network. Each packet consists of header meta data and payload media data . Includes standard packet protocols such as but not limited to Internet Protocol IP EvDO UMTS or any other packet based network either radio fiber optic or wired.

Header or Packet Header The portion of a packet that describes the packet the meta data concerning the payload its encoding type and destination.

Vox packet A proprietary packet that enables the system and method to further refine and optimize the delivery of Messages Media and other signaling information.

Time Shift Delay TSD The amount of time between the arrival of a Vox Packet and the rendering of the Packet on a Device. The TSD must exceed the Minimum Time Shift Delay. The TSD is typically determined by the User s behavior in choosing to review the Messages of a Conversation some time after receipt.

Minimum Time Shift Delay MTSD The time shift delay enforced by the Client to allow for jitter processing using jitter buffer techniques. This causes the system to delay rendering until an adequate number of the packets have arrived to create a usable media stream. The system will typically adaptively adjust the MTSD over time to compensate for variable conditions in the network.

Rendering Delivering a Media stream to a User in a form suitable for User consumption e.g. voice text graphic display video or a combination thereof .

Mixing The Rendering of one or more Media streams. For example the Media stream from two Participants of a Conversation may be Mixed when Rendered creating a User experience similar to a conversation where multiple people are speaking at the same time.

Encoding The process of translating Media either created by a User such as voice or video or otherwise originating on a Device such as GPS or other sensor data and converting the media into digital data to be processed by a Client.

Adaptive Jitter Buffer Jitter buffers or de jitter buffers are used to counter jitter i.e. either the arrival of out of sequence packets or the delayed arrival of packets introduced by packet switched networks so that the continuous rendering of audio or video signals transmitted over a network can be performed without disruption. The data is stored in a buffer before Rendering to allow a reasonably sized buffer of Media to arrive. The Media may be rendered before all the Packets are received trading off quality for currency. An Adaptive Jitter Buffer is capable of dynamically changing its size to optimize the delay quality tradeoff.

Persistent Infinite Message Buffer PIMB The PIMB is a storage management system for the storage of time based Media that performs both the de jittering of live data and the storage and retrieval of archive data. The PIMB further includes the additional attributes of potentially infinite and persistence storage of Media. The PIMB maintains exact or full copies of Vox Packets of a Message and Conversations at some or all Participant Devices and or Servers.

Packet Loss Compensation or Concealment PLC During Rendering of a Media stream the PLC component compensates for missing Packets interpolating the results to present the stream to a reviewer. Missing Packets may be rendered as silence or information from adjacent Packets may be used to present an interpolated sound or image. The particular method to be used will be dependent on the media Codecs in use and other generally known parameters.

Contact A record of either a User or non user of the system. Users typically engage in Conversations with members on their list of Contacts. A non user is a user that accesses or uses the system using a legacy phone radio or other non Client enabled device.

Group The association of multiple Contacts. Contacts may be selectively added or deleted from a Group. When a Conversation takes place among a Group all the members of the Group may or may not participate.

Channel Typically used for tactical communication systems. A Channel is similar to a Group in that it associates multiple Contacts with the Channel.

Participant A person who is identified as a member of a Conversation. Could be a User or a non User participant.

Time Shifting Time shifting is the ability to play any Message at any time after it has been received as determined by the User recipient. By Time Shifting a User may Review a Message i immediately on demand by Rendering immediately after the MTSD or ii time shifted in a mode of reviewing the Message upon the discretion of the User iii from the archive for searching reconstructions etc. of old Conversations iv after a delayed period of time to accommodate the Reviewing of other higher Priority Messages or Conversations that need to reviewed first v and or repeatedly if necessary for the Message to be reheard and understood. In other words Time Shifting is the ability of a user to render a Message at any time after the system imposed MTSD.

Reviewing Listening viewing reading or otherwise observing the Media content in Messages. Reviewing may take place in either a near synchronous real time live mode or the time shifted mode.

Intention Either i a User defined attribute capturing whether the User wants to Review the Messages of a Conversation either as soon as possible or Review the Messages in a time shifted mode ii implied by a User s behavior or a combination of i and ii .

Attention A user attribute capturing whether the User is Reviewing the Messages of a given Conversation at the moment.

Catch Up To Live CTL A rendering mode that allows a User who is not at the Head of a Conversation to Review previous Messages more quickly to Catch Up To Live i.e. the Head of the Conversation . The CTL feature may use any of a number of catch up techniques such as the faster replay of Messages the removal of gaps in the Media of the Messages removal of hesitation particles etc. When the User has caught up to live the system seamlessly flows into the live Conversation. This is a very useful feature with conference calls for example in situations where a User needs to temporarily shift their attention away from the Conversation but wishes to hear the entire Conversation upon their return.

Catch Up Mode A user configured or pre configured mode that determines how the CTL process will catch up i.e. replay faster remove silence and hesitation particles or a combination thereof .

Jump To Live JTL This feature allows a user to jump from their current position to the Head of a Conversation. A user will typically use the JTL feature when they do not want to Review all of the Messages between their current position in the Conversation and the Head. When the JTL feature is implemented the user skips over any intervening Messages and starts Rendering the live Messages at the head of the Conversation.

MCMS Participant Attributes A set of attributes either defined by a User interpreted by the system from the User s behaviors assigned by an administrator or a combination thereof which define the Intention Attention Priority and rendering preferences of a receiver for a given Conversation. The attributes include but are not limited to i the Intention of when a receiver would like to render to the Messages of the Conversation. Possible Intention values include now time shifted Catch Up To Live CTL paused and never ii Catch Up Mode which is a configuration setting which determines how the CTL process should catch the receiver up to live e.g. play faster skip silence gaps or hesitations or play at normal speed iii Time Shift Delay TSD which defines how far the receiver s current position in the conversation is from the Head of the Conversation and iv the Priority of the Message with regard to the receiver s other Conversations.

Referring to a block diagram of the telecommunication and media management system according to one embodiment of the invention is shown. The system includes a plurality of Clients through running on Devices through respectively. The Devices communicate with one another over a communication services network including one or more Servers . One or more networks through is provided to couple the plurality of Devices through to the communication services network . In various embodiments the networks may be the Public Switched Telephone Network PSTN a cellular network based on CDMA or GSM for example the Internet a tactical radio network or any other communication network or a combination thereof. The communication services network is a network layer on top of or otherwise in communication with the various networks through . In various embodiments the network layer is either heterogeneous or homogeneous. Clients through communicate with one another and with Servers over the networks through and network using individual message units referred to as Vox packets which are described in detail below.

Referring to a block diagram of a Client running on a Device is illustrated. As illustrated in the Client includes Multiple Conversation Management System MCMS application a rendering and encoding module and an MCMS applications database . As illustrated in the Client further includes a Store and Stream SAS module with a Persistent Infinite Message Buffer PIMB reader a PIMB writer PIMB database a data and network quality DNQS store and Media driver and encoder hardware . The MCMS application and the Store and Stream module communicate with one another through message handling modules and respectively. The Client further includes an authentication encryption security module and a communication protocol module .

The module provides authentication encryption and security services during the transmission and receipt of Vox packets to and from the Client . The communication protocol module encapsulates Vox packets into the native packets used by the underlying network connected to the Device running the Client when transmitting data and de encapsulating Vox packets from the native packets when receiving data. With the modules and multi party end to end authentication encryption and security is provided between Clients . Messages are authenticated encrypted and secured across the networks through and network from a first sending Device to second receiving Device .

The database stores and manages the persistent meta data for a number of entities in the system including Contacts and Participants Conversations and Messages live and stored and default Priorities and information regarding the Servers . In addition the MCMS database stores the moment to moment operational data of a User s Conversations presence and status as well as that of all the Participants conversing with the User or on the User s Contact list. For example with regard to Conversations and Messages the database keeps track of status information such as what Messages of a Conversation a User has or has not Reviewed Priorities and Catch Up To Live status for each Conversation in which the Client is a Participant the presence and status of all Participants and other network and other system management data.

MCMS application supports the different Voxing modes of engaging in conversations and or managing multiple conversations using a variety of media and data types voice video text location data etc. . Users engage in Conversations by sending Messages to designated recipients using their Client enabled Devices . Depending on preferences and Priorities the recipient might Review the Message in real time or they might simply be notified that the Message is ready for Reviewing. Users can transition from a series of back and forth Messages which are Reviewed in a time shifted or voice messaging mode or in a near synchronous full duplex conversation similar to standard live phone calls and then back to voice messaging again. The MCMS application allows a User to control their interactions with their most important Conversations in real time without missing any Messages in other ongoing Conversations. For example the MCMS application notifies a User of urgent or high priority communications from a Conversation that they are not currently Reviewing. MCMS application also enables all Messages from all Conversations to be stored for later retrieval so they can be reviewed at any time.

In accordance with various embodiments there are several different operational modes of the MCMS application including MCMS Consecutive MCMS C and MCMS Simultaneous MCMS S which support the consecutive and simultaneous rendering of Messages respectively. Each of these embodiments is described in more detail below. Unless specifically specified the term MCMS is intended to generally mean the MCMS application which includes the aforementioned different modes.

The MCMS application is a multi tiered architecture that includes a number of modules and services. The modules and services include the MCMS Database Module the SAS Services Module the Messaging and Signaling Services Module the User Interface Application Programming Interface API the User Interface Module the Conversations Messages Management Services the Priorities Services the Contacts Service the Presence Status Services and the Messages Signals Services

The MCMS database module is a service module that manages all function calls necessary for the MCMS application to access the MCMS database .

The SAS Services module includes a set of function calls that enable communication and coordination between the MCMS application and the Store and Stream module and which are passed back and forth through the message handling modules and respectively. The set of function calls enable both the MCMS application and the Store and Stream module to operate as necessary to implement the various Voxing functions when invoked by Users and or as dictated by network conditions. Some of the functionality performed by the SAS Services module includes maintaining and communicating the status of Message transmissions and Message acknowledgments the instructions for rendering of Messages and the status and presence of Users.

The Messaging and Signaling Services module runs on both Clients and Servers and enables communication between the Client and the Servers of the system . This communication which includes messages data and other signals allows the Client and the system to track and administer communications network status Users and User status. Types of messages and signals sent between the Message and Signaling Services modules running on the Clients and the Servers include for example network availability of Users tracking of Messages that the Server has sent to the Client possibly including a high water mark to determine if an entire message or some portion of a message is missing e.g. a sequence number per Participant per Conversation created by the generating Client whether a user is speaking or Reviewing Messages of a given Conversation where a User is with respect to the Head of a Conversation or when a Participant is no longer Reviewing a Conversation live. These are examples a few of the many types of messages and signals sent between the Message and Signaling Services modules on the Clients and Servers and in no way should be construed as limiting the invention.

The User Interface API is a module that defines a set of function calls that define the programming interface between the User Interface module and the underlying services of the MCMS application . The User Interface API supports general purpose methods such as UI application support and all function calls necessary for a User Interface to operate the MCMS Application . In various embodiments the User Interface API enables the Client to support a wide variety of user interfaces and device types such as Adobe Flash based and or Microsoft Windows applications cellular or mobile phone devices PSTN devices driven with tones a voice user interface VUI and physical radio communication interfaces. In various embodiments the User Interface API module enables the design of both highly flexible and highly constrained user interfaces to support the functionality of the MCMS application .

The MCMS User Interface module supports the operation and functions of the audio and video user interface of the Client . The User Interface module supports a host of user interactions and can be implemented with various interaction mediums such as an array of graphical user interface screens an Audio DTMF interface or voice user interface on the Device all of which enable a User to interface with the system . A partial list of User interactions that are supported include for example functions to log in manage join and monitor Conversations control Conversation rendering manage Priorities and requests to review archived Conversations. It should be noted that this list is exemplary and in no way should be construed as limiting the invention.

The Conversation Message management services is a module which defines a set of functions that manage the data structures and processes responsible for managing and retaining all information needed for the User to manage the receipt and Review of transmitted and received Media e.g. voice or video content Messages between the participants of a Conversation. The Messages are organized into Conversations. Media that is sent or received by the Device running the application is available for immediate Review while being received. The received Media is also recorded for Review in a time shifted mode Conversation management and archival purposes. In an alternative embodiment Messages or Conversations can be optionally marked for transience specifying their desired retention requirements e.g. some Messages will not be retained or stored beyond the requirements for immediate rendering . In yet another embodiment Media can be optionally marked for review in a time shifted mode only and cannot be reviewed immediately upon receipt.

The Conversation Message management services further enables for each current or ongoing Conversation of the User the sending of Media to a receiving Client at any time and the receiving Client seamlessly associates these Messages with the appropriate Conversation regardless of the actions or inaction of the receiver.

With the Conversation Message management services all Conversations are essentially asynchronous. If two Users are actively engaged in a given Conversation and the User controlled delay between transmissions is minimal the experience will be one of a synchronous full duplex conversation as with current telephone or VoIP conversations. If either User delays their participation for whatever reason the Conversation drifts towards an asynchronous voice or other Media messaging experience. In alternative embodiments Conversations can be optionally Tagged as asynchronous Messages only or synchronous Messages only. In either of these cases the Conversation cannot drift between the two modes unless the Tag is reset. After the Tag is reset the Conversation again may flow between near synchronous i.e. live or real time and asynchronous i.e. time shifted or voice messaging modes.

The Conversation Message management service processes the transmission and receipt of Messages in a progressive fashion. When transmitting Media may be created while Messages are simultaneously encoded stored and transmitted. In other words the transmission of Messages may occur simultaneously with the generation of Media by the User i.e. while speaking into their Device or generating video . On the receiving side the receipt storage and Rendering of Messages also all occur progressively. Messages do not need to be completely received before they can be Rendered. The Rendering of Messages may occur at the same time Messages are being delivered right up to the MTSD. Further the service is also capable of the simultaneous transmission of outgoing Messages and Rendering of incoming Messages. The progressive nature of the service allows a User to be engaged in a live Conversation while storing and streaming the media of the Conversation for later retrieval and review as well other functions described herein.

The time shifting of Messages by the Conversation Message management services allows a User to Catch Up To Live on a Conversation if they missed earlier Messages or were involved in another Conversation. This time shifting process eliminates the need for Users to broadcast a request to their entire Group or Channel to have Messages repeated. Older Messages may be replayed at any time at potentially higher speeds to save time. Users may easily skip forward and backward through their Messages and within individual Messages. The Reviewing process may be configured on a Message Priority basis to potentially skip lower priority Messages.

In one embodiment the Conversation Message management service also identifies Messages by a specific Participant speaker and by default mixes Messages of a Conversation that were delivered at the same time MCMS S . In an optional embodiment a User could Review the transmissions of different Participant speakers of a Conversation separately.

The Conversation Message management module further allows Conversation sharing among Participants who can be added to an active or archived Conversation. In one embodiment an added Participant to a Conversation is provided access to the Conversation and has the ability to retrieve the previous Messages of the Conversation for Review. In an alternative embodiment the added Participant is provided access to the Messages of the Conversation only from the point where the new Participant joined and not any previous Messages of the Conversation.

The Conversation Message management module is also responsible for managing the functions used to control all rendering tasks performed by the Store and Stream module . These tasks include rendering Media i.e. voice video etc. appropriately for the Device running application . These rendering tasks include but are not limited to the rendering of Mixed Messages i.e. overlapping messages as well as rendering according to user defined criteria such as playing faster catching up to live removing silence removing hesitation particles frequency shifting and the ability to apply independent gain control to individual senders in a multi party conversation.

The Priority service is a module that defines a set of functions that manage the data structures and processes responsible for managing and retaining all information needed for a User to manage the Priority of the consecutive Conversations i.e. MCMS C in which the User is engaged. When a User participates in a number of consecutive live Conversations the User is required to prioritize the Conversations. Issues arise when Messages of different Conversations are ready to be rendered at the same time. An algorithm is used to determine the order in which the Messages are rendered that considers the availability of Messages to be rendered and the Priorities set by the User. The algorithm determines that the available Messages with the highest priority are rendered first while any concurrently available Messages are time shifted automatically just enough to allow for the rendering of the higher priority Message. As rendering time becomes available the system will automatically render the time shifted messages according to the User s Priorities.

The Contacts services is a module that defines a set of functions that manage the data structures and processes responsible for managing and retaining all information needed for authenticating and associating one or more Contacts with Conversations. When sending a Message as part of a Conversation that is associated with a number of Contacts all of the Contacts receive the Message.

The Presence Status services is a module that defines a set of functions that maintain the data structures and processes responsible for managing and sharing presence and status information between certain Users and or non users of the system. In various embodiments the presence and status information is maintained for all User and non users engaged in the Conversations the User of the Client is engaged in all Users and non users in the Contacts list or Users within a predefined domain e.g. the members of a corporation or other organization . These examples are merely illustrative and should not be construed as limiting. The Presence Status services module may manage and share presence and status information on any defined set of Users and or non users.

The Presence Status service enables Users to monitor the status of other User s Intentions Attention and their Time Shift delay on any given Conversation i.e. how far back they are from Reviewing the Messages of the Conversation live . In one embodiment privacy controls are provided concerning availability of Presence and Status data. The Presence Status module further controls the data that enables the system to deliver Messages that match the behavior and Intentions of Users. For example a User may indicate their Status by designating an Intention to either Review or not Review a Conversation live. In response the Presence Status services issues commands that cause the rendering of Messages either live or time shifted in accordance with the Intention of the User. In addition the Intentions of Users are shared with the other Participants of the Conversation. The service is also capable of inferring other Status values from the User s behaviors. The Presence and Status information is also used to optimize network traffic and bandwidth as described in more detail below.

The Messages Signals services is a module that defines a set of functions that manage the data structures and processes responsible for messaging and signaling Users of the system using special messages or audible tones. The special messages or tones may include for example an indication if a Message or Messages are live or time shifted whom the Message s are from Priority and other factors. The Message Signal service further has the ability to i signal the presence or absence of Users on the network as well as the ability to notify if one or more Users are no longer actively Reviewing the Messages of a Conversation ii ring or otherwise notify another User to get their attention when they are paying attention to another Conversation or not paying attention to their Device at all iii leave a Message for Users currently not on the network to immediately review the Message the next time the individual re connects to the network iv generate an audible or visible feedback that alerts the sender that a sent Message was not received by recipient s generate a confirmation when the Message has been received by the recipient s and or a confirmation indicating when the Message has been Listened to by the recipient s and v implement a Priority scheme where individuals on a Conference or tactical call may be notified that their attention is immediately needed on the call. This indication may convey multiple levels of urgency and an acknowledgement of some kind by the recipient.

The rendering and encoding module is responsible for performing all rendering tasks for the MCMS application . These tasks include rendering Media appropriately for the device running application .

The Store and Stream module supports a number of functions and performance attributes which are described below.

With the Store and Stream module Message transmission is essentially full duplex enabling any party to send a Message at any time even while another party is also sending a Message or if the other party is unavailable or otherwise engaged. The Store and Stream module is able to render messages as in a live PSTN or VoIP call or deliver them for time shifted messaging modes. It is able to optimize transmission and control Rendering according to the desires of the User.

The Store and Stream module maintains connectivity with all target recipients e.g. Servers or other Devices on the underlying network manages all message signal and media transmissions and optimizes the delivery speed and bandwidth usage across the network to meet a User s immediate performance requirements while managing network quality and capacity. The module adapts and optimizes Media delivery commensurate with the quality and capacity of the underlying network . When insufficient underlying network resources are available the quality of the transmitted Media streams can be degraded. As bandwidth becomes available the quality of the transmitted Media streams may be increased. In addition to tradeoffs of Media quality the Store and Stream functionality can make tradeoffs in the amount of Media transmitted in each packet based on Users intentions to render data in real time as described below.

By dynamically controlling the delivery rate of Media based on the conditions of the underlying network the Store and Stream module is optimized to deliver time sensitive Media that is good enough to Render upon receipt and the guarantee eventual delivery of exact or full copies of the Media for archival purposes through a background process of requesting retransmission of missing low quality or damaged packets. As long as sufficient network resources exist to meet minimum Media quality levels this retransmission does not impede the Rendering of live call Media. The Clients of the system are thus designed to bridge the performance gap between the delivery of an exact or complete copy of the Media at the expense of substantial potential latency versus the quick delivery of Media but with no guarantees of completeness. In the context of this application the term good enough means that the quality of the Media is sufficient so that when it is rendered it is intelligible. The notion of good enough is therefore subjective and should not be construed in absolute terms. For example the quality level of certain Media to be good enough may vary depending on the type of Media circumstances and other factors.

The Store and Stream module further persistently stores all Media created by or otherwise originating using a Device or received over the network from other Device and or users. There are several significant advantages of storing this Media on the Device running the Client i it enables Users to leave a Message for another party even when the sender and or the recipient has either unavailable or poor network connectivity. In the case of insufficient bandwidth the Message will be transmitted as fast as available bandwidth can be effectively used. In the case of no connectivity the Message is queued for transmission as soon as network connectivity becomes available resulting in a time shifted delivery ii the User has the ability to pause replay fast forward and Catch Up To Live with an ongoing Conversation as well as retrieve and review the archived Messages of previous Conversations and iii it enables the optimization of data payloads over the system and improves system resilience against network bandwidth and connectivity problems that may occur from time to time.

The Store and Stream module is also responsible for Mixing Messages as appropriate to create overlapping Messages generated by the normal overlap of speakers in a Conversation or background noise simulating an actual Conversation where multiple parties are speaking rendering transcriptions or translations of audio media adjusting the rendering of Media according to a number of User defined criteria including playing faster removing silence gaps between spoken words removing hesitation particles and frequency shifting and the ability to apply independent gain control to individual senders in a multi party Conversation as well as other potential Rendering options.

The Persistent Infinite Message Buffer or PIMB is a set of indexed i.e. time stamped and sequentially numbered Media payload data structures and a system for their storage and retrieval. In one embodiment the data in the PIMB is arbitrarily persistent meaning it is available virtually forever or at least until the system runs out of storage. Various retention rates and strategies may be employed to make effective use of storage resources. Many possible implementations exist for the physical storage implementation of the PIMB including but not limited to RAM Flash memory hard drives optical media or some combination thereof. The PIMB is also infinite in size meaning the amount of data that can be stored in the PIMB is not inherently limited. This lack of limit is in comparison to existing jitter buffer technology that discards data as soon as it is rendered. In one specific embodiment the PIMB may be implemented using a small and relatively fast RAM cache memory coupled with a hard drive for persistent storage. As the physical storage capacity of the PIMB is exceeded the data is maintained on the Server as described below for later retrieval on demand. User criteria or a replacement algorithm such as least recently used or first in last out is used to control the actual data stored in the PIMB and the data that is maintained on the Server or archived at any point in time. The PIMB further provides the attributes of file system storage and the random access attributes of a database. Any number of Conversations regardless of their duration or the number of Messages in each may be stored and later retrieved for Review. In addition the meta data associated with the Messages of a Conversation such as its originator and its length may be also stored in the PIMB . In alternative embodiments the indexed Media payloads and other data can be stored for a designated period of time e.g. 30 days . Once the age of the media exceeds the designated period the payloads and data are discarded. In another embodiment payloads can be discarded based on the sender and or the recipient of the Message containing the payload or the topic of the Conversation or Messages associated with the payload. In yet other embodiments payloads and data may be marked for transience meaning the Messages will not be stored in the PIMB beyond the requirements for immediate Rendering.

The data and network quality store DNQS is a data store for storing information regarding Media payloads and Vox packets that are either read from or written to the PIMB .

The PIMB writer writes data to the PIMB for two basic purposes. The PIMB writer writes data from a Media capturing device e.g. a microphone or camera on the Device running the Client Encode Receive . The PIMB writer also writes data received over the network from other Clients into the PIMB Net Receive .

For capturing Media from the Device the PIMB writer includes Encoder Receiver and a Data Storer . When a User speaks into the microphone or generates video images with the Device for example the hardware receives the raw audio and or video signals and provides them to the Encoder Receiver which encodes the signals into indexed media payloads hereafter sometimes simply referred to as payload or payloads . The Data Store stores the payloads into the PIMB . Other types of Media such as sensor data is converted into payloads in a similar manner.

For storing Media received over the network into the PIMB the Net Receive function of PIMB writer includes a Network Receiver a Data Bufferer a Data Storer a Data Quality Manager and a Network Quality Manager . The Network Receiver receives Vox packets over the network . The Data Bufferer places the received Vox packets into their proper sequence and prevents the Rendering of the incoming Vox packets for at least the Minimum Time Shift Delay MTSD delay. The Data Storer transforms the packets into indexed media payloads and stores the indexed media payloads in the PIMB . As the payloads are stored the Data Quality Manager DQM notes any missing or defective packets. If packets are missing or defective the DQM schedules a request for retransmission over the network . The sending device replies by resending the missing or defective packets. Eventually these packets are converted into indexed media payloads and stored in the PIMB . By retrieving the missing or defective packets an exact copy of a sender s Message is eventually stored in the PIMB . The retransmission of missing and or defective packets does not delay the rendering of Messages in real time provided that the packets that have been delivered are of good enough quality and quantity. Retransmission requests may be delayed by the DQM if insufficient network resources are available to support both the new live data as well as the retransmission.

The PIMB reader reads data from the PIMB for two basic purposes. The PIMB reader accesses the PIMB when data is to be rendered Render for the local Client . Data is also read from the PIMB when data is to be transmitted Transmit by the Client over the network .

For the rendering of messages on the Client the PIMB reader includes a Data Prioritizer a Data Retriever a Packet Loss Compensation Interpolator PLC Interpolator a Data Mixer and a Data Renderer . The Prioritizer prioritizes the data to be rendered by building an ordered queue of messages that could potentially be Rendered. It uses User configured Priority for the rendering of consecutive Conversations MCMS C . In addition the Data Prioritizer uses the availability of media data to render within the limits imposed by the MTSD the User s current Attention and the User s defined and implied Intentions. The Data Retriever retrieves the prioritized indexed media payloads from the PIMB . The PLC Interpolator performs packet loss compensation and interpolation on the retrieved payloads using known packet loss compensation and interpolation algorithms. The particular method to be used is dependent on the media Codecs in use and other well known parameters. The Mixer is used to appropriately mix concurrent data streams from multiple Messages of a single Conversation together. For example if two or more Participants of a Conversation are speaking at the same time the Mixer mixes the Messages creating the effect of both Participants speaking at the same time. In an alternative embodiment the User has the option of Reviewing the multiple streams from one Participant at a time. If only one Participant in the Conversation is speaking the Mixer may simply pass the single Message stream without performing any mixing. The Renderer takes the data from the Mixer module and converts it into a form suitable for the hardware driver . The hardware then drives either the speaker or video display of the Device depending on the type of Media creating voice video or some other audible and or visible notifier on the Device .

To prepare messages for transmission from the Client over a network the PIMB reader includes a Data Prioritizer a Packet Quality Manager PQM a Data Retriever Packetizer a Transmitter and an Acknowledger . The Data Prioritizer prioritizes the Messages for transmission over the network . Priority is determined using the MCMS Participant Attributes related to payloads available for transmission network connectivity and bandwidth conditions and the Intentions of Users beyond the next hop to either Render live or time shifted and in some embodiments possible optimizations of transmission bundling where multiple packets to any given next network hop are available. The prioritized packets are then optimized using the PQM which assures the timely delivery of good enough data quality for live Messages while minimizing real time bandwidth as described in more detail below. The Data Retriever retrieves the appropriate payloads from the PIMB . The Packetizer assembles the payloads into Vox Packets which are then transmitted by the Transmitter module over the network . When the recipient receives the Vox packets an acknowledgement is sent back to Acknowledger over the network for notifying the sending User that a Message has arrived at its destination.

The PQM has several optimization goals i the timely delivery of an adequate copy of time sensitive Media as soon as possible to be good enough for Rendering ii the efficient use of available bandwidth meaning using the optimal transmission frequency payload quality and packet size for the underlying network and iii the ability to dynamically adjust or make changes in the transmission frequency payload content payload quality packet size etc. as network conditions change.

On the receiving side of a network transmission is the Network Quality Manager NQM . The NQM is responsible for observing specific properties of network performance for each sender that has sent media to the Client comparing expectations of jitter loss and throughput to their actual values. This is used to compute a Network Quality Rating NQR for every sender. This NQR is used to indicate sender availability and Conversation live ness to the User of the receiving device.

The Data Quality Manager measures the quality of the data being received over the network by observing packet loss jitter and throughput. The DQM uses these measurements for three purposes i to send receipt reports back to the sender ii optionally using those receipt reports to request retransmission of certain data and iii making these measurements available to the NQM

Referring to a block diagram of the application that runs on the Server s . The application is similar to the Client application in many regards and includes an MCMS server application an MCMS database a store and stream module a PIMB a data and network quality store DNQS MCMS SAS message handling modules and which manage messages and signals back and forth between the MCMS server application and Store and Stream module an archive retriever and an archive . The application further includes an authentication encryption security module and a communication protocol module .

The MCMS server application is a multi tiered architecture including a MCMS Database Module a Store and Stream SAS Module a Messaging Signaling Module Conversations Messages management services Priority services Contacts including User and Authentication services Presence Status service and Messages Signals services . The aforementioned modules and services of the application are similar or the same as the modules and services having like reference numerals as the Client and therefore are not described in detail herein except for one notable exception. In various embodiments the MCMS server application and Store and Stream module including the MCMS database is configured to support many Users in one instance of the application. The one instance may be further configured to support multiple domains where each domain is defined as a group of Users i.e. a corporation or other group of Users belonging to a common organization . This architecture allows each application on Server to serve multiple users or domains where each user or domain is not visible to other Users. This partitioning is referred to as multi tenancy .

The server Store and Steam module performs the functions of Net Receive and Transmit. For the Net Receive function the module includes a Net Receiver Data Bufferer a Data Storer a Data Quality Manager DQM and a Network Quality Manager . For Transmit functions the module includes a Data Prioritizer Packet Optimizer Data Retriever Packetizer Transmitter and an Acknowledger . The aforementioned elements of the Store and Stream module are similar or the same elements having like reference numerals as the Client and therefore are not described in detail herein.

Since the Server does not directly interact with Users the encoding and rendering functions provided in the Store and Stream module of the Clients need not be present. The MCMS application when running on Servers does not interact directly with Users. Consequently the user interface and user interface API modules and services and are not needed.

The application on each Server potentially serves multiple tenants meaning it serves multiple Users of the system . The PIMB of the server application is therefore significantly larger and is used to store the media payloads of multiple Users as opposed to the PIMB which is used to store just the generated or received payloads of only a single User. The main purpose of the Store and Stream module is to receive Messages transmitted by the Clients and transmit Messages to other Clients . When a Client transmits a message the message contains an identifier associated with the target recipient. In response the Server finds a delivery route to a Client associated with the intended or targeted recipient. As Messages are received they are stored in the PIMB and transmitted to the next Server i.e. the net hop of the network layer along the path to the intended recipient s or to the recipient s directly depending on the system configuration. The archive retriever is responsible for archiving the media payloads stored in the PIMB in archive . As the physical space in the PIMB is exhausted media payloads in the PIMB are moved to the archive which is a mass storage device. In various embodiments the payloads stored in the PIMB may be archived in accordance with User defined criteria and or any known replacement algorithm such as first in first out FIFO or least recently used LRU . It should be noted that only a single Server is illustrated in for simplicity. It should be understood that in actual embodiments multiple servers or a server farm may be used for a network with a large number of Users.

The terms persistent and infinite used to describe the PIMB and the PIMB should not be construed literally as absolute terms. A User may wish to indefinitely store some Messages that are considered important. In other situations such as a casual chat between two friends the Messages may be deleted after a certain period of time to save space. According to various embodiments of the invention different retention policies may be used either set by the system or configured by the User. The use of the word infinite refers to the lack of any preset time boundaries enforced by the PIMB. This is contrasted with current jitter buffer systems which discard media after it has been rendered. The terms persistent and infinite should therefore be broadly construed to mean that the PIMB and PIMB have no internal limitations on the time ranges and quantities of Messages that can be stored therein.

There are a number of advantages to archiving the Messages of Conversations in a persistent storage medium. Voice messages and other Media can be organized indexed searched transcribed translated and Reviewed as needed. Voice as well as other Media therefore becomes an asset that can be managed both by Users and organizations. These Media assets have value to corporations first responders police and fire departments as well as the military.

As noted above the Vox protocol is used by the Store and Stream module to support all facets of payload transmission storage and optimization. The Vox packet is a structured message format designed for encapsulation inside a transport packet or transport packets of the underlying technology of the network . This arrangement significantly improves the flexibility of the system . By embedding the Vox packets into existing transport packets as opposed to defining a new transport layer for Voxing applications the system takes advantage of current packet based communication networks running over the existing telecommunications infrastructure. A new network infrastructure for handling the Vox packets therefore need not be created to take advantage of all the benefits of the system and method described herein.

Referring to the general format structure of a Vox packet is illustrated. The format of the Vox packet includes fields for type sub type length and payload. The different types of Vox packets include authentication signaling media payload media multiplex one message and media multiplex multiple messages . The sub type field is used to designate different types of authentication signaling or media type messages. Possible sub types for authentication Messages include those necessary for key exchanges and Authentication. Possible sub types for signaling Messages include registration routing message set up and network management. Possible sub types for Media messages include different Codec styles and different payload aggregation techniques. The length field defines the overall length or size of the payload. The payload field contains the actual payload or media of the packet .

Referring to a diagram illustrating a Vox packet encapsulated in an exemplary protocol used by the network is shown. In this example the Vox packet is embedded in underlying UDP IP and Ethernet transport packets respectively. In this manner the Vox packet can be transported across underlying UDP IP and Ethernet layers of the network . This is a standard protocol encapsulation technique used by packet networks.

Referring to a diagram illustrating a media multiplex Vox packet encapsulated in UDP IP and Ethernet is illustrated. In this example the Vox packet includes a Media type field a Media sub type field a length field a message ID field a time stamp field a sequence ID field and a Media payload field.

Referring to the format of an indexed media payload is illustrated. The indexed media payload includes a sub type field a length field a message identifier ID field a time stamp field a sequence identifier ID field and field for the Media payload.

The encapsulation of Vox packets into the transport packets of the underlying network allows the Media Messages and Conversations to each be defined by a number of attributes.

When Media is created or otherwise originated on a Device it is typically time based meaning it changes in some meaningful way over time. As a person engages in a Conversation for example their spoken words are strung together into sentences or statements which vary over time and the resulting data streams and packets will maintain the same variance over time. Similarly video as opposed to a still photo as well as GPS or other sensor data will vary over time. Regardless of the type or how it is originated the Media is segmented and placed into the payloads of a plurality of Vox packets . The packets are then continually stored transmitted received stored and rendered in streams i.e. streaming media at the transmitting and receiving Devices respectively. Since each packet is indexed time stamped and given a sequence identifier the individual packets can be segmented into Messages. By sequentially threading the individual Messages together Conversations may be constructed.

One further unique aspect of the system is that the media payloads generated by a Client are stored in multiple locations. Not only are the payloads stored in the PIMB of the generating Device but also in the PIMB of the Server s and the PIMB of the receiving Devices . This basic feature enables or makes possible much of the Voxing functionality described above and provides the system with both resilience and operability even when network conditions are poor or when a Participant of a Conversation is not connected to the network.

The system is intended to run or be layered over a variety of existing communication networks such as the Internet fixed PSTN type circuit networks and mobile or cellular phone networks or a combination thereof. The system is designed around the concept of moving many small units of information i.e. the Vox packets between different Clients and Servers in the system . While Vox packets may vary in size depending on their function and payload they all appear to be the same kind of data to the underlying network layer. In one embodiment the system has been designed and optimized for IPv4 networks such as the Internet but other types of networks may be supported as well. For the purposes of this document the term IP should be taken to mean IPv4 IPv6 or any other current or future implementation of the Internet Protocol.

Referring to a diagram of a Client running on Device and communicating with a Server over a shared IP network is shown. As illustrated the Client is coupled to the shared IP network through a first Internet service provider A and the Server is coupled to the shared IP network by a second Internet service provider B. During communication the Vox packets designed VP in the figure are encapsulated within UDP IP packets and then interleaved among other IP protocol packets as is well known in the art and transmitted across the shared IP network from the Client to Server or vice versa. As is well known each lower packet layer encapsulates the entire packet of the layer immediately above it. Packets can also be sent in a similar manner between two Servers . Messages are sent from one Client enabled Device to another over a shared IP network . At each hop the Vox packets are embedded in the underlying IP protocol and transmitted until they reach the target destination.

The diagram of is merely exemplary showing only a single Client and Server connected to the network for the sake of illustration. In actual embodiments of the system a large number of Clients and one or more Servers are typically connected to the shared IP network . It is also useful to note that the Client and Server do not have exclusive use of the IP network . In the example shown an HTTP client which is coupled to the network through Internet provider A can send packets back and forth with an HTTP server coupled to the network through a third Internet provider C. The system does not control the manner in which the VPs embedded in the IP packets traverse the network . Rather all packets that traverse and share the network do so in accordance with the standard procedures of the underlying shared IP network .

Referring to a circuit based network such as a GSM mobile phone network is illustrated. The circuit network is coupled between Client running on Device and Server . Once a circuit is established between the Client and Server the system layers Vox packets VP VP VP VP VP etc. onto the underlying packets used by the network and transmits them across the network creating virtual Vox circuit. The Vox Packets sequentially traverse the circuit network typically with spacing or framing data as is well known in the art for transmitting data over a circuit network. In addition packet construction parameters such as the payload size and the number of header fields included may be used to exploit the lack of per packet overhead and to increase speed and or efficiency of data transfer across the network . It should be noted again that for the sake of simplicity only a single Client and Server are shown connected to the network . It should be understood however that additional circuits between Clients and Servers as well as other components may be established concurrently through the network . The network is therefore not dedicated for the transmission of Vox Packets but rather may be shared with other types of network traffic.

Referring to a diagram illustrating communication between a first Client A enabled Device A associated with a first network A and a second Client B enabled Device B associated with a second network B is illustrated. The networks A and B further each include gateway Servers A and B respectively. The Gateway Server pair A and B facilitate communication between the two networks A and B allowing the Devices A and B to communicate with each other. In various embodiments the networks A and B could each be any type of network. For example each network A and or B could be an IP network a circuit type network or a wireless or cellular network i.e. CDMA GSM TDMA etc. . The Servers that straddle the two networks A and B are considered gateway servers because they route traffic or serve as a gate between the two networks.

With the system there are a several basic network interaction considerations to optimize system performance. These considerations include factors such as resolving the underlying address to which the Vox packets are to be sent the integrity of any sent Vox packets and the management of the Maximum Transmission Unit MTU of a single Message that may be sent across a given network or combination of networks.

The address of a target Client needs to be known so that the underlying network delivers the Vox packet to the correct location. With IPv4 networks the address is typically an IPv4 Address which is a 32 bit number that uniquely identifies a host within the network. For other networking technologies the address could be some other type of identifier. IP networks use the Domain Name System DNS to resolve human readable names into IP addresses and the Address Resolution Protocol ARP to resolve IP addresses into physical addresses. Regardless of the underlying networking technology the system uses one of the above mentioned or other known addressing schemes for delivery of Vox packets to the correct location.

As with almost any packet based communication system transmitted Vox packets might not be delivered to their addressed location if the underlying network is unable to deliver the packets in which the Vox packets are encapsulated. Most packet networks do not inform transmitters when packets are dropped. Instead they rely on the transmitters and receivers to notice and compensate for any dropped packets. The system is designed to use these receiver receipt report messages to coordinate this packet loss management. If the underlying network is able to inform the sender of lost or dropped packets the system utilizes this information in its retransmission protocol.

The management of MTU is the determination of the Maximum Transmission Unit i.e. the maximum size of a single message that may be sent across a network. For packet based networks the underlying network imposes the MTU. For circuit switched networks the MTU may be a tunable parameter for network efficiency and performance. Thus in most cases the underlying network imposes or determines the maximum size of the Vox packet that may be transmitted efficiently. For example with IP networks packets may be fragmented if the payload exceeds the MTU but at a substantial performance penalty. With IP over Ethernet networks the transmitting device has an MTU of 1518 bytes as enforced by Ethernet. The largest IP packet must leave room for the Ethernet headers. The largest UDP packet must leave room for both IP and Ethernet headers and the largest Vox protocol that may be generated on Ethernet for example is the Ethernet MTU 1518 IP header 20 UDP header 8 1490 bytes. Since the Vox protocol will have a header of its own the actual Vox media payload will be less than 1490 bytes on an Ethernet network. For Gigabit Ethernet the MTU could be much larger but would be determined using a similar formula.

In a purely packet based network there are two potential values for MTU the local link MTU and the path MTU. Determining the local link MTU yields the maximum size for Vox packets to be efficiently sent out to the local network interface. The path MTU yields the maximum size of Vox packet that may be sent intact all the way to the remote node. If a sender is connected via Ethernet the Vox packet might pass through various other systems with smaller MTUs en route to the recipient. The smallest MTU on the path to the destination needs to be resolved and known by the sender. In the IP world there is a standard procedure for discovering the smallest MTU called Path MTU Discovery . For other kinds of networks an equivalent procedure may be used. Again since the system is layered on top of other networks any of the above MTU algorithms may be used.

Referring to a series of flow diagrams are provided to illustrate the operation of the store and stream module and on Clients and Servers respectively. shows the sequence of operation for a first Client transmitting Messages to a second Client . illustrate the operation of the PIMB writer and PIMB Reader on the transmitting Client . illustrate the operation of the PIMB Writer and PIMB Reader on the receiving Client . illustrates a flow diagram of the Store and Steam module on a server .

In the User of Client running on a Device originates Media to be transmitted. The Media can be originated at the Device in a number of different ways such the User creating Media by speaking into a microphone or creating video content on their Device . Media is also originated by a Device by receiving sensor data such a GPS information or a temperature reading. Regardless of how the Media is originated the Media is encoded by the PIMB Writer box which converts the Media into indexed media payloads and stores them in the PIMB box on Client . The PIMB Reader on the Client reads the payloads out of the PIMB creates Vox packets and transmits the packets to the receiving Client box over the network . Each Server along the path between the sending Client and the receiving Client stores the transmitted payloads in the PIMB and transmits the Vox packets to the next hop box . At the receiving Client the net receive function of the PIMB Writer converts the Vox packets into indexed media payloads box and stores the payloads into the PIMB of Client box . The rendering module of the PIMB reader on Client renders the payload information read from the PIMB into a medium suitable for human consumption such as voice or video box . Each of these steps are described in more detail below with respect to .

In a sequence of the Encode Receive function performed by the PIMB Writer step of is provided in detail. In the initial step the User of the Device running the Client originates the Media to be transmitted. As noted above the Media may be derived by speaking into a microphone using a camera receiving sensor data or by some other Media generating component. In the next step the Encode Receiver encodes the Media and creates the indexed media payloads step which are then stored in the PIMB step by the Data storer

In the sequence of the Transmit function performed by the PIMB Reader step of on the sending client is provided in detail. In decision loop the transmit function of the PIMB Reader continuously checks to see if indexed media payloads that are to be transmitted have been written into the PIMB and are available for transmission. If such payloads are available in the PIMB the Data Prioritizer prioritizes the payloads that should be sent first using the MCMS Participant Attributes information as illustrated in step . Information about the highest priority payloads are passed to the Packet Optimizer module which runs the PQM step as described in more detail below with respect to . The appropriate payloads are then retrieved from the PIMB step by the Data Retriever and converted into Vox packets by the Packetizer step . The Vox packets are then transmitted step by the Transmitter over the network to the receive Client which sends back receipt reports reflecting the properties loss jitter throughput of the packets that have been received. These receipt reports provide the information necessary for the PQM to calculate the MABR for a given receiver. The aforementioned process is repeated for each transmission loop as indicated by the return arrow from the transmit step to the top of the flow chart.

In the embodiment described above the media is encoded stored in the PIMB and then transmitted over the network in a serial fashion. In an alternative embodiment the encoded media can be stored in the PIMB and transmitted over the network in parallel meaning the two functions occur substantially at the same time.

In the sequence for the Net Receive function step of of the PIMB Writer on the receiving Client is illustrated. In the initial step the network receiver receives the Vox packets over the network . The Data Storer converts the packets into indexed media payloads step which are stored in the PIMB step . As the payloads are stored the Data Quality Manager DQM is run. The DQM checks for missing or corrupted packets ensures the eventually storage of an exact copy of the transmitted data and the sends receipt reports regarding the conditions of the network to the transmitter. Each of these functions of the DQM are described in more detail below with regard to .

In the sequence for the Render function of the PIMB Reader box of on the receive Client is illustrated. In the initial step the Data Prioritizer prioritizes the indexed media payloads to be rendered as determined by the MCMS application using the MTSD information as well as User status and presence information including the User s Intentions and Attention status. The prioritized payloads are then read from the PIMB step by the Data Retriever . The PLC Interpolator performs packet loss compensation and interpolation step on the retrieved payloads using known packet loss compensation and interpolation algorithms depending on which Codecs are used. In the next step the Mixer mixes step multiple Messages of a Conversation if two or more Participants have generated Media at the same time within the same Conversation e.g. both are speaking at the same time . The Renderer renders step the data stream from the Mixer generating sound video or other Media step for the recipient User.

In the sequence for a Server to receive Vox packets from the previous hop on the network store archive and transmit the Vox packets to the next hop is illustrated. In the initial step the Server performs the Net Receive function of the PIMB writer similar to to store the indexed media payloads of the received data in the PIMB and archive or the Server . The server also performs the Transmit function of the PIMB writer similar to to forward the received packets onto the next hop on the network . In this manner a copy of the media generated by the transmit Client is received stored and transmitted at each hop along the path to the receive Client .

In the aforementioned embodiment the writing of received indexed media is stored in the PIMB of the Server and transmitted to the next hop in a serial fashion. In an alternative embodiment the received indexed media payloads can be stored in the PIMB and transmitted to the next hop substantially at the same time. The storage of Media on the PIMB of both transmitting and receiving Devices allows for the progressive transmission and rendering of Media. On the transmit side the Media originating on the transmitting device may be progressively transmitted over the network as it is being received. In various embodiments the encoded Media regardless of how it is originated may be progressively transmitted before after or at substantially the same time it is stored in the PIMB . On the receive side the incoming Media may also be progressively rendered as it is received over the network provided the User has opted to Review the Media in the near real time mode. In various embodiments the incoming Media may be progressively rendered before after or substantially at the same time as it is stored in the PIMB of the receiving Device . If the received Media is to be Reviewed in the time shifted mode then the Media is retrieved from the PIMB or possibly a PIMB on a Server if replaced on the local PIMB for later Review at a time designated by the User.

In the context of the present application the term progressive or progressively is intended to be broadly construed and generally mean the continuous processing of a data stream based on availability of the data. For example as Media is created or otherwise originated on a Device the progressive encoding storage packetization and transmitting of that media is continuous so long as the Media is available. As a person speaks that Media is progressive or continuously encoded stored packetized and transmitted for the duration of the persons speech. When the person pauses or stops speaking there is no media to progressively process. When the person resumes speaking again the progressive processing of the Media resumes. On the receive side the Media is also progressive processed as the Media is being received i.e. available . As the Media is received it is continuously stored. It will also be continually rendered as the Media is being received when in the near real time mode or from storage when in the time shifted mode. Although the above explanation was provided in the context of voice it should be understood that all types of Media can be progressively processed in a similar manner. Also the progressive processing of Media does not necessarily have to be progressively processed in time indexed order. Rather the Media is processed in the order in which it is received. If Media is received out of index order in one embodiment the Media is progressively processed in the order it was received and then organized into the indexed sequence in the PIMB . In an alternative embodiment the received Media can be organized into its indexed sequence and then progressively rendered.

The PQM relies on a metric called the Maximum Available Bit Rate MABR which is a continually computed approximation of actual transmission capacity or bandwidth i.e. a measure of the capability of the network at a given point in time between a sending and receiving node pair. As instantaneous network conditions change the MABR is updated. Regular measurements of network throughput packet loss and jitter are considered in computing the MABR. In an alternative embodiment the MABR may also be manually set or limited based on time of day type of network other conditions or parameters.

The PQM also considers the Intention of the recipient s to optimize transmission for time sensitivity. A transmission is considered time sensitive if either i the Intention of the recipient s is to Review the transmission live or in the near real time mode or ii the recipient would like to immediately Review a Message that for some reason is not currently stored on their Device e.g. the Message was previously stored in the archive . The Intention of the recipient can be either inferred by the behavior of the recipient or the recipient may set or otherwise designate their Intention. On the other hand a transmission is considered to be not time sensitive if the Intention of the recipient is to Review the Message in the time shifted mode. The Intention of the recipient to Review the transmission in either the live or time shifted mode at least partially defines the timeliness requirements of the transmission. In various other embodiments factors such as the urgency or priority of transmissions may also be considered in defining the timeliness requirement of the transmission.

The nodes in the network path between a sender and a receiving pair also need to be consistent regarding the status of intentions of the recipients. If one target recipient indicates timeliness meaning they wish to Review the transmission immediately or live then all the intermediate nodes on the network along the sender receiver path need to have the same timeliness requirement regardless of the requirements of other recipients. The timeliness requirement of each of the intermediate nodes is therefore dependent on the receiving nodes the transmission is being sent to. This dependency is sometimes referred to as a union of requirements for target nodes in the network transmission path.

The PQM further considers an Ideal Bit Rate or IBR for each scheduled Message payload transmission. For time sensitive transmissions the IBR is computed based on the packetization rate needed for substantially real time or live communication referred to herein as the Real Time Bit Rate or RTBR . With voice for example a packetization rate of a packet every 20 milliseconds containing 20 milliseconds of audio data is considered an acceptable IBR for conducting live conversations. The RTBR for such a system in kilobits per second would be the size of 1 second of audio payload data plus the size of all network headers that would be generated for the transmission. For video media or a combination of voice and video the RTBR will likely be substantially higher than simply voice. For other types of media such as sensor or GPS positioning data the RTBR will likely be lower than that of voice. For non time sensitive transmissions the IBR is set to a Maximum Efficiency Bit Rate MEBR to optimize the usage or efficiency of transmissions over the network. The MEBR is calculated by adjusting the packetization rate to its largest possible value for the underlying network. If multiple messages or payloads are to be sent between a sending and receiving pair then an Aggregate IBR AIBR is considered for the transmission.

The PQM operates by sending data in a series of transmission loops for each sending and receiving pair. The transmission loops for each sending and receiving pair are independent. Any transmission on the network may affect the MABR of other sending receiving pairs. Accordingly the MABR is preferably continually computed for all recipients.

Referring to flow charts illustrating the sequence of operation of the PQM for a single sending and receiving pair is illustrated. In the steps in determining the MABR between the single sending and receiving pair are illustrated. In a flow chart illustrating the steps for calculating the AIBR for each transmission loop for the single sending and receiving pair are illustrated. In a sequence for determining the amount of data to transmit between the sending and receiving pair per loop is illustrated. The processes illustrated in the three diagrams run simultaneously and interact with one another as described in more detail below.

In a flow chart for calculating the MABR for the network interface between the sending and receiving pair is shown. In the initial step the network interface between the sending and receiving pair is monitored. The sender periodically receives reports which contain information regarding the status of the network connection at the receiver in step . The reports include information regarding the current status of data throughput packet loss and jitter as observed by the receiver at the network interface. In step the MABR is calculated at the sender based on these observations contained in the reports. By monitoring or observing the data in these reports the MABR value is continually adjusted based on current network capabilities or conditions between the sending and receiving pair. As network capabilities become more favorable for data transmission the MABR will increase. If the network capabilities become less favorable for transmission the MABR will decrease potentially all the way to zero for an unusable network. The reports are similar to the packet loss reports generated by nodes in TCP networks but additionally include throughput and jitter information as well.

If there are several network interfaces between the sending and receiving pair an MABR is calculated for each interface for which a receipt report is received. If no traffic has been recently sent on the network or no receipt reports have been received the MABR may not reflect current network conditions. However since receipt reports are generated continually by receivers while data is transmitted the sender s MABR metrics will quickly converge to a more accurate value.

Referring to a flow chart illustrating the steps for calculating the AIBR for a transmission loop is illustrated. In the initial step the Messages with Media by which we mean portions of the time indexed media that belongs to this Message ready to be transmitted between the sending and receiving pair in the current loop are ascertained. A list of Messages with Media is then built . For each Message in the list the time sensitivity or timeliness requirement of each Message is considered . If a particular Message is not time sensitive then the IBR is set to the Maximum Efficiency Bit Rate MEBR . On the other hand if a Message is time sensitive then the IBR is set to the Real Time Bit Rate RTBR . In the next step the previously computed IBRs for each of the Messages in the list are summed together resulting in the Aggregate Ideal Bit Rate AIBR for the transmission loop. As signified by the return arrow the above described process is repeated for each transmission loop between the sending and receiving pair.

Referring to a flow chart illustrating the sequence for determining the rate of data to transmit between the sending and receiving pair per transmission loop is illustrated. In the initial step the MABR as calculated in is compared to the AIBR as determined in for the next transmission.

If the MABR is greater than or equal to the AIBR then all the Messages identified as ready for transmission in the loop are packetized at the IBR rate and transmitted .

On the other hand if the MABR is less than the AIBR then a series of procedures are applied to so that the PQM meets its goals of the timely delivery of an adequate copy of the data the efficient use of available bandwidth and or adjustments to the payload content and quality packet size and transmission rate to meet current network conditions.

In the initial step the Messages in the list are reviewed for time sensitivity . If there are no time sensitive Messages then the bit rate is reduced to the MABR and the Messages are transmitted .

If the list includes time sensitive Messages the bit rate allocated for the non time sensitive Messages is reduced until it meets the MABR limits. If reducing the bit rate all the way to zero is insufficient to meet the MABR then these non time sensitive Messages are removed from the list of Messages to be transmitted in the loop. If the bit rate has been reduced so that it is less than or equal to the MABR then the remaining Messages are Packetized and transmitted .

If the removal of non time sensitive Messages was not sufficient to meet MABR then another procedure involving the use of a lower quality Codec or Codecs for the remaining time sensitive Messages is used. An attempt is made to transmit the payload data as fast as possible by sending fewer bits during the transmission loop. In other words by reducing the quality of the payload the transmission sends fewer bits in a given period of time. In various embodiments different Codec or Codecs each having a different bit rate versus quality tradeoff may be used. If the use of the lower quality Codec or Codecs is sufficient meaning the MABR limit is met then the Messages are transmitted .

If the use of lower quality Codec s still does not meet the MABR then the packetization interval of the time sensitive Messages is increased . With this procedure the header to payload ratio is increased which lowers the overall bit rate but introduces latency i.e. a delay in the delivery of the transmission to the recipient . If this procedure results in the reduction of the AIBR to less than or equal to the MABR then the transmission occurs.

If after changing the packetization interval the MABR is still not met then the bit rate may be progressively lowered to be within the MABR limit. When the bit rate is lowered in this manner time sensitive messages are sent at a rate that is not sufficient to maintain a live conversation. Therefore the Conversation is forced out of live . If the network is down or conditions are very poor it is possible that no data transmission may occur. Again the aforementioned sequence is repeated for each transmission loop between the sending and receiving pair.

If there are multiple network interfaces between the sending and receiving pair the sequence described in relation to is performed for each interface for which receipt reports are available. In various embodiments the sender may contain logic to distribute the transmission load among the multiple interfaces. In different examples the payloads can be sent only on one interface while in other embodiments some or all of the interfaces may be used.

The aforementioned description pertains to any sending and receiving pair in the system . In most situations the sending and receiving pair will include a Client enabled Device and Server two Servers a Server and Client enabled Device or even possibly two Clients respectively. If a sending node is transmitting to two or more receiving nodes at the same time the above mentioned sequence as described in relation to occurs concurrently for each receiving sending pair.

The DQM determines if data received at the Client is either corrupted or if there are missing packets. In addition the DQM of a receiving Client generates of the receipt reports which are sent back to the transmitting node on the network. The DQM also runs a background process to ensure that an exact copy of transmitted data is eventually received and stored. These functions are described below in respectively.

Referring to a flow diagram illustrating the operation of the DQM for checking for missing and or corrupted data is illustrated. In the initial step the DQM checks for corrupted packets using well known techniques such as CRC or similar integrity checking mechanisms. If a packet is corrupted that packet is treated as missing . The DQM next ascertains if any packets are missing . If an out of sequence packet is not received after a predetermined period of time it is assumed to be missing. The DQM notes any missing or corrupted packets in the DNQS . On the other hand if no corrupted or missing packets are detected the DQM determines if the quality of the received data was intentionally degraded by the sender for the purpose of saving bandwidth. The degraded quality is noted in the DNQS . Regardless if the quality of the received data is degraded or not receipt information e.g. a packet sequence number time stamp and the network address of the next node in the network the packet is to be sent of the data is stored in the DNQS . The aforementioned process is continually repeated as signified by the return arrow to the start of the flow diagram.

As a result of the process detailed in information regarding the receipt of non degraded packets the deficiency of degraded quality packets and missing packets are all stored in the DNQS . As Media is received the DNQS maintains up to date information regarding the status of the Media.

Referring to a flow diagram illustrating the operation of the receipt report generator function of the DQM is illustrated. In the initial step the DNQS is periodically scanned to determine if there is any Media for which a receipt report needs to be generated . If the answer is no then the above scanning process is repeated. On the other hand if Media is identified then the process determines if the Media is time sensitive meaning either the User intends to Review the Media live or the user would like to immediately Review Media that is not stored on their Device .

If not time sensitive then the recipient informs the sender to set the retransmission priority as defined below to low . If time sensitive then the amount of packet loss is considered . If the amount of packet loss is outside a usable quality range the retransmission priority is set to high . As noted above if the amount of packet loss is too large the recipient may not be enabled to Review the Media upon receipt. If the quality is within an acceptable range meaning the quality of the transmission is sufficient that it can be understood when rendered then the priority for the sending of the receipt report is set to low . Regardless if the recipient is Reviewing upon receipt or not a receipt report is sent the DNQS is updated and the Network Quality Manager NQM is updated . The retransmission requests defined in step is therefore conditional based on time sensitivity. The transmission request defined in step is conditional on both time sensitivity and quality.

The retransmission priority informs the PQM of the sender to properly prioritize the transmission rate for the Media that requires retransmission. For example when the retransmission priority is set to high then the sending PQM of the sender should send any retransmissions before any new Media. If the priority is low the PQM should send the retransmitted Media after any new Media.

The aforementioned process is continuously repeated so that receipt reports are generated as Media is received. If the sender does not receive receipt reports in a timely manner the PQM of the sender will reduce the transmission rate eventually stopping the transmission if no receipt reports are received.

Referring to a flow diagram illustrating the sequence for requesting of missing or degraded Media is illustrated. In the initial step the DNQS is periodically scanned for missing or degraded Media . If there is no missing or degraded Media then the above defined scan is periodically repeated.

Media is considered missing if an out of sequence packet does not arrive after a predetermined threshold period of time . If the packet arrives before the threshold then it is no longer considered missing. On the other hand if the packet does not arrive after the threshold is exceed then it is deemed missing. With missing packets a low priority request for retransmission is made and the time of the request is noted in the DNQS . This process is repeated until the missing packet is received. When the missing packet arrives and the corresponding Media is available in the PIMB the missing status of the Media is removed from the DNQS . The retransmission request defined in step is therefore conditional based on whether the Media is determined to be missing.

If degraded the DQM determines if the Media is part of a live Conversation . If not a request for a full quality copy of the degraded Media is made the full quality Media is designated as missing and the request time is noted in the DNQS . If the Media is part of a live Conversation then no action is immediately taken in order to preserve network bandwidth. When the Conversation transitions out of the live mode then the steps through are performed to ensure that a full quality i.e. an exact or perfect copy of the degraded Media is eventually received. When the data becomes available in the PIMB of the recipient Client the degraded status of the associated Media is removed from the DQNS . The transmission request defined in step is conditional on whether the Media is both degraded and not part of a live conversation.

The aforementioned process is continually repeated as signified by the return arrows from and to the top of the flow diagram at . By repeating the process outlined in exact copies of all transmitted Media is eventually stored in the PIMB of the receiving Device . In this manner the storage of exact copies of transmitted Media is guaranteed at the recipient Device .

Referring to an exemplary Device running Client application is illustrated. The Device includes a graphical user interface display data entry buttons keys or keyboard a microphone and a transducer for converting electrical signals into sound such as a speaker. The display may also accept input as a touch screen. Further the display and keyboard may be combined using a touch screen interface. As noted above the Device may be a variety of different communication tools such as a desktop computer laptop or other mobile computers personal digital assistants a programmable land line or cellular phone or programmable radios or just about any other type of programmable communication device. The exemplary Device illustrated in the figure is intended to be generic in the sense that it is supposed to represent or encompass all of the communication devices listed above. In addition the term graphical user interface should not be construed as limiting. Other types of user interfaces which can be implemented on a Device as well including Audio DTMF interfaces Voice User Interfaces VUI radio switch interfaces or a combination thereof can all be used to implement the various functions described below. For the sake of simplicity each of these types of methods by which a User may interact with their Device are generically referred to as a user interface .

All Devices regardless of their type preferably have a user interface that enables the user to operate the Device and communicate with other User s in the system . Although the user interface can be designed to have virtually an infinite number of different look and feel implementations there are certain functions and features that all Devices should have in common. These functions and features are listed below.

The user interface preferably includes one or more of the following status indicators or flags i battery indicator ii connectivity indicator iii clock iv transmitter status v transmission sync status vi Reviewing status vii Priority Messages needing attention and viii missed Messages.

The user interface preferably includes the following functions flags and components to conduct and manage a single Conversation i name of a Conversation and or list of Participants ii Conversation status iii Conversation type iv Conversation duration v time behind the Head of the Conversation vi outstanding Messages vii presence status of Participants viii meta data with navigation ix Conversation attributes or designators x Conversation set up including title scheduling Participants Conversation summary and xi indicators showing which Participants have contributed Messages and which have Listened to or Reviewed messages.

The user interface also preferably includes in addition to those listed immediately above the following functions flags and components to conduct and manage multiple Conversations i a name identifier for each Conversation ii live active or standing inactive indicator iii Review position either at Head or Time shifted iv Priority and other attributes and v indicators of what portions of Conversations were missed.

The user interface also preferably includes a number of navigation features such as i DVR style fast back forward per conversation ii instant messaging style personal message navigation iii Conversation Time indicators iv time scale shifting i.e. zooming backward and forward through a Message or the Messages of a Conversation v changing Priority of Conversations vi hanging up and vii home.

The aforementioned functions and features may be implemented in a variety of ways for example using a touch screen graphical user interface or other input devices such as the data entry buttons keys or keyboard a mouse by voice activated commands or a combination thereof. Again the functions and features listed above and how they are implemented is not intended to be exhaustive. The various methods and technologies that could be used is so comprehensive that it is not practical to list or discuss them all herein.

The MCMS application supports a number of different types of Conversations such as a near real time or live calls where the delay from when a Participant speaks and the other Participant s hear the first Participant is very small Conversations where Participants exchange voice Messages back and forth with a longer delay between Messages live conference calls involving multiple Users standing Conference calls at a regularly scheduled times or configurable structured call types such as a simultaneous briefing where Participants each leave a Message briefing beforehand for others to Review to before everyone joins the live conference call. Yet another unique attribute of the MCMS application is the ability for Users to transition between the different types of Conversations. For example the Participants can seamlessly transition from a voice messaging mode to a live call and back again. Or the Participants of a live conference call can transition to a voice messaging mode and send updates or action items to each other after the conference call. While several examples have been noted it should be understood that the system is extremely flexible and provides numerous options to transition between different types of calls or Conversations and between multiple conversations. By varying the delay between Messages the Participants effectively flows between the type of Conversation that best suits their needs. The above examples should therefore not be construed as limiting.

As noted above Conversations consist of Messages maintained in their original context and sequence. A sent Message either belongs to an existing Conversation or begins a new Conversation. A typical Conversation includes a set of Messages that are organized around a defined subject matter topic time Group or Channel. For example Conversations may involve a common Group of people such as the members of a club a company may have a standing Conversation at a fixed time such as a weekly sales meeting or friends may have ad hoc Conversations on various topics such as making dinner plans.

Each Conversation is defined by a set of attributes including a name a list of Participants begin and end time and state including at least pending active or terminated. Other Conversation states are possible in other embodiments. A User interacts with the MCMS application on their Devices . In preferred embodiments the interface allows a User to organize Conversations by any of the various attributes.

The relationship between a Participant and a Conversation also has attributes. These attributes include but are not limited to Priority Status states of participation in a Conversation . The values of Participant status include active participation in more than one Conversation at a time Reviewing a Conversation in a time shifted mode Catching Up To Live passively participating i.e. not actively Reviewing but receiving high Priority Messages standby or ignoring a Conversation i.e. declined to participate or record the Conversation .

From a recipient s perspective a User may select or define the relative priority of Messages. For example Messages from a person s boss would typically be given a higher Priority than a social acquaintance. In some embodiments a recipient has the ability to set their own Priorities. In the implementation of MCMS C the User selects a subset of their Conversations to be rendered consecutively. The User then sets ordered Priorities for these Conversations. The system uses the priorities set by the user to order the Messages to be rendered. The aforementioned algorithm queues the Messages to be rendered using User Priorities and information concerning Message data available beyond MTSD .

In other embodiments such as tactical communications the recipient may have no or limited ability to set Priorities. For example a fire fighter may have no ability to lower the Priority of Messages from the fire chief. A sending User however has the ability to send urgent or highly important Messages. By Tagging a Message as urgent or an emergency the Message is rendered as soon as possible at the recipient s overriding any Priority settings of the recipient. Any conflicts among multiple emergency messages are resolved based on a predetermined priority scheme.

Referring to an organizational diagram grouping the major functions of the MCMS application is illustrated. The major functions include account management conversation management aggregate conversation list management conversation participation call controls and contact management . After registering and logging into the system the User may navigate through the user interface of their Device implementing the various management functions described in detail below. In some embodiments this functionality will provide a great deal of flexibility. In other embodiments such as tactical or communication radios the implementation of the user interface may be constrained with many of the user functionality and options preconfigured to meet the utility of the device. The discussion here is exemplary and is not intended to be an exhaustive explanation of the MCMS functionality but rather is intended to provide just an overview of some of the MCMS attributes.

Under the account management function a registered User may change certain settings and preferences. A User may change their email address password name phone number phone password call in number default and or User defined rendering speeds Tags gain or volume levels for Reviewing Messages Catch Up to Live mode etc. To make these changes the User enters the appropriate information through the interface of their Device . The MCMS application responds by writing the updated preferences into the MCMS database .

As illustrated in conversation management is a set of functions that allow a User to view their aggregate Conversation lists create a new Conversation update the details of a Conversation delete a Conversation and close a Conversation. Each of these functions are described below.

View Conversations For each Conversation the MCMS application may provide the User the one or more of the following attributes the name of the Conversation the actual start time the last activity Tags duration and the list of Participants. For each Participant the name and or phone number status live other call in past catch up mode offline reachable offline unavailable. 

Create a Conversation A User creates a Conversation through the interface by inputting a Conversation name a list of Contacts and an optional scheduled start time. If no start time is designated it is assumed the start time is immediate. In response the MCMS application creates a new Conversation in the database associating records for each Participant on the Contacts list. The MCMS application also creates in the database Participant records for each User on the Contact list allowing the caller to receive the presence information of the others on the Contact list. If the Conversation is scheduled the MCMS application starts the Conversation at the designated time. Otherwise the Conversation starts right away.

Update Conversation Details The User may make changes to a Conversation through the user interface . For example Participants may be added or removed. Any change in status of the participants is updated in the MCMS database .

Delete a Conversation A User may delete a specific Conversation from their list of Conversations through the interface . In response the MCMS application notes the change in the database and designates the Conversation as deleted.

Close a Conversation A User may elect to terminate or close a Conversation. In one embodiment only the User that creates a Conversation can elect to terminate that Conversation.

As illustrated in the aggregate conversation list management is a set of functions that allow a User to engage in multiple Conversations i.e. the User s aggregate conversation list . The aggregate conversation list management functions allow a User through the interface on their device to participate in one Conversation live while participating in other Conversations in a time shifted mode.

Chose Conversation Through the interface a User may select one Conversation among the User s aggregate conversation list as current. The Messages of the current Conversation may be rendered in either the live or time shifted modes. The User may switch the current conversation among the aggregate conversation list from time to time.

Switch Conversations Modes In an optional embodiment a User may be able to switch from the MCMS MCMS C and MCMS S modes of operation.

As illustrated in conversation participation is a set of functions that allow a User to start a Conversation receive a notification to join a Conversation obtain Conversation status information and hang up on a Conversation.

Start a Conversation After a Conversation has been created either by the User through the interface or the scheduler in the MCMS application the status of each Participant is checked. If a Participant is offline then an effort is made to contact that person. If a Participant is online but engaged in another Conversation then the MCMS application notifies that Participant. The presence status of all online Participants is updated in the database .

Receive a Notification The system may notify a User that their attention has been requested on a Conversation through a graphic display and or audible notification via the user interface .

Conversation Status A user may request the status of a Conversation through the interface of their Device . In response the MCMS application assembles the status information stored in the database and presents the information to the User.

Conversation Pause Through user interface a User may hang up or switch away from an active Conversation. In response the MCMS application updates the User s participant status for active Conversations in the database and directs the Store and Stream module to remove the User from the Conversation.

As illustrated in conversation control is a set of functions that allow a User to control their participation in a Conversation. These functions allow a User to catch up to live skip to the Head jump to a past location pause play faster and play slower when Reviewing the Messages of a Conversation. Each of these functions is triggered by the User through the interface on the Device .

Catch up to live A User may Catch Up To Live in an ongoing Conversation using the CTL function. When this function is activated the MCMS application checks the last point in the Conversation the User has reviewed and directs the Store and Stream module to render the Messages not previously heard using a faster than normal rendering option designated by the User and to seamlessly transition to live mode when it reaches the head.

Jump to Head This function enables a User to jump to the Head of a Conversation skipping over any intervening Messages between the current point of the User in the Conversation and the Head. When implemented the MCMS application instructs the Store and Stream module to immediately render the Messages at the Head of the Conversation. If the Head of the Conversation is currently live this is called Jump to Live JTL .

Jump to past This function enables a User to jump back to a previous Message or point in the Conversation similar to a rewind or replay function. When implemented the MCMS application instructs the Store and Stream module to render Media starting from the rewind point.

Pause This function enables the User to pause the Reviewing of the Messages of a Conversation. In response the Store and Stream module stops the rendering of Messages until another command is issued.

Play faster This function enables a User to render Messages more quickly. In response the Store and Stream module renders the Messages at a faster rate than normal. The rendering rate may be either specified by the User or the User may select from a number of preset options.

Play slower This function enables a User to render Messages more slowly. In response the Store and Stream module renders the Messages at a slower rate than normal. The rendering rate may be either specified by the User or the User may select from a number of preset options.

As illustrated in the system provides the User with a host of functions for managing Contact lists and user Groups. These functions include the adding editing deleting Contacts and user Groups. Each of these functions are implemented by a User though the interface of their Device . Any revisions or deletions in a User s Contact list or Group list is stored in the MCMS database .

Add a Contact This function enables a User to add a new Contact to their contact list. The new Contact can be either a registered User or an external contact. Typically the name phone number s type of number cell office home computer etc. email address and other personal information are provided for each contact record.

Search for a Contact This function enables a User to search for a specific Contact in their contact list. The search may be conducted using a number of criteria such as name phone number most recently called most frequently called Group etc.

Get a Participant list This function enables a User to search and retrieve a list of Participants of a Conversation by a number of different search criteria including for example by name most recent outgoing calls most recent incoming calls most frequently called etc.

Authorize a caller to review status This function enables a first User to authorize other Users to view the first User s status. Non authorized Users may not view the status of the first User.

Create a Group of Contacts This function enables a User to associate a number of Contacts into a Group. When a User defines a Group the list of Contacts in that Group are stored in the MCMS database .

Edit a Contact Group This function enables a User to edit a Group or update the contact information for a member of the Group.

As noted above the MCMS C operation is similar to MCMS with the added feature of enabling Users to manage and participate in multiple conversations consecutively through a hierarchical system of Priorities and the time shifting of Messages which are automatically managed by the system Implementing the MCMS C functionality includes three basic processes. As illustrated in the first process involves defining a set of Conversations for consecutive rendering. Once the list is defined a hierarchical set of Priorities and other factors are applied to the indexed media payloads associated with the set of Conversations. The indexed media payloads are then sequenced into a sequencing order. By rendering the media in the sequence order the Messages of the set of Conversations are consecutively rendered.

Referring to a flow chart illustrating the steps for defining the list of Conversations to render consecutively is shown. In the initial step the User s aggregate list of Conversations is defined. Either the User or pre configuration data step is next used to select the Conversations among the aggregate list for consecutive rendering step . With a tactical communication system for example typically pre configuration data is used to impose the Conversations to be consecutively rendered. With non tactical applications the User is typically given a higher degree of flexibility to select the Conversations for consecutive rendering.

Referring to a flow chart illustrating the steps for defining hierarchical set of priorities for rendering the Messages of consecutive Conversations is illustrated. In the initial step a set of priority rules are defined and applied to the list of Conversations to be rendered consecutively . In various embodiments the set of priority rules may range from a rigid hierarchical communication protocol to a highly flexible communication protocol. For example in a tactical communication system where a rigid hierarchy is often desirable the set of priority rules will preferably impose a specific order in which concurrent Messages are rendered. For example with a first responder tactical system Messages from a fire chief may be given the highest priority. The next level of priority may be given to fire fighters inside a burning building. At the next level priority may be given to fire fighters outside the building etc. By defining a rigid priority the current Messages of those supervising the efforts to fight the fire or those in harm s way are rendered ahead of those performing a less critical role. With non tactical communications a User may be given a great deal of flexibility to define their own priority scheme to meet personal needs. A sales executive may for example define a priority scheme listing consecutive Conversations with clients from the most important to the least important. Or a User may prioritize consecutive Messages among family and friends. Regardless of the scheme used a priority list for consecutive Conversations is defined step in this process.

Referring to a flow diagram illustrating the construction of a queue of Messages received from the various consecutive Conversations is illustrated. In the initial step the availability of non rendered indexed media payloads of Messages i.e. media streams is continually detected step for each of the Conversations to be consecutively rendered. The priority hierarchy is applied to the available indexed media payload streams step . Based at least partially on the priority hierarchy and possible other parameters as mentioned below the available indexed media payloads are arranged into a sequence order step . The indexed media payloads are then continuously rendered in the sequence order step . By continuously repeating the above described process the Messages of multiple Conversations are consecutively rendered.

In one embodiment the sequencing order is based either partly or fully on the priority hierarchy. In alternative embodiments other parameters in addition to the hierarchy and availability may be considered as well. For example the sequence order may be defined using one or more parameters such as the switching costs associated with interrupting a currently rendered stream of indexed media payloads with the indexed media payloads of a higher priority Conversation the quality of the available streams of indexed media payloads the relative time the indexed media payloads were received a shuffling order or from input of a controller of the system.

Typically when conflicts between the Messages of different Conversations occur the indexed media payloads first in sequence order are rendered while the rendering of other available indexed media payloads are paused or delayed. When there no conflicts indexed media payloads are immediately rendered as they become available.

In yet another embodiment the Messages of the consecutively rendered Conversations may be optionally reviewed in a time shifted mode. If the User of the first communication device generated any Media associated with the consecutively rendered Conversations that media is indexed and stored in the PIMB of the Device as well as the PIMB s of the Servers on the network. Thus when a Conversation is reviewed in the time shifted mode the User has the option of reviewing just the incoming Messages associated with the Conversation or both the incoming Messages as well as the Media created by the first User associated with the Conversation in time index order.

In the MCMS S or simultaneous mode a User of a Client enabled Device may define a set of Conversations for simultaneous rendering. Once the set of Conversations is defined the indexed media payload streams associated with the set of Conversations are simultaneously rendered on the Device regardless if they overlap or not. In alternative embodiments the User may optionally render the received indexed media payloads from the set of media streams separately. The indexed media payloads of the simultaneous Conversations may also be optionally rendered in near real time or in the time shifted mode.

In a series of diagrams illustrating the attributes of a Conversation and the operation of MCMS MCMS C and MSMS S is illustrated.

In a time diagram illustrating the sequence of rendering the indexed media payloads of the Messages of a Conversation labeled A between a User X and two other users designated Y and Z . In this example Media is generated by user Y during the time intervals designated by t t t and t. Media is generated by user Z during the time intervals designated t t and t through t.

The rendering sequence at the Device of User X is illustrated at the bottom of the figure. During intervals t t and t Media derived only from Y is rendered. During intervals t and t only Media derived from Z is rendered. In intervals t and t Media from both Y and Z is rendered. In intervals t t and t nothing is being rendered because neither users Y or Z are generating Media during these periods. It should be noted that intervals t through t are not intended to mean fixed time intervals but rather just periods of time when Media is being generated.

The diagram of is useful in illustrating the attributes of Conversations. When one user is generating Media either Y or Z that Media is received at the Device of X and is available for rendering. When both users X and Y are generating Media both Media streams are received at Device of X and is available for Mixing. When neither user X or Y is generating Media no Media is received at Device of X. As noted above User X has the option of Reviewing the Media generated during Conversation A in either the near real time or time shifted modes. Also the User X has the option of Reviewing the Media in the Mixed format as illustrated or to separately Reviewing the Media from Y and Z in the time shifted mode.

With the MCMS application the User selects one Conversation as current. For the selected Conversation the User may Review incoming Messages and generate Messages which are transmitted to the other Participants of the Conversation. In this example the User selects in order Conversation B C and A as current respectively. The Message sequence is therefore initially B B and B followed by C and C and then finally A through A. Again while a particular Conversation is selected as current the User may transition between the near real time and the time shifted modes and back again. The final rendering as illustrated in the diagram is not intended to correspond in timing of the received Messages as illustrated in the top portion of the diagram. Rather the lower portion of the diagram is intended to show only the rendering order of the Messages based on Conversation order selected by the User.

The example of is thus useful in illustrating the attributes of the MCMS application. A User selects one Conversation as current. The other Conversations are paused. The User may also transition the current Conversation among all the Conversations at any time.

Referring to a diagram illustrating the operation of MCMS C is illustrated. In this example the User is Participating in two consecutive Conversations A and B. With Conversation A three Messages are received A A and A. With Conversation B three Messages are received B B and B. It is useful to note that with this example Message B conflicts with Messages A. Also Conversation A has a higher priority that Conversation B.

During the consecutive rendering of the two Conversations the higher priority Messages A and A are first rendered in near real time as represented by the vertical dashed lines in the figure. Since there is a relatively large time gap between Messages A and A this space is filled by time shifting and rendering Messages B and B. When A arrives it is rendered in near real time while Message B is rendered only after the higher priority Message A is rendered. By time shifting rendering of the lower priority Messages between the higher Priority Messages consecutive multiple conversations can be managed. It should be noted that in this simple example priority is the only parameter used to determine the consecutive order for rendering. As noted above a number of other parameters may be used as well.

Referring to a diagram illustrating MCMS S is illustrated. In this example a User is engaged in three simultaneous Conversations A B and C. The Messages A A and A B B and B and C and C are received for each Conversation A B and C are shown in the diagram respectively. With the MCMS S the incoming Messages are rendered at a recipients Device as they are received. The rendering sequence of the Messages of the three Conversations A B and C as illustrated in the lower portion of the diagram are therefore the same as when the Messages were received. In this manner multiple Conversations may be simultaneously rendered.

In the aforementioned examples several variations of the MCMS application were described including MSMS C and MCMS S. Regardless of the specific type of MCMS application used they all share several common characteristics. In each case the Conversations are defined by a threaded sequence or organization of Messages. The Messages are segmented from a stream of Media with each Message given a sequence identifier and indexed by the time the Media was created. Depending on the variation of the MCMS application Messages can be rendered in accordance with one or more rendering options. The rendering options include in one form or another the filtering grouping overlapping and or serialization of Messages using anywhere from zero to a plurality of different attributes. In this manner multiple Conversations each including a string of Messages can be conducted on a single Client enabled Device . Lastly each of the variations of MCMS may handle the receipt of interrupt Messages in the same way. When an interrupt Message is received it typically takes precedent over and is rendered before other Messages belonging to other Conversations.

Referring to a block diagram illustrating the hardware of a Device used for storing and executing the Client application is shown. The hardware includes a CPU main memory and mass storage . As is well known in the art the Client application is loaded and stored in main memory and mass storage and executed by the CPU .

Referring to a block diagram illustrating the hardware of a Server used for storing and executing the server application is shown. The hardware includes a CPU main memory mass storage and the archive . As is well known in the art the server application is loaded and stored in main memory and mass storage and executed by the CPU . As noted above indexed media payloads of one or more Users are stored in the archive .

Although many of the components and processes are described above in the singular for convenience it will be appreciated by one of skill in the art that multiple components and repeated processes can also be used to practice the techniques of the system and method described herein. Further while the invention has been particularly shown and described with reference to specific embodiments thereof it will be understood by those skilled in the art that changes in the form and details of the disclosed embodiments may be made without departing from the spirit or scope of the invention. For example embodiments of the invention may be employed with a variety of components and should not be restricted to the ones mentioned above. It is therefore intended that the invention be interpreted to include all variations and equivalents that fall within the true spirit and scope of the invention.

