---

title: Message-based model verification
abstract: A system and method may generate executable block diagrams having blocks that run in accordance with message-based execution semantics. A message may include an input data payload that does not change over time, and the message may persist for only a determined time interval during execution of block diagram. A verification engine may provide one or more tools for evaluating and verifying operation of message-based blocks. The verification engine may support one or more verification blocks that may be added to the block diagram and associated with the diagram's message-based blocks. The verification blocks may capture and present messages exchanged among the message-based blocks. The verification blocks may also specify an expected interaction of messages, and determine whether the actual messages are equivalent to the expected interaction.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09501339&OS=09501339&RS=09501339
owner: The MathWorks, Inc.
number: 09501339
owner_city: Natick
owner_country: US
publication_date: 20160115
---
The present application is a continuation of application Ser. No. 13 117 859 filed May 27 2011 which claims the benefit of U.S. Provisional Patent Application Ser. No. 61 349 401 filed May 28 2010 by Alan Moore et al. for a MESSAGE BASED TRACES AND VERIFICATION which applications are hereby incorporated by reference in their entireties.

Exemplary embodiments can be used for generating executable block diagrams in which at least some of the blocks run in accordance with message based execution semantics. Each message may be an instance of a message type and may include a payload comprising one or more data elements that do not change over time. A message may be generated at a particular point in time by a source block of the diagram and may persist for a determined time interval. Message types may be organized in one or more class hierarchies. In particular a plurality of base message types may be defined and for each base message type there may be one or more derived message types. Through the organization of the class hierarchy a message based block capable of receiving a base message type may also be capable of receiving any of the message types that are derived from that base message type. A message based block capable of receiving a particular derived type of message however may not be capable of receiving the corresponding base message type.

A message based modeling system which may be included within a high level modeling environment may support message based functionality in the block diagram. The system may include a library of pre defined graphical blocks configured to generate and send messages and to receive and process messages. The library of message based blocks may be organized as a class hierarchy. The modeling environment may include a graphical editor that provides a canvas in which a user may construct a block diagram. Each message based block may have one or more message ports for sending and receiving messages. In response to the message ports of selected blocks being interconnected such as through message based connections extending from source ports to destination ports the system may establish message based relationships among the interconnected blocks.

The system may further include a propagation engine that checks the message types among the interconnected message based blocks of the diagram. This process may be performed as part of a compilation of the block diagram. Specifically the propagation engine may determine whether a message type expected by a destination message block is compatible with the message type generated by the source message block. For example if a destination block expects to receive a message of a base message type as provided in the class hierarchy and the source block generates either the specified base message type or a message type that is derived from the specified base message type then the propagation engine may determine that the message based relationship is valid. If the destination block expects a different base or derived message type than the one generated by the source block or the destination block expects a derived message type and the source generates a base message type then the propagation engine may determine that the message based relationship is not valid and may issue a compilation error.

The system may also include a message based execution engine that controls the execution of the message based blocks in the diagram. More specifically during execution a source block generates a message at a particular point in time. The message based execution engine may maintain the message for a determined time interval. In addition the execution engine may send the message to one or more destination blocks triggering the execution of the one or more destination blocks and the execution engine may control the processing of the message by the one or more destination blocks.

In an embodiment the high level modeling environment may include systems that support other execution domains such as a time based execution domain. In addition the message based system may cooperate with such a time based execution system environment to implement a message time based hybrid execution model. The time based system may include a library of time based blocks and selected time based blocks may be added to the block diagram. A time based block describes a dynamic system of equations that defines time based relationships between signals and state variables. Signals represent quantities that change over time and may have values at all points in time. The relationships between signals and state variables may be defined by the set of equations represented by the time based blocks. Time based blocks may include signal ports that may be interconnected with signal based connections. The source of a signal corresponds to the block that writes to the signal during the evaluation of the block s equations and the destination of the signal is the block that reads the signal during the evaluation of the destination block s equations.

The time based execution engine executes the time based blocks in the diagram by evaluating the relationships between signals and state variables over time beginning at a start time and continuing to a stop time. Each evaluation of the relationships may be referred to as a time step.

As mentioned the message based system and the time based execution engine may cooperate to implement a hybrid environment. In particular the time based execution engine may organize the blocks into a sorted order which refers to the order in which the blocks operations or methods e.g. execution methods are invoked. The time based blocks are then executed according to the sorted order. When a message is generated within the block diagram the execution of the time based blocks may be suspended and the message may be sent to one or more destination blocks. The one or more destination blocks may then receive and process the message. When the processing of the message by the one or more destination blocks is complete execution of the time based blocks according to the sorted order may resume.

The message based system may also include a verification engine. The verification engine may support a library containing one or more verification blocks. Instances of the verification blocks may be added to the block diagram to evaluate the operation of message based blocks. The types of verification blocks may include an observer type a message sink type a generator type and a scenario type. The observer block may be used to visualize a set of messages referred to as a trace generated by one or more selected message based blocks of the block diagram. The set of messages of the trace may be ordered in time between a start time and an end time by the observer block. The observer block may be a floating block within the block diagram and it may be associated with a message based connection. The message sink block may be directly connected to a message based block and may be used to visualize a trace generated by that message based block. The generator block may be used to represent an external source of messages to the block diagram. The generator block may be connected to one or more message based blocks as a source and configured to generate one or more messages or traces that may then be received and processed by the one or more message based blocks to which the generator block is connected. The scenario block may be used to define valid and invalid traces. It may also or alternatively be used to define one or more constraints on one or more messages or traces. For example temporal constraints may be defined on one or more messages or between two or more messages. The scenario block may be associated with one or more message based connections in the block diagram whose messages may form a runtime trace to be evaluated. The scenario block may compare the defined valid and invalid traces and the one or more constraints to the runtime trace produced during execution of the block diagram. The scenario block may be further configured to take one or more actions if one or more of the runtime traces is not equivalent to the defined valid traces or the runtime traces are equivalent to the defined invalid traces. The scenario block may also take a specified action if the one or more constraints are not satisfied.

The removable medium drive may accept and read a computer readable medium such as a CD DVD floppy disk solid state drive tape flash memory or other medium. The removable medium drive may also write to the computer readable medium .

Suitable computer systems include personal computers PCs workstations laptops tablets palm computers and other portable computing devices etc. Furthermore exemplary processing elements include single or multi core Central Processing Units CPUs Graphics Processing Units GPUs Field Programmable Gate Arrays FPGAs Application Specific Integrated Circuits ASICs etc. Nonetheless those skilled in the art will understand that the system of is intended for illustrative purposes only and that the present invention may be used with other computer systems data processing systems or computational devices. The present invention may also be used in a networked e.g. client server computer architecture or a public and or private cloud computing arrangement.

Suitable operating systems include the Windows series of operating systems from Microsoft Corp. of Redmond Wash. the Linux operating system the MAC OS series of operating systems from Apple Inc. of Cupertino Calif. and the UNIX series of operating system among others.

A user or developer such as an engineer scientist programmer etc. may utilize the keyboard the mouse and the display to operate the high level modeling environment and construct or open one or more models of a system that is being designed. The model which may have executable semantics may represent a real world dynamic system that is being modeled simulated and or analyzed by the user.

In an implementation high level modeling environment may receive inputs by a user as the user creates edits revises and or opens one or more models as indicated by arrow . The model execution engine in cooperation with the modeling systems and may execute the model generating one or more results that may be presented to the user as indicated by arrow . A model may include a plurality of portions each operating according to a different execution domains. For example a first portion may operate according to message based semantics a second portion may operate according to time based semantics and a third portion may operate according to state based semantics.

In an embodiment a graphical model may be executable such that the model receives one or more inputs processes those inputs and produces one or more outputs.

In an embodiment a suitable high level modeling environment includes the MATLAB technical computing environment from The MathWorks Inc. of Natick Mass. The high level modeling environment may thus operate at a level that is even higher than other well known programming languages such as the C C and C programming languages. A suitable time based modeling system includes the SIMULINK environment from The MathWorks Inc. A suitable state based modeling system includes the Stateflow charting tool from The MathWorks Inc.

It should be understood that other modeling tools in addition to or in place of the time based modeling system and or the state based modeling system may be used in the environment . Other such modeling tools include dataflow systems such as the LabVIEW programming system from National Instruments Corp. of Austin Tex. and the Visual Engineering Environment VEE from Agilent Technologies Inc. of Santa Clara Calif. physical modeling systems such as The Simscape product from The MathWorks Inc. Unified Modeling Language UML systems and Systems Modeling Language SysML systems among others. In addition a lower level programming language such as the C C and C programming languages among others may also be used to create one or more models or model portions.

The propagation engine message based execution engine verification engine report generator interface engine message based object constructor and class packages may each comprise registers and combinational logic configured and arranged to produce sequential logic circuits. In an embodiment the propagation engine message based execution engine verification engine report generator interface engine message based object constructor and class packages may be implemented through one or more software modules or libraries containing program instructions pertaining to the techniques described herein. The software modules may be stored on main memory and or computer readable media such as computer readable medium and executable by one or more processing elements such as processing element . Other computer readable media may also be used to store and execute these program instructions. In alternative embodiments various combinations of software and hardware including firmware may be utilized to implement the present invention.

In an embodiment the message based components of a graphical model as well as the messages generated during execution of the model may be objects and these objects may be defined by creating classes which are not objects themselves but which act as templates that instruct the constructor how to construct an actual component and message object. A class may for example specify the number and type of data variables and the steps involved in the functions which manipulate the data. The object constructor may use the corresponding class definition and additional information such as arguments provided during object creation to construct the object. Likewise objects may be destroyed by a special function called a destructor . Objects may be used by manipulating their data and invoking their functions.

It should be understood that other possibly more complex class hierarchies may be provided. For example additional base classes may be provided and one or more of the subclasses may include subclasses of its own and so on.

While the message types are referred to as classes in an embodiment they do not have any methods. Instead the specialization of the message classes may add new properties i.e. data members only.

In an embodiment an instance of a message object may include one or more data elements. is a schematic illustration of a data structure representing the data elements of an instance of a message object. The data structure may be organized into a plurality of fields and sub fields each storing particular information. For example the data structure may include a message type field a message identifier ID field a valid flag a time to live TTL field and a payload field . The message type field may store information that indicates the particular type of message the message ID field may store an identifier that uniquely identifies the message the valid flag may indicate whether the message is valid or invalid the TTL field may store information indicating how long the message should be maintained and the payload field may store information associated with the message that was generated by the message source and that may be used by one or more message destinations.

It should be understood that the data structure may include additional or fewer fields. In addition the payload field may be organized into a plurality of sub fields.

In another embodiment message based components and or messages may be instances generated from types instead of being objects generated from classes. Those skilled in the art will understand that other implementations of message based components and or messages may be utilized.

In an embodiment a user may select one or more types of message based components from the library browser. In response the constructor may access the component class package and create an object instance of the selected type as indicated at block . The object instance may be stored in memory such as main memory and an icon such as a block may be added to the canvas as indicated at block .

The user may configure one or more of the components of the model to generate and or receive a message as indicated at block . For example a user may open a properties or other page associated with a selected message based component that has been added to the canvas. The property page may include fields or other data entry elements for receiving information for example from the user specifying a message type that the component is to receive. In response the object constructor or another module such as the model builder may add an input port to the block as presented on the canvas. Similarly the property page or another property page may include fields and data entry elements for receiving information that specifies a message type that a selected component is to send. In response an output port may be added to the block as presented on the canvas. In this way a user may add a plurality of blocks representing message based components to the canvas and provide these blocks with input and output ports for receiving and sending messages.

The user may define message based relationships among the message based components of the model as well as the other components as indicated at block . For example the user may define a message based relationship graphically by drawing a message based connection between the input and output ports of message based blocks. More specifically the user may configure a given message based component to receive a particular message by drawing a connection from the source of the message such as the output port of another message based component to the respective input port of the given message based component. Likewise the user may configure a selected message based component to send a message by drawing a connection from the respective output port of the selected message based component to the destination of the message. In response to the definition of message based relationships e.g. by the user the message based execution engine may add the destination component to a list of listeners for the respective message as indicated at block . Specifically the execution engine may create a list of listeners for each message for which a message based relationship has been defined in the model. If a message based relationship is removed for example by the user deleting a message based connection between two message based blocks the execution engine may remove the destination component from the list of listeners for that message.

In an embodiment model components operating in domains other than the message based execution domain may be configured to send or receive messages. For example a user may draw a message based connection between a message based block and a block operating in another domain such as the time based domain the state based domain the dataflow domain etc. Likewise a user may draw a message based connection from a block operating in another domain to a message based block.

The Message Generator block may be configured to have two input ports each associated with a respective type of message that the Message Generator block is interested in receiving. The Message Generator block also may be configured to have one output port that is associated with a message type that the Message Generator block may send. The Message Buffer block may be configured with an input port and an output port each associated with a respective message type. The Message Receiver block may be configured with an input port and two output ports each associated with a respective message type. In addition the state based portion may be configured with a first input port that is associated with a type of message and a second input port that is associated with a signal. The state based portion may be further configured with a first output port that is associated with a type of message and a second output port that is associated with a signal.

Message based relationships may be established among the time based portions the state based portion and the message based portion . For example a user may connect various input and output blocks of the model with message based connections. In response constructor may create message object instances and the execution engine may establish message based relationships among the respective portions or components of the model .

In an embodiment before execution of the model the propagation engine may analyze the construction and configuration of the model to determine whether during execution of the model those blocks that are configured to receive messages will receive the intended messages as indicated at block . In particular the message based execution engine and the model execution engine may build an in memory representation of the model such as an intermediate representation IR . The IR may include a plurality of nodes that may represent the blocks of the model and edges that represent connections within the model. The IR may also be annotated with additional information such as the types of messages that destination blocks are configured to receive the types of messages that source blocks are configured to send etc. The IR may be created as part of a compilation stage that marks the start of model execution. This compilation stage may include preparing data structures and evaluating parameters configuring and propagating block characteristics determining block connectivity and performing block reduction and insertion. In addition one or more optimization techniques may be applied to the IR. After the application of an optimization technique an additional IR may be generated. The propagation engine may analyze one or more of these IRs.

The propagation engine may evaluate this IR examining for example those elements of the IR that represent the input ports of message based and other blocks. The propagation engine may determine the type of message that the given message block expects to receive on a subject input port. The propagation engine also may identify the upstream block that is connected to the subject input port of the given message based block. The propagation engine may determine the type of message issued by this upstream block. In addition the engine may determine whether the type of message defined for the output port of the source component complies with the type of message defined for the input port of the destination component. If a mismatch is identified by engine it may be reported. For example an error message or error report may be generated and presented for example on the display for review by the user.

The model may be simulated e.g. executed or run. For example the model editor window may include a Run command button that may be selected by the user e.g. with the mouse . Alternatively the user may enter a text based run command for example in a Command Line Interface CLI or the model may be run programmatically.

In an embodiment the model execution engine interfaces with the time based system the state based system and the message based system to execute the entire model as indicated at block .

In an embodiment the time based modeling system may create a sorted order of the time based components of the model as indicated at block . The sorted order may refer to the order in which to invoke block methods during execution of the model . Exemplary block methods for time based components may include an output method that computes the output signals of the block based on its input signals and its state an update method that computes the block s states and a derivatives method that computes the derivatives of the block s continuous states. Time based components that are configured to execute together may be identified as a group in the sorted order. For example a time based subsystem may include a plurality of time based blocks and the subsystem may be configured to run as an atomic subsystem. In this case all of the time based blocks of the atomic subsystem execute atomically as a group. The time based modeling system may also define a simulation start time a simulation end time and a plurality of time steps between the start and end times. The size of the time steps may depend on the particular solver being used to execute the model.

Input and output signals may be represented graphically in the model or block diagram by arrow elements extending between time based blocks. Input and output signals represent quantities for example input and output data that change over time during the execution of the model and the quantities represented by the signals may be defined and thus have values for all points in time between a model s start time and its stop time. Execution of a model may also be referred to as simulation of the model.

In an embodiment one or more initialization steps may be performed before execution of the model begins. For example one or more state based portions of the model may execute one or more default transitions as indicated at block . Initialization steps for message based portions of the model may involve typical operations such as dequeuing a waiting message.

For each time step of the simulation which may begin with the simulation start time execution of model may proceed as follows. The time based modeling system in cooperation with the model execution engine may begin executing the time based components of the model according to the sorted order as indicated at block . If an event that is a triggering event for a state based portion of the model occurs the execution of the time based components may be suspended as indicated at block . The triggered state based portion may be executed as an atomic unit for example by the state based modeling system in cooperation with the model execution engine as indicated at block . Upon completing the execution of the state based portion the execution of the time based components may resume from the point in the sorted order at which execution had been suspended as indicated at block . For example the model execution engine may record where in the sorted order the execution was suspended to execute the state based portion.

In an embodiment an input triggering event may occur outside of a state based portion for example by a time based or other component but may be visible within the state based portion. Exemplary input trigger events may include an edge triggered input event and a function call for example from a time based component. An edge triggered input event may be configured to operate on a rising edge a falling edge or either a rising or falling edge. To operate as an input edge triggered input event a signal from a time based component may need to cross zero such as a changing from 1 to 1. In contrast a function call input event may consist of an instantaneous flow of control from a caller subsystem to a callee subsystem. A triggering event for a state based portion whether it is an edge function call or other trigger may not provide any input data to the state based portion which the state based portion might otherwise use for processing for example to generate output data. Instead the triggering event may operate as a control signal that triggers execution of the state portion and the state based portion may operate upon input data that is internal to the state based portion or that is received in other ways besides a triggering event.

If the triggering event for the state based portion occurs during the execution of a group of time based components that are configured to execute atomically then the execution of the entire group of time based components may be completed. Further execution of time based components may then be suspended and the execution of the triggered state based system performed.

If a message is generated and sent for example during the execution of time based components according to the sorted order then the execution of time based components may be suspended as indicated at block . The message based execution engine may examine the list of listeners for the respective message. The execution engine may send the message to the components on the list of listeners as indicated at block . If the destination component is triggered by the receipt of the message the execution engine may execute the destination component as indicated at block . The message based execution engine may also start a timer associated with the generation of a message and may track the age of the message as indicated at block . For example the engine may use the clock to operate one or more timers. When the age of the message reaches its maximum age which may be indicated in message s TTL field the message may be destroyed by the message based execution engine as indicated at block . Each message may thus persist for only a defined time period during the execution of a model.

Upon completing the execution of the components triggered by the message the execution of the time based components may resume from the point in the sorted order at which execution had been suspended as indicated at block .

It should be understood that the model execution flow described in connection with one or more of steps to may be nested. For example the execution of a state based portion may generate a message triggering the execution of a message based portion which may trigger the execution of a state based portion and so on.

It should be understood that a message may be sent to a message based component a state based component a time based component or some other component. In addition the message based component the state based component and the time based component may execute in response to the received message.

The life time of a message may depend on the semantics of the message processing environment. A message implemented using function call semantics may get created and consumed in the same time step thus resulting in a lifetime of a single time step. In the presence of queuing semantics messages can be produced in one time step but wait in a message queue for a number of time steps before they are consumed. In addition the consumer can choose to process a message without consuming the message thus resulting in messages with potentially infinite lifetime.

In an embodiment instead of sending a message to a destination component the message based execution engine may notify a destination component that a message has been created. In response the destination component may retrieve the message. If the destination component fails to retrieve the message before its maximum age is reached the message may be destroyed before ever being retrieved.

In an embodiment a message based component may be configured upon sending a message to expect a reply to its message. Such a component may be configured to execute in a synchronous or asynchronous manner. For example the component may be configured to execute synchronously in which case the component after sending its message waits to receive the reply before continuing with its execution. Alternatively the component may be configured to execute asynchronously in which case the component after sending its message proceeds with its execution without waiting for the reply.

In an embodiment a state based portion of the model may be configured to execute during a time step even though no triggering event for that state based portion occurred during the time step. More specifically a state based portion may register for time based triggering. If the model includes a state based portion that is registered for time based triggering and the state based portion has not already executed during the current time step then the model execution engine may execute the state based portion as indicated at block .

At this point execution during the current time step may be complete. If the current time step does not equal the simulation end time the current time step may be incremented and the execution process may be repeated. This process for example steps to may be repeated for each time step between the simulation start time and the simulation end time.

Referring to model execution at each time step may proceed as follows. Time based Constant and Gain blocks and may execute first as they may be the first blocks in the sorted order. The signal output of Gain block may be a trigger event for the state based portion . Accordingly after Gain block executes execution of other time based components may be suspended and the state based portion may be executed. The Message Receiver block is configured to listen for a message from the state based portion on input port . If the execution of the state based portion results in the generation and sending of this message the message is received by Message Receiver block causing it to be executed. Next the blocks of the second time based portion execute following the completion of execution of the Message Receiver block assuming it executes. Execution of the second time based portion results in the generating and sending of a message that is received by the Message Generator block . If the second time based portion is configured as an atomic subsystem then all of its blocks including Gain block and Outport block will execute before the Message Generator block executes. On the other hand if the second time based portion is not configured as an atomic subsystem then the Message Generator block may execute before execution of the Gain block and Outport block .

If the execution of the Message Generator block results in the generation and sending of a message then the Message Buffer block may execute as it is triggered by such a message. If the execution of the Message Buffer block results in the generation and sending of a message then the state based portion may execute again.

At this point execution of the current time step may be complete. The model execution engine may increment the time step and execute the model again unless the simulation end time has been reached.

In a further aspect of the invention verification or other testing may be performed on one or more message based portions of a model. In an embodiment one or more verification components may be provided to verify a message based portion of a model.

In an embodiment the verification engine may create a first verification component which may be referred to as an observer for verifying one or more messages in a model. The observer may be associated with a particular message based connection in a model and may present information concerning one or more of the messages that travel across that connection during execution of the model. In an embodiment the observer component operates at least in part as a viewer to present information concerning all of the messages that travel across the selected connection during execution of the model. The observer component may provide a message based view that includes the set of message participants such as the sources and destinations the types of messages generated and sent and the payloads of those message. This collection of information may be referred to as an interaction.

Suppose a user is interested in examining and verifying the actual messages exchanged between the Bus component and the Controller component across the message based connection during execution of the model . In this case the user may access an Observer component such as Observer component or block .

The verification engine may receive a request for an Observer block as indicated at block . The verification engine may also receive a designation of one or more message based connections to which the requested Observer block is to be associated as indicated at block . In response to the request the verification engine may cooperate with the constructor to create an Observer component such as an object instance. In addition the model builder may present a corresponding Observer block such as block in the graphical model as indicated at block . A user may issue a request for an Observer block either textually e.g. by entering a command in a Command Line Interface CLI or graphically e.g. by selecting an Observer block from a library browser. In an embodiment a user may select a message based connection of interest for example connection such as with the mouse . In response the verification engine may present one or more selectable commands in a drop down list including an Insert Observer Block command. The user may select the Insert Observer Block command thereby causing an Observer component to be created that is associated with the selected message based connection.

In an embodiment the Observer block may include a plurality of Graphical User Interface GUI elements. Specifically the Observer block may include corresponding icons for the two or more message based participants e.g. the components connected by the message based connection to which the Observer block is associated. Here the Observer block may include a first box element representing the Bus component and a second box element representing the Controller component . The Observer block may also include a line element such as line elements extending from each box element . Information concerning messages exchanged between the Bus component and the Controller component across message based connector may be presented between the line elements of the Observer block .

After issuing a request for an Observer block and associating it with a message based connection of interest the model may be executed as indicated at block . As part of the execution of the model the Bus component may generate and send one or more messages to the Controller component and the Controller component may respond with one or more reply messages. Information concerning this exchange of messages may be presented by the Observer block .

Specifically the verification engine may monitor the sending and receiving of messages across the selected message based connector as indicated at block . For example the verification engine may interface with the message based execution engine . In addition as each such message is generated and sent the verification engine may add an entry to the Observer block for that message as indicated at block . The verification engine may also include within each entry one or more information elements concerning the respective message as indicated at block . For example the verification engine may add an arrow element to the Observer block for each actual message. An arrow pointing from line element which extends from box element to line element which extends from box element may represent a message sent from the Bus component to the Controller component . An arrow pointing from line element to line element may represent a reply message sent from the Controller component to the Bus component . The verification engine may also include a data element at each entry that indicates the type of message sent and that includes information from the message s payload. The entire payload or a portion thereof may be included in the entry s data element.

In addition the verification engine may include one or more time elements in the entry for a given message. The one or more time elements may contain information relating to the timing characteristics of the message. In particular a message may be sent by a source component at a particular time which may be denoted as the TimeSent T and may be received by a destination component at a particular time which may be denoted as TimeReceived T. One or more of these timing characteristics such as Tand or T may be included in the entry of the Observer block by the verification engine .

The timing characteristics of a message may be determined by the verification engine in cooperation with the message based execution engine . For example system may receive a clock signal from system clock and the message based execution engine may use this clock signal to identify one or more timing characteristics of messages.

As illustrated in the Observer block four messages were generated and sent across the message based connection during execution of the model as indicated by arrow elements . All four messages were sent by the Bus component to the Controller component as indicated by the arrow elements . Furthermore each of the four messages may be Altitude type messages and may carry the following payloads 10 000 20 000 30 000 and 40 000 . In addition the four messages were received by the Controller component at the following times 12 s 18 s 20 s and 21.4 s as indicated by timing elements of the Observer block .

The verification engine may also receive a request for a report of the messaging information presented by the Observer block as indicated at block . For example a user may request such a report. The verification engine may provide the information to the report generator as indicated at block and the report generator may create a report as indicated at block . The report generator may provide the report to an output device such as the display a printer etc. as indicated at block . The report generator may also or alternatively save the report in memory as indicated at block .

The Observer block may be docked that is fixed to the model . The Observer block also may be visually associated with the message based connection through a line element not shown connecting the Observer block to the connection . Alternatively the Observer block may be a floating block. A floating block is not locked to any particular location in the model but may be moved around the canvas for example by the user. In this case an icon such as a glasses element may be placed near the connection to indicate that an Observer block is associated with this message based connection.

The verification engine may create a second verification block referred to as a Message Source block. The Message Source block may be connected to a destination component of a model through one or more message based connections. The Message Source block may be used to define one or more messages and these messages may be sent from the Message Source block to the destination block during execution of the model.

The verification engine may receive a request for a Message Source block as indicated at block . In response the constructor may create an instance of a Message Source block and the model builder may present a Message Source block and a Generator block on the canvas as indicated at block . The verification engine may also receive a designation of one or more destination blocks that are to receive messages generated and sent by the Message Source block as indicated at block . The verification engine may provide one or more GUI elements within the Generator block for receiving information that defines one or more messages to be generated and sent by the Message Source block . For example the verification engine may include a system boundary box element and a Controller box element in the Generator block . The verification engine also may include a first line element extending from the system boundary box element and a second line element extending from the Controller box element . Information defining one more messages may be entered for example by the user between the first and second line elements . For example a user may draw an arrow element e.g. using the mouse from first line element to the second line element thereby defining a first message to be generated and sent to the Controller component during execution of the model . The user may enter information specifying the type of message its lifetime and its payload. The user may also specify one or more timing characteristics such as when each message is to be sent. For example the user may indicate that a respective message is to be generated and sent during each time step of the model s execution. Alternatively the user may specify that a respective message is to be sent once during the execution of a model such as during a designated particular time step. As the user enters information defining one or more messages in the Message Source block this information may be received by the verification engine as indicated at block .

For example a first arrow element may be added to define a first message of type Altitude having a payload of 10 000 and a message send time of 12 s. A second arrow element may be added to define a second message of type Altitude having a payload of 20 000 and a message send time of 18 s. A third arrow element may be added to define a third message of type Altitude having a payload of 30 000 and a message send time of 20 s. A fourth arrow element may be added to define a fourth message of type Altitude having a payload of 40 000 and a message send time of 21.4 s. A fifth arrow element may be added to define a fifth message of type Anomaly with a message send time of 22 s.

Once the desired messages have been defined the model may be executed as indicated at block . During execution of the model the verification engine may cooperate with the execution engine to cause the one or more messages defined in the Generator block to be generated and sent by the Message Source block at the specified times where the messages are of the specified type and carry the specified payloads as indicated at block . One or more of these messages may trigger execution of the Controller component as indicated at block .

Message generation time may be specified in absolute terms for example from the start of the simulation of a model. In addition message generation time may be specified relative to a preceding message.

The verification engine may create a third verification block referred to as a Message Sink block. The Message Sink block may be connected to a source component of a model through one or more message based connections and may present information concerning one or more messages generated by the source component during execution of the model. In an embodiment the Message Sink block operates as a viewer to present information concerning all of the messages generated by the source component during execution of the model.

The verification engine may receive a request for a Message Sink block as indicated at block . The verification engine may also receive a designation of one or more message sources for the Message Sink block as indicated at block . In response to the request the constructor may create a Message Sink object instance and the model builder may present a corresponding Message Source block and a Message Viewer block in the graphical model as indicated at block . A user may issue a request for a Message Source block either textually e.g. by entering a command in a Command Line Interface CLI or graphically e.g. by selecting it from a library browser.

In an embodiment the Message Viewer block may include a plurality of GUI elements. Specifically the Message Viewer block may include a first box element for the message source i.e. the Bus component and a second box element for a system boundary. The Message Viewer block may also include a first line element extending from the first box element and a second line element extending from the second box element . Information concerning messages generated and sent by the Bus component may be presented between the first and second lines of the Message Viewer block .

After requesting the Message Sink block and connecting it to the source of interest the model may be executed as indicated at block . As part of the execution of the model the Bus component may generate and send one or more messages.

The verification engine may monitor the generating and sending of messages by the Bus component as indicated at block . In addition as each such message is generated and sent the verification engine may add an entry to the Message Viewer block for that message as indicated at block . The verification engine may also include one or more information elements for each entry added to the Message Viewer block as indicated at block . These information elements may provide additional information on the messages. Specifically each entry may include an arrow element extending from the first line element to the second line element thereby indicating that the message was sent by the Bus component . Each entry may also identify the type of message and may include information from the message s payload. The entire payload or a portion thereof may be included in the respective entry in the Message Viewer block . One or more entries may also include one or more time elements that provide information concerning the timing characteristics of the respective message such as the time the message was sent T and or the time the message was received T.

For example a first arrow element may be presented in the Message Viewer block during execution of the model by the verification engine indicating that a first message of type Altitude having a payload of 10 000 was sent by the Bus component at time 12 s. A second arrow element may be presented indicating that a second message of type Altitude having a payload of 20 000 was sent at time 18 s. A third arrow element may be added indicating that a third message of type Altitude having a payload of 30 000 was sent at time of 20 s. A fourth arrow element may be presented indicating that a fourth message of type Altitude having a payload of 40 000 was sent at time of 21.4 s.

The verification engine may also receive a request for a report of the message information captured by the Message Sink block and or presented in the Message Viewer block as indicated at block . For example a user may request such a report. The verification engine may pass the information to the report generator as indicated at block and the report generator may create a report as indicated at block . The report generator may provide the report to an output device such as the display a printer etc. as indicated at block . The report generator may also or alternatively save the report in memory as indicated at block .

The verification engine may create a fourth verification block referred to as a Scenario block. The Scenario block may be connected to one or more message based connections. In addition a Scenario block may include a specification of one or more valid and or invalid interactions. That is the specification may define the messages that are expected to be exchanged on the one or more message based connections that have been associated with the Scenario block. A set of messages in a particular order may be referred to as a trace. The Scenario block may also include one or more constraints on the expected messages. When the model is executed the verification engine based on information contained in the Scenario block may determine whether the messages actually generated during execution are equivalent to the expected messages and or satisfy the one or more constraints. If not the verification engine may take one or more actions such as suspending the execution of the model stopping execution of the model issuing an alert outputting the non conforming message or trace generating a new scenario block whose specification corresponds to the non conforming message or trace etc. The Scenario block may also display information concerning the actual messages generated during execution of the model.

The verification engine may receive a request for one or more Scenario blocks to be added to a model as indicated at block . Suppose for example a user is interested in evaluating the manner in which the Bus component and the Controller component process messages. The user may request a first Scenario block to evaluate the messages generated and received by the Bus component and a second Scenario block to evaluate the messages generated and received by the Controller component. The user may issue a request for a Scenario block graphically textually or through a combination of textual and graphical inputs to the high level modeling environment. For example a user may select a Scenario block from a library browser.

In response the constructor may create an instance of a Scenario object and the model builder may add a Scenario block to the model canvas displaying the model as indicated at block . Specifically the verification engine may add first and second Scenario blocks to the model . The verification engine may also receive a designation of one or more message based components to be associated with each Scenario block as indicated at block . For example a user may associate the first Scenario block with the messages corresponding to message based connections and . The user may also associate the second Scenario block with the messages corresponding to message based connections and .

The verification engine may receive information specifying an interaction as indicated at block . That is the verification engine may receive information concerning the messages expected to be generated and sent during model execution. In an embodiment a Scenario block may include a plurality of GUI elements for receiving information specifying an interaction. For example because it is associated with message based connections and the first Scenario block may include a Sensors box element a Bus box element and a Controller box element . A line element such as line elements and may extend from each box element and respectively. A user may specify one or more expected messages by drawing arrow elements between line elements and . The specification may include the type of message its payload and its timing characteristics among other information. For example the user may specify the sending of an Altitude type message from the Sensors component to the Bus component as indicated by arrow element and the sending of an Altitude type message from the Bus component to the Controller component as indicated by arrow element .

The user may also specify one or more constraints for the expected messages. For example the user may specify that the second altitude message is to be received by the Controller component within 1.0 seconds of when the Sensors component sends the first altitude message . The specification of this timing constraint may be performed by the user at the first Scenario block . For example the user may specify a time sent T value of timeNow for the sending of the first altitude message by the Sensors component at the tail of the arrow element where it joins line element . The user may also specify a time receive T value of timeNow

The user may specify that two anomaly messages are expected as represented by arrow elements and and that the second anomaly message should be received by the Controller component within 0.1 seconds of when the first anomaly message is sent by the Sensors component .

It should be understood that a determined order of the messages may be specified for example by a user or programmatically. The determined order may be specified within the Message Scenario block and may be a sequential order.

A Scenario block may receive additional constraints besides or in addition to constraints concerning the ordering and timing of messages.

The information specified in a Message Scenario block such as the source and destination components message types payloads and constraints may be referred to as an interaction. Other techniques besides or in addition to the use of arrow and other GUI elements may be used to specify an interaction or one or more parts thereof for example one or more textual inputs may be used.

The second Scenario block may include a Bus box element a Controller box element and an Actuators box element since it is associated with message based connections and . A line element such as line elements and may extend from each box element and respectively. Between line elements and the user may draw arrow elements representing the messages expected to be sent by the Bus component and received at the Controller component and the order of those messages. The user may specify a determined order such as a sequential order of message occurrence textually and or graphically for example by drawing the arrow elements that represent those messages in a vertically descending order. That is the message represented by a first arrow element is expected to occur before a second message represented by a second arrow element if the first arrow element is drawn above the second arrow element in the Scenario block.

As shown in the second Scenario block a user may draw two arrow elements between lines and associated with the Bus and Controller components . Specifically the user may draw a first arrow element representing an Altitude type message with a payload of 10 000 and a second arrow element representing an Anomaly type message. Following this sequence of messages between the Bus and Controller components the user may draw arrow elements representing expected messages between the Controller and Actuators components . Specifically the user may draw a third arrow element representing a DumpFuel type message a fourth arrow element representing a ReleaseStage type message and a fifth arrow element representing a ReleaseTank type message.

The verification engine may also receive one or more actions that are to be performed if an actual message occurs during the execution of the model that is not equivalent to the specified interaction or to one or more constraints specified in a Scenario block as indicated at block . For example a user may open a property page not shown associated with a Scenario block and may specify a desired action e.g. by selecting one or more radio buttons or checkboxes. Actions that may be specified may include stopping the execution of the model pausing or suspending its execution until released e.g. by the user logging an error outputting the one or more actual messages generating a new Scenario block whose specification is the one or more actual messages and using the new Scenario block in the model and or presenting an alert. The particular action or actions may be user settable for example through a property page or dialog of the Scenario block.

After the one or more Scenario blocks have been configured as desired e.g. by the user or programmatically the model may be executed as indicated at block . As part of the execution of the model the Sensors Bus and Controller components may generate and send one or more messages. The verification engine may monitor the sending and receiving of messages across the message based connections that have been associated with the one or more Scenario blocks as indicated at block . In addition the verification engine may compare the actual messages that occur during execution of the model with the interaction contained by the one or more Scenario blocks as indicated at block . The verification engine may determine whether an actual message occurs that is not equivalent to an expected message as specified by the interaction as indicated at decision block . If an actual message is not equivalent the verification engine may perform the specified action as indicated by No arrow leading to block . The verification engine may also determine whether an actual message fails to satisfy a constraint specified through a Scenario block as indicated by decision block . If an actual message does not satisfy a constraint the verification engine may perform the specified action as indicated by No arrow leading to block . It should be understood that the same action may be performed. If the actual messages occur according to the determined order and satisfy any other specified constraints the model may execute to completion as indicated by Yes arrows leading to block . The specified action may include or may be allowing the model to continue execution.

It should be understood that other or different GUI elements may be utilized or supported by one or more of the verification blocks. For example an additional GUI element may be provided for the Scenario blocks through which a series of looping messages may be specified by a user.

In an embodiment the high level modeling environment may include one or more code generation modules for generating code from a model such as C code C code Hardware Description Language HDL code etc. The code generation module may generate code for one or more verification blocks such as the Scenario blocks. If the code for the Scenario block detects an invalid trace for example it may generate an error message that could be read by another code module which in turn may take some predetermined action such as resetting the deployed systems or sending a signal to a processing unit.

The generated code moreover may be used in a deployed system that may be a real world system that is physically separate from the data processing system on which the high level modeling environment operates. Exemplary deployed systems include controllers such as Engine Control Units ECUs used in cars and trucks Anti lock Braking Systems ABS aircraft flight control systems etc.

Suitable code generation models include the Real Time Workshop code generator and the Simulink HDL Coder products from The MathWorks Inc.

The foregoing description of embodiments is intended to provide illustration and description but is not intended to be exhaustive or to limit the invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from a practice of the invention. For example while a series of acts has been described above with respect to the flow diagrams the order of the acts may be modified in other implementations. Further non dependent acts may be performed in parallel. Also the term user as used herein is intended to be broadly interpreted to include for example a computer or data processing system e.g. system or a user of a computer or data processing system unless otherwise stated.

Further certain embodiments of the invention may be implemented as logic that performs one or more functions. This logic may be hardware based software based or a combination of hardware based and software based. Some or all of the logic may be stored in one or more tangible non transitory computer readable storage media and may include computer executable instructions that may be executed by a computer or data processing system such as system . The computer executable instructions may include instructions that implement one or more embodiments of the invention. The tangible non transitory computer readable storage media may be volatile or non volatile and may include for example flash memories dynamic memories removable disks and non removable disks.

No element act or instruction used herein should be construed as critical or essential to the invention unless explicitly described as such. Also as used herein the article a is intended to include one or more items. Where only one item is intended the term one or similar language is used. Further the phrase based on is intended to mean based at least in part on unless explicitly stated otherwise.

The foregoing description has been directed to specific embodiments of the present invention. It will be apparent however that other variations and modifications may be made to the described embodiments with the attainment of some or all of their advantages. For example one or more message based blocks such as a verification block may be configured through a command line Application Programming Interface API that may be provided by the message based object constructor or the verification engine. Therefore it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention.

