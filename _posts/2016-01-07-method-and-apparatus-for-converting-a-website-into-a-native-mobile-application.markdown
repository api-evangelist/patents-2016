---

title: Method and apparatus for converting a website into a native mobile application
abstract: Disclosed herein are a number of embodiments for effective and user-friendly tools that are designed to automatically convert a website into a native app for execution by a mobile computing device such as an Android device or an iOS device. Such tools permit website owners to quickly generate native apps for their websites without the need for any significant programming efforts by app developers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09448776&OS=09448776&RS=09448776
owner: APPNOTCH LLC
number: 09448776
owner_city: St. Louis
owner_country: US
publication_date: 20160107
---
This patent application claims priority to U.S. provisional patent application 62 101 337 entitled Method and Apparatus for Converting a Website into a Native Mobile Application filed Jan. 8 2015 the entire disclosure of which is incorporated herein by reference.

With the ubiquity of mobile computing devices such as smart phones and tablet computers many people use mobile applications apps or mobile apps executed by their mobile computing devices to electronically access information and or services content .

While apps are widespread much more widespread are websites. However given the growth in usage of apps many website owners have a desire to make website content available to users via apps to add an additional channel for engaging users as well as potentially sell native apps to the public via App Stores.

Website owners have faced a challenge in this regard because the creation of an app is technically challenging and historically has required a website owner to either code new apps themselves for one or more mobile application platforms or hire a software developer to code such apps. As used herein an app refers to a mobile application that is executed by a mobile computing device. Apps typically vary as a function of which underlying mobile computing device platform they execute on. For example the same functionality for an app would be coded differently for execution on an iOS platform e.g. an Apple iPhone iPad iTouch etc. than on an Android platform e.g. an Android compatible smart phone . The term native app or equivalently native application native mobile app or native mobile application is used herein to refer to a mobile application program that has been designed and configured for use on a particular mobile computing device platform. The term native app does not encompass a general browser program on a mobile computing device that is configured to access websites including mobile versions of websites via a network such as the Internet.

As a solution to this problem the inventor discloses techniques by which a website can be automatically converted into a native app that can be loaded onto a mobile computing device for execution thereby. Example embodiments for methods apparatuses systems and computer program products that perform these website to native app conversion techniques are described below.

There are several problems and technical challenges that example embodiments disclosed herein solve. For example app development typically requires custom coding for each app by a technical person with advanced programming skills and who has a solid working knowledge of Java Android SDK Apple Xcode and Objective C or Swift can develop an Android and or iOS app. With example embodiments of the invention however anyone can convert any static website and or dynamic website built using HTML CSS or other web framework or tools into a native app and host it in either or both Android and Apple app stores or a private app store such that might be available within a company for free or paid download.

With conventional methods in order to build a native iOS app a developer would need access to an Apple Mac system and development tools along with a yearly subscription to Apple s iOS developer program. With example embodiments of the invention however a person is able to create a native iOS app without acquiring or having access to a Mac system and other iOS development tools.

Moreover after developing a native app in the conventional manner developers have to spend an additional time testing their app in different devices and various form factors for usability. By contrast with aspects of example embodiments of the invention operating system and form factor validation can be pre built into a native app shell data structure. The shell data structure detailed below is built and tested on various devices OS versions and form factors. Additionally it can overcome the form factor limitation if the HTML files are designed to be adaptive or responsive.

Further still in situations where the content at issue is static and or where a mirror website is used as a backup some example embodiments of the native app described herein will still operate if the original website goes down or is not accessible e.g. if the mobile computing device lacks a network connection when using the native app . Currently there are many website applications including critical web applications in use by field operators such as emergency responders mobile sales personnel which cannot be accessed without Internet connectivity via cellular or Wi Fi signal. Many of these website applications can be converted into native apps using example embodiments described herein for a fraction of the time and expenses related to custom designing and coding app versions of those applications using an app programmer or team of app programmers .

As mentioned the website to native app conversion techniques described herein allow anyone to convert any static or dynamic website into a native app that works on any of a number of mobile computing device platforms such as Android and iOS devices.

According to an example embodiment the inventors disclose a method comprising a processor automatically converting a website into a native app wherein the automatically converting step comprises 1 the processor generating a manifest data structure for the website to be converted 2 the processor accessing a native app shell data structure in a memory and 3 the processor compiling the native app from the native app shell data structure and the manifest data structure. The native app shell data structure can be configured to house the underlying logic for running the native app presenting website content via the native app navigating among the website content via the native app. The native app shell data structure may include code that configures the native app to operate according to a relinking model or an intercepting model. Furthermore in a relinking model the manifest data structure may take the form of a file that lists all assets of a website that are locally hosted by the native app. However in an intercepting model the manifest data structure may initially take the form of merely a specification of the website to be converted e.g. a specification of the website s URL . Then during later use of the app such a manifest could be updated to list any website assets that are intercepted and locally cached by the native app. Examples of such designs are discussed below.

Further still the native app shell data structure may be populated with features that are not available on the website to be converted. For example the native app shell data structure may be configured to provide the native app with functionality that allows it to provide features such as push notifications content searches security multi lingual support GPS based locator services camera capabilities and others.

These and other features and advantages of various embodiments of the invention will be described in greater detail below with reference to the accompanying drawings.

The website can be any website accessible over a network and it need not be a website that is specially configured to work with any specific type of app or mobile computing device operating system platform. For example the website can be built using HTML CSS Style Sheets JavaScript customer plug ins including third party script libraries such as jQuery jQuery Mobile or Angular or other web programming languages. The website comprises a collection of content components e.g web pages or portions thereof that can take the form of HTML files as well as a collection of links to the various content components. The content components can be static content components or dynamic content components. The content components of the website and the links of the website can be referred to as the assets of the website.

The input can take any of a number of forms. For example the input can simply be an identification of the website to be converted such as a specification of the uniform resource locator URL for the website. In an example embodiment the converter computer system can be configured to provide a series of graphical user interfaces GUIs to a user computer for display thereon where these GUIs guide the user through the process of converting a website into a native app. One of these GUIs may include a data entry field that allows a user to enter the URL for the website to be converted into the native app . The processor upon execution of the conversion program instructions can then access this specified website crawl it and extract the information needed to generate the native app as described in greater detail below. As another example the input can be a copy of the website itself. In an example embodiment a user may compress the website into a single file e.g. a zip file and send the compressed file to the converter computer system where it is uncompressed for the converter computer system to gain access to the website . In another example embodiment the converter computer system may have an application programming interface API for interfacing with an external computer system so that the external computer system can deliver a copy of the website to the converter computer system . The external computer system would have a capability to integrate this API into its own system so that users of the external computer system have easy access to the converter . In this regard third party website building publishing tools services such as Wix Squarespace and or Weebly would have a capability to provide their users with access to the converter via an API so that such users can not only build their own websites but also automatically convert those websites into native apps as described herein. Further still the input may include metadata for the native app that is to be generated such as an app icon to be displayed for the native app on a screen of a mobile computing device a name for the native app and the like.

The native app can take the form of a plurality of data structures and instructions that are executable by a processor of a mobile computing device to present the website to a user of the mobile computing device via invocation of the native app . The native app will be configured for execution by a specific mobile computing device operating system such as Android iOS BlackBerry or Windows. The native app can be stored on a non transitory computer readable storage medium such as computer memory. For example a copy of the native app can be stored in a memory of an app store or the like and be made available for download into the memory of a mobile computing device for execution thereby. shows an example mobile computing device that is configured to execute native app . The mobile computing device includes a processor and associated memory where the processor and memory are configured to cooperate to execute the native app . Furthermore the mobile computing device may also include one or more I O devices e.g. a touchscreen user interface for graphically displaying output data and receiving input data from a user a GPS receiver component a camera capable of capturing video an encryption decryption circuit for encrypting or decrypting data wireless I O for sending and receiving data a microphone for capturing sound and a speaker for converting sound data into audible sound. The wireless I O may include capabilities for sending and receiving messages over a network such as a cellular data or WiFi network as well as making and taking telephone calls. The wireless I O may also be capable of communicating with nearby objects via near field communication NFC communicating with nearby objects via RF and or communicating with nearby objects via Bluetooth. As explained below the native app may be configured to interface with these components of a mobile computing device in order to provide users with increased functionality relative to the capabilities of the source website .

Returning to the processor can take the form of any hardware data processing component that is capable of performing the website to native app conversion operations as described herein. For example the processor may take the form of a microprocessor CPU or the like that is capable of executing the conversion program instructions . In operation such a processor can fetch one or more conversion program instructions from memory over a bus or other interconnect for execution thereby. It should be understood that the processor may take the form of multiple processors that cooperate with each other to implement the website to native app conversion operations as described herein.

The memory can take the form of any memory device capable of storing data and interacting with the processor as described herein. It should be understood that the memory may take the form of multiple memory devices. Together the processor and memory as described herein can be characterized as a circuit specially configured to perform website to native app conversion operations as described herein.

The converter computer system may also include by way of example additional components such as non volatile data storage e.g. a hard disk etc. connected to a bus one or more network interfaces connected to the bus through which the computer system can receive input and or website content from remote sources via a network a display e.g. a monitor and input s e.g. a keyboard mouse etc. for interacting with users.

Example embodiments of the conversion program instructions and data structures are described below. Instructions are configured for execution by processor and can be stored on a non transitory computer readable storage medium such as memory . Examples of different embodiments for the conversion program instructions and data structures are described below in connection with a locally hosted web site embodiment and a link interception embodiment for the native app . With the locally hosted website embodiment for the native app the native app is built so that some or all of the website s content components are locally hosted by the native app from inception in which case the native app can function effectively even if the mobile computing device on which it executes lacks a network connection. The link hosting embodiment can be referred to as employing a crawling relinking method to build the native app. With the link interception embodiment for the native app the native app is built so that it accesses the website over a network connection available to the mobile computing device when the native app is launched. Website content then gets served from the remote website while also being cached by the native app. Subsequent usage of the native app to access the same web site content may result in the content being served from the local cache rather than the remote website.

The system next collates the metadata from the previous steps and passes it to the app builder. Once the builder and app engine completes the build the apps are emailed to the user with instructions on how to submit to Apple and Google see .

The web foundry can accept website content in any one of a number of formats as discussed above and as described in more detail below. For example shows an example where any of five techniques can be used to accept website content to build a native app. Each of the input methods is detailed below.

A crawler on a server or the app is designed to download a given website content including HTML CSS JavaScript images and other assets that makes up the website parse that content and store the content in a local database in the server or within the app as a set of content component files. The system then processes each file to relink the URLs inside it to point to the local file so the content loads from within the device instead of the external web server. This allows the website content to be viewed without a network connection and improve the app s performance. An example of a tool that can be used as the crawler is NCrawler available from ncrawler.codeplex.com.

The illustration in depicts an example environment for the Crawler based app conversion example embodiment.

Website is created by a professional by designing and uploading the files to a web farm. This can be done by the user creating the files in a desktop editor then transferring the files to a server web farm via file transfer or by using a website building publishing tool service Examples Wix Squarespace and Weebly .

The web foundry in an example embodiment builds a platform specific native shell app see with no pre built content of the website beyond a capability to access and present a specified website for display. The native app when invoked loads the website to display and intercepts the network calls to cache responses. If network connectivity is not available and if the previously cached objects are present the cached responses are used to fulfill the requests to display the website.

An example embodiment for the Interception based website to native app conversion comprises a user app owner entering website address URL along with metadata about the app used to build the native application such as its icon name etc. that they want to convert into an native application.

This information is validated and then given to a processor or packager for each mobile platform desired. This process then uses the information to build a native application for the given website URL . Once finished the application is sent back to the website owner or submitted to the appropriate store e.g. Apple App Store or Google Play or Private App Store for distribution.

A special custom platform specific native application is used to browse a website intercepting the network calls and caching the responses similar to the Interception method detailed above and below. The cached responses are then uploaded to the web foundry along with app metadata including icons description images and other information used to build the app. Both these information sets are packaged and sent to app foundry to build the platform specific native application. Updates to that application could also be done using the same special application for initial creation. These processes would may involve uploading the cached responses to a server for the building of the application.

An example embodiment for the AppPackage based website to native app conversion comprises of using a special native application to browse a website and then using the cache from browsing to create the final application.

A special native application is used to browse a target website . In a fashion similar to the Interception method the requests for resources needed to display the website are recorded and saved into a cache. Once the website has been browsed enough to have a sufficient portion of the needed assets for display of the website the application can upload its cache to a server to have the final application built.

This server receives the cached files from the special application and combines this with other necessary app metadata used to compile a native application. The final native application is then built with the assets needed for displaying the target website.

The final native application when launched will display the website using the assets captured by the original special application. It could also make requests directly to the website and even update the cache similar to the Interception method.

Another way to update the content is to use the special application to browse update the cache for the website and upload the new content to the server to build a new updated version of the final application.

The user zips the content of the website and uploads the zipped content to the web foundry along with app metadata including icon name version and other information used to build the platform specific native app with content from the zip file. The native app can be designed and built to exhibit behavior the same as or similar to the native app built using the Crawler or Interception or AppPackage models.

An example embodiment for the Zip based website to native app conversion comprises a user uploading the contents of the website in a compressed Zip format to the web foundry . The compressed file can contain app metadata including icon name version and other information used to build the platform specific native app

The web foundry decompresses the files and splits the website content from app metadata and sends it to the app foundry to build the platform specific native app for displaying the target website .

The native application when launched will display the website using the assets captured by the original zip file provided by the user. It could also make requests directly to the website and even update the cache similar to the Interception method.

The user makes a request from their website to an API application programming interface service passing in the URL of the website and along with app metadata including icon name version and other information used to build the platform specific native app along with security keys to uniquely identify the source. The web foundry then parses the information and calls the app foundry to build the platform specific native app. When the process is complete the app foundry can email the app or link to the app to the user for distribution.

An example embodiment for the API based website to native app conversion comprises a user calling a set of API calls over the network from their website passing in the address for website assets and other information used to build the platform specific native app. To ensure security each caller may pass in a pre assigned security key to uniquely identify their website and ownership.

The web foundry verifies the data along with security key to ensure identity matches and sends the info to app foundry to build the platform specific native app for displaying the target website .

The native app can be designed and built to exhibit behavior the same as or similar to the native app built using the Crawler or Interception or AppPackage models.

With reference to the App Foundry may comprise two parts the App Builder and the App Engine . The App Engine its produced manifest see and output assets see and Shell app code see can be designed to vary slightly between the Crawling Relinking and Interception models and of course the resulting platform specific native app file would differ because of the differing code used to compile. The App Builder would likely not need to change as a function of the target platform if desired by a practitioner.

In an example embodiment the App Builder its subcomponents the Shell App code and the App Info would vary depending on the platform e.g. Android iOS which would also cause the produced platform specific native app file to vary as well. Other portions of the foundry would not likely be required to change because of the platform if desired by a practitioner.

The App Foundry receives platform specific and app specific data App Info the input assets and associated file mapping the latter two are sent to the App Engine . The produced manifest file and output assets along with the App Info are then sent to one or more platform specific App Builders which use the appropriate shell code for the platform and model Relinking or Interception to produce the final platform specific native app file s .

The input assets and file mapping may be empty or not given to the foundry . In this case according to an example embodiment such as in an interception model embodiment the only source of input can be the App Info as well as a specification of the website e.g. the URL for website . With no input for the App Engine it is effectively skipped and the App Builder would only be given the App Info and website URL which would serve as the manifest data structure and use the appropriate Shell code for the interception model to produce the final platform specific native app file s .

The App Info given to the App Foundry can include information used to build compile the application such as the name version icon unique identifier. An example of such app info is provided in . In this example the app info is in an XML format but it should be understood that other formats for storing and transferring the information could be used such as JSON.

The App Builder component is responsible for the actual compilation of the application and would be specific to the platform being compiled e.g. Android iOS . The builder possibly receives the processed output assets and manifest of the target website . It uses platform specific and app specific information App Info such as the app s name icon version and a platform specific identifier e.g. iOS Bundle Identifier . This information could come from the same source as the input assets or from another location likely another website s form input .

This information is then used to setup a project such that it can be compiled with the appropriate Shell App code . In an example embodiment this setup process can vary for each platform such as the location where the packaged files are placed as well as the structure used to contain the metadata for the application such as the name version and unique identifier . For example Android packaged resources would typically be placed in an assets folder and the metadata in the AndroidManifest.xml file. In contrast iOS packaged resources are typically in the top level folder of the project and referenced in the project file while the metadata is stored in an Info.plist file. While the AndroidManifest.xml and Info.plist files are typically in XML the element and attribute names are vastly different.

The compilation step would typically use the standard compiler tools for the platform such as xcodebuild for iOS or ant and related Java compilers for Android. While these compilers have similarities they typically cannot take code written in a different language or for another platform thus the compiler used is typically dependent on the platform being built.

The compilation process typically produces a single platform app file such as a .apk for Android or .ipa for iOS . This file serves as the converted website application. This could then be used to install directly onto a device or publish to an app store e.g. Google Play Apple App Store .

As discussed above the app engine according to example embodiments may be designed to employ either of two models a relinking model and an intercepting model.

Both variants of the engine may receive input asset files as well as a mapping of the addresses where the input asset files are retrieved and output a manifest mapping a filename or path with the original address as well as output asset files which are either very similar to the input asset files or in the case of the intercepting engine exactly the same. However in some embodiments of the intercepting model the engine may not need to start with any input asset file as the app according to the intercepting model may merely start with the website URL as discussed below.

Other information is likely to be present in the manifest file such as the starting address page to use when the app launches the time the files were processed and other metadata about the content of each file etc. In the event a practitioner omits this extra information from the manifest it would still likely be desirable to package such additional information with the application in some manner for efficient operation.

A final Address to File mapping is created from merging and removing mappings . Then each file from the input assets is processed . Depending on the type of file a different parser is used for example HTML CSS and Javascript. Other parsers could be used as well and would be necessary if another file type needs to be processed. Using the parser links are found and each one is checked to see if it exists in the mapping . If the link does exist it is then adjusted relinked to the local file instead of the website. Once all of the links for a file have been adjusted it is saved to the output asset files . Not all files need to be processed or parsed such as images since they do not contain any links to other resources these files would be left unaltered and saved in the output asset files .

The address to file mapping is saved to make the final manifest file containing the mapping used and like metadata on each file such as HTTP headers or metadata on the website or state of the application. This process could be performed before during or after the processing of files .

If the engine is updating existing assets then the current manifest and current files are available as well as possibly a list of removed assets . Before making the final Address to File mapping merging of the input mapping and the mapping present in the current manifest would take place. This merging would include adding entries in the input mapping that are not in the current manifest and updating the file path and or metadata for entries present in both and possibly deleting the old version of the file . If a list of removed resources is provided these listed resources are then removed from the mapping the associated file may also be deleted at this point or in the future . After these steps the final address to file mapping is formed. Also while updating the current asset files are also processed with the input assets in order to relink any new updated or deleted assets.

If desired by a practitioner the native app can be designed to check for updates to website and then update itself accordingly. With such embodiments the app content can be updated according to either of two different methods with the Relinking model as shown by app internal update and app external update .

Both update methods perform a check to see if any new or updated website content is available. These checks can be triggered by in several ways such as the application launching periodically based on time or externally by an API or webservice call typically from the website owner .

If checking reveals that an update is available the app user can be asked if they wish to update as the process takes time and network resources a user may or may not want to perform the update . The update process ensures the application has the latest content for the website available to it.

In this option as shown by the application processes each entry in the manifest and makes a request to the original server for the resource e.g. using the HTTP HEAD method and determines if received response is different new from the one currently stored on the device. Each one determined to be different or new is added to a list . Once all the entries in the manifest have been processed and there is at least one entry in the list i.e. at least one resource has changed or updated and update is determined to be available.

The actual update process begins and a full request e.g. HTTP GET for each resource in the list is made and the full response is then retrieved and placed into the New Input assets and its address URL and metadata are added to a mapping . The Relinking App Engine see is then used to update the current assets and manifest . Some resources may have been removed from the server e.g. HTTP 404 status code in which case the associated file is removed by adding it to a list of removed mappings . Each of the resources are processed and then saved to the device completing the update process.

In this scenario the app checks if an update is available from this server . If updates are available it may prompt the user if they wish to update as the process may take time to complete. Checking for updates would involve storing a unique sequence e.g. timestamp or hash of when all of the assets were last updated or initially created and comparing it to what the server has. When an update happens the server is contacted again for a list of files that each have a unique sequence e.g. timestamp or hash . This list is compared with the application s manifest . For each entry there are 3 possibilities 

In this option updates would only occur when the server not necessarily the website host is triggered to perform the relinking process on the website. Possible triggers include periodic e.g. hourly or daily or a webservice or API call from the website when it changes or wants to publish such changes . This is in contrast to option 1 where the trigger is from the user of the application.

In the interception model the App Engine is much simpler. shows an example embodiment of an intercepting app engine . The input assets are typically unchanged and passed directly as the output assets . Only the manifest file would need to be generated from the mapping of the input files . The process would involve serializing the mapping into the desired format and possibly adding any additional metadata.

The built application when launched will load the specified website URL entered by the owner. While the application is loading any web page image script or other asset the request is intercepted allowing the application to examine the request and give its own response instead of going to a server.

When a request is intercepted the application determines if a cache entry exists in the manifest . If a requested entry exists in the cache and is considered fresh according to predetermined criteria e.g. by the HTTP Caching standards the cached file from the assets is served instead of making a network request. However if a stale not fresh response is found and no network connectivity is available the cached file could still be used.

If an entry does not exist for the request or it is stale but a connection exists then the website asset is fetched by normal means and the response and its content are added to the cache by updating the manifest and assets so that it can be used for this and later requests. Not all responses need be cached nor should they such as HTTP POST submissions.

The need to update the application is minimal and really occurs automatically as a user browses the website. However updating a cached response is possible by having the application forcibly make a network request for it and replacing or updating it with the network response in the manifest and assets . This could be done for example on all cached responses or on responses that are considered stale. 

The native app shell data structure can take the form of shell application code . The shell code can include the basic logic for displaying the native app on the mobile computing device and interfacing with the mobile computing device s native controls and provides a simple user interface for browsing the website content from within the app and navigating that content from within the app. In an example embodiment the shell code can also contain the logic for performing the App Content Update see of the App Engine . The shell code can be configured to use the manifest and assets to display the converted website and behave appropriately.

In the relinking model the Output Assets are modified versions of the Input Assets and in many cases the differences in the links are subtle such as removing leading characters to make them relative instead of absolute. The modified files are then loaded from local device storage to be displayed in the platform s native control typically through use of the file protocol. Changing absolute links is done in the link remapping to prevent the files from trying to access the root directory of the device which an application normally does not have access to.

The shell code for the interception model contains the logic outlined in the interception App Content Update a manifest and optionally prepackaged assets . The manifest data structure in such an embodiment may simply be a specification of the URL for the website . However as the intercepting native app is later used this manifest may grow to list the locally cached website assets. Also the shell code for the interception model may initially not have an input assets although these input assets can be built during app use as the app locally caches the website contents that are accessed.

Unlike the caching mechanisms of a typical browser the shell app code for the intercepting model is designed to be aggressive in how it caches responses and override or ignore any pre existing cache control configuration data that may be included within the website assets. For example the cache logic of the shell code can be configured to cache HTTP responses even if those responses have headers stating they should not be cached. In these scenarios the cached response can be considered stale within the app and will always be fetched from server if connectivity exists. However if connectivity does not exist the application will serve these stale responses from the local cache thereby providing the user with content even if connectivity is lost.

A conventional browser caching mechanism typically cannot be pre populated with cached responses. Browsers will also typically not display a website page from cache if connectivity is lost especially if the response is marked as not cacheable. Many websites will mark their main pages as not cacheable so that any updates are always fetched. The caching model of the intercepting app however allow a user to still browse the website as they last saw it without any connectivity. Also if assets are pre packaged into the application they can browse that version without having any connectivity the first time the application is opened.

This section outlines some of the differences in the Shell App code between Android and iOS. Other differences would be present for other platforms such as Windows and Blackberry.

Determining connectivity for Android devices is performed much differently than for iOS devices. Android has a component called a Broadcast Receiver that can be notified when changes to network connectivity occur including when it is lost switching to or from WiFi etc. Such a receiver is set up to monitor changes and keep a flag boolean updated when an internet connection is available or not.

For iOS determining connectivity to the internet is not as straightforward. Instead network requests are always attempted and fall back to code handling non connectivity if a timeout or other error indicating a loss of connection.

In the interception model the actual mechanism of intercepting requests differs greatly as between an Android interception model and an iOS interception model. For Android the native WebView control used to display the content allows for application code to give responses to resource requests of the control. Returning a null value will have the control perform the request normally over the network.

Interception on iOS involves the application registering a URL Protocol handler. This handler does not receive requests for just the native control display the website but all network requests done by other parts of the application . Because of this requesting the resource from the server to update the cache requires flagging said request so that it is not intercepted over and over. The application code for this handler is also not typically on the same thread of execution as the rest of the application which causes concurrency issues with accessing and changing the same memory.

Additional features that can be included in the Website to Native App Conversion Process flow include integrating one or more marketplace features into the native app. Examples of options in this regard are described below. When such feature integrations are desired code for implementing such additional features can be added to the shell app code so that the features can be executed by native app .

A website may or may not have security layer added to it. A typical security layer is a authentication security scheme. When the website is converted to an app the current architecture can support the login authentication built into the website dynamically. By adding extra layer of security on top of the website s authentication security scheme it adds an extra layer of protection to protect the data the app has stored in the local device.

An example embodiment for this can include a two step approach to adding the extra layer of protection on top of the already existing authentication.

Example An insurance website that was converted to an app collects user data from a form. During app usage connectivity is lost while data has been entered into the form via the app in which case such data can be kept in local storage on the device . And at a later time when device re establishes connectivity the same data can be posted back to the server. During this transition time absent additional security there is a risk that if the device is lost or stolen a person who finds or steals the device can read the data. By adding an extra layer of app level security the data that is stored in the device will be in encrypted format and will be deemed unreadable. At the same time when connection is reestablished the app will post the data to the server in an unencrypted format but over a SSL layer.

Another example can be a case where a web based chat application with no security cannot be used by a hospital staff due to HIPAA rules. The same web based chat converted into an app and with the added app level security instantly becomes a HIPAA compliant app.

During the app build process an app owner can choose to add extra security by configuring few additional steps see the example GUIs described above . The UI process is extremely easy and intuitive that allows any non technical person to add the industry standard security their app.

By building an app that is deemed private Example a company wanting to convert their Human Resource website to track employee benefits into a native app will not serve any value if the app is hosted on the public app store but it would be served well if it is built as a private app and hosted in a company managed internal infrastructure.

An example embodiment for this can include a one click process for the app owner to choose to build configure and send their completed app to a private app store and avoid the 14 days wait time to get their app published to an app store. The integrated process of this example embodiment takes minutes to build a private app with all features of the website and be ready to install on a device.

Push Notifications are great tools for communication but are not generally supported by websites. shows an example process flow that can be used for the native apps to support a push notification service.

An example embodiment for this can include a one click process the app owner can choose to configure and build their app with Push notification enabled in it. The integrated process of this example embodiment takes minutes to build the app with Push Notification and avoid all the additional steps. The Push feature can be extended to support Group Push Tagging based push one on one push to target a specific user as well as users in certain geo location.

An app is by default designed to present information in a specific language. To serve content in different languages the app developer would conventionally have to include a language translation feature and each language the app supports can add complexity and time. However this can be expedited by example embodiments where a multi lingual feature can be easily integrated into app .

An example embodiment for this can include a simple way for the app owner to build their app and choose to include additional languages using the marketplace add on tools that example embodiments offer. The app shell can further make the user experience much easier by dynamically detecting which part of the world the device is located in and loading the local language translation service on the fly.

An app that serves multiple pages of content can use the marketplace tool or plugin to enhance itself to offer an integrated search of all the content using a simple user interface.

An example embodiment for this can include a powerful feature the app owner can choose to add to their app and make their app content searchable. Both in the crawler and interceptor model of the design as the content gets gathered into the app and stored locally in the device when user searches for one or more words the app can scan through the locally stored pages and data and provide the results if designed to include a search feature.

A website that serves in an interactive nature which collects user information in a form type of page when converted to an app can work in offline mode without data connection and still deliver 100 of the functionality.

An example embodiment for this can include a useful feature the app owner can choose to add to their app and make their app work in a disconnected or offline mode. Both in the crawler and interceptor model of the design any page that collects data can detect if the device has connectivity or not and when there is no connectivity the app can store the data in the local device storage. When the device regains connectivity it can post the data back to the server and complete the transaction without any data or productivity loss.

An example embodiment for the integration of device specific features into the native app can include a capability for an app owner can choose to integrate device specific features such as Camera Microphone GPS etc. into the native app . As an example a Tailor business can use their app to integrate Camera feature and their customers can use the app to take photos of their suit or a gown and send it to the tailor all without leaving their app. The conventional approach would require the user to use multiple applications including Camera and Email separately to complete a transaction. However with the integrated device feature the end user can complete the same task in a much shorter time frame without leaving the app .

Other peripheral components of a mobile computing device that may be accessed through the native app can include a GPS receiver resident on the mobile computing device a microphone resident on the mobile computing device a Bluetooth component resident on the mobile computing device a near field communication NFC component resident on the mobile computing device a biometric sensor resident on the mobile computing device an accelerometer resident on the mobile computing device a compass resident on the mobile computing device an altimeter resident on the mobile computing device and an encryption or decryption circuit resident on the mobile computing device.

The existing Web Foundry and App Foundry can be extended to support other platforms including BlackBerry or Windows by a practitioner adding platform specific libraries.

The embodiments disclosed herein were chosen and described in order to best explain the principles of the invention and its practical application to thereby enable others skilled in the art to best utilize the invention in various embodiments and with various modifications as are suited to the particular use contemplated. As various modifications could be made in the constructions and methods herein described and illustrated without departing from the scope of the invention it is intended that all matter contained in the foregoing description or shown in the accompanying drawings shall be interpreted as illustrative rather than limiting.

