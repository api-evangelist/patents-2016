---

title: Selection of ranked configurations
abstract: Methods, systems, and apparatus, including computer programs encoded on a computer storage medium, for selection of ranked configurations. In one aspect, a method includes providing a plurality of class definitions for selection, each class definition modeling a respective data or functional component of a cloud-based environment using a group of configurable class parameters, each class definition supporting instantiation and inheritance of the class definition in a configuration specification for a cloud-based deployment; deriving respective performance metrics associated with each of the plurality of class definitions based on aggregated performance of multiple cloud-based deployments, wherein the multiple cloud-based deployments had been carried out according to respective configuration specifications that require instantiation of the class definition or a new class definition derived from the class definition; and utilizing the respective performance metrics associated with each of the plurality of class definitions in ranking the plurality of class definitions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09557978&OS=09557978&RS=09557978
owner: Google Inc.
number: 09557978
owner_city: Mountain View
owner_country: US
publication_date: 20160222
---
This application is a continuation application of and claims priority to U.S. patent application Ser. No. 13 421 124 titled Selection of Ranked Configurations filed on Mar. 15 2012 which application claims the benefit under 35 U.S.C. 119 e of U.S. Provisional Application No. 61 453 478 filed Mar. 16 2011. The disclosure of each of the foregoing applications is incorporated herein by reference.

Cloud computing is a computing model developed to enable convenient on demand network access to a shared pool of configurable computing resources e.g. networks servers storage applications and services that can be provisioned and released quickly dynamically and with minimal manual management efforts and human interactions with the service providers.

A few common cloud based service models include Software e.g. commercially available software applications as a Service SaaS Platform e.g. hosting environment of software applications such as virtual machines or application frameworks as a Service PaaS and Infrastructure e.g. compute power storage database networking services etc. as a Service IaaS . Before a cloud based service is made available to a cloud service customer various aspects of the service are configured according to a configuration specification such that when the service is deployed it meets the customer s needs and usage demand.

This specification describes technologies relating to use and management of cloud computing environments.

In general another innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of providing a plurality of class definitions for selection each class definition modeling a respective data or functional component of a cloud based environment using a group of configurable class parameters each class definition supporting instantiation and inheritance of the class definition in a configuration specification for a cloud based deployment deriving respective performance metrics associated with each of the plurality of class definitions based on aggregated performance of multiple cloud based deployments wherein the multiple cloud based deployments had been carried out according to respective configuration specifications that require instantiation of the class definition or a new class definition derived from the class definition and utilizing the respective performance metrics associated with each of the plurality of class definitions in ranking the plurality of class definitions.

These and other embodiments can each optionally include one or more of the following additional features. Categorizing the plurality of class definitions based on the respective data or functional components of the cloud based environment modeled by the plurality of class definitions and ranking the plurality of class definitions within the class definitions respective categories. Providing the plurality of class definitions for selection further comprises providing the respective performance metrics with each of the plurality of class definitions for user review in a selection user interface. For each of the plurality of class definitions identifying a plurality of cloud based deployments that had been carried out according to respective configuration specifications that required instantiation of the class definition or at least one new class definition derived from the class definition monitoring respective performances of the plurality of cloud based deployments and associating the respective performances of the plurality of deployments with the class definition. Deriving respective performance metrics associated with each of the plurality of class definitions based on aggregated performance of multiple cloud based deployments further comprises for each of the plurality of class definitions identifying one or more data or functional components in the plurality of cloud based deployments that were configured according to the class definition or a new class definition derived from the class definition identifying one or more performance metrics associated with the identified one or more data or functional components and deriving the respective performance metrics associated with the class definition by aggregating the identified one or more performance metrics.

These and other embodiments can each optionally include one or more of the following additional features. The performance metrics include one or more measures of latency reliability scalability availability or security. For each of the plurality of class definitions tracking a respective count of cloud based deployments that have been configured at least in part according to the class definition and utilizing the respective counts associated with the plurality of class definitions in the ranking of the plurality of class definitions. For each of the plurality of class definitions tracking a respective count of problems encountered in cloud based deployments that have been configured at least in part according to the class definition and tracking a number of required changes to resolve the problems encountered in the cloud based deployments that have been configured at least in part according to the class definition and utilizing the respective counts of the problems and the respective numbers of required changes associated with the plurality of class definitions in the ranking of the plurality of class definitions.

These and other embodiments can each optionally include one or more of the following additional features. The respective numbers of required changes associated with the plurality of class definitions are used to calculate respective weights given to the respective performance metrics associated with the plurality of class definitions in ranking the plurality of class definitions. Receiving a respective definition submission from each of a plurality of definition suppliers wherein the respective definition submission includes one or more class definitions written in a specification language and each class definition models a data or functional component of a cloud based deployment using a group of configurable class parameters and is extendable to create at least one new class definition by a modification to one or more of the group of configurable class parameters or an addition of one or more new class parameters providing a user interface that presents the class definitions received from the plurality of definition suppliers for review and selection by a plurality of definition users. Receiving a plurality of distinct configuration specifications written in the specification language the plurality of distinct configuration specifications each for configuring a distinct cloud based deployment and including a distinct class definition that extends from a same one of the class definitions received from the plurality of definition suppliers and configuring each of the distinct cloud based deployments based at least on the same one of the received class definitions and the distinct class definition that extends therefrom in the distinct configuration specification of the distinct cloud based deployment.

These and other embodiments can each optionally include one or more of the following additional features. For each of the received class definitions monitoring usage of the class definition in a plurality of configuration specifications that have been used to configure a plurality of cloud based deployments and recording for each use of the class definition in the plurality of configuration specifications a credit to a definition supplier of the class definition and a charge to a definition user associated with the use. The usage of the class definition includes an instantiation of the class definition in a respective configuration specification that has been used to carry out a respective cloud based deployment. The usage of the class definition includes an extension of the class definition to create a new class definition that is instantiated in a respective configuration specification used to carry out a respective cloud based deployment. Receiving a software submission from a software supplier the software submission including a software application to be deployed in a cloud based environment and a plurality of distinct configuration specifications each for deploying the software application in the cloud based environment in a distinct manner and providing the plurality of distinct configuration specifications for review and selection by a software user. Receiving selection of one of the plurality of distinct configuration specification by the software user deploying the software application in the cloud based environment according to the selected distinct configuration specification and recording a charge to the software user and a credit to the software supplier based on a respective price associated the selected distinct configuration specification. Receiving from a user input selecting a first class definition that models a first data or functional component of the cloud based environment identifying one or more collections of class definitions wherein each collection of class definitions includes the first class definition and at least one additional class definition that models a respective data or functional component other than the first data or functional component and providing to the user the one or more collections of class definitions for selection.

These and other embodiments can each optionally include one or more of the following additional features. For each of the one or more collections of class definitions identifying one or more data or functional components in a plurality of cloud based deployments that were configured according to the class definition or a new class definition derived from the class definition identifying one or more performance metrics associated with the identified one or more data or functional components and deriving the respective performance metrics associated with the collection of class definitions by aggregating the identified one or more performance metrics. Receiving a selection of a collection of class definitions identifying a configuration specification associated with the collection of class definitions and configuring a cloud based deployment based on the configuration specification.

In general another innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of modifying one or more base classes whose class definition is used in multiple of the plurality of cloud based deployments wherein the base classes model a respective data or functional component of a cloud based environment using a group of configurable class parameters and the base classes support instantiation and inheritance of the class definition identifying a plurality of cloud based deployments each having been carried out according to a respective configuration specification the respective configuration specification written in a specification language and the respective configuration specification including the modified base classes or classes that inherit the modified base classes and reconfiguring for each cloud based deployment the cloud based deployment based on the one or more modified base classes.

These and other embodiments can each optionally include one or more of the following additional features. The data or functional component modeled by each class is one of a virtual device supporting a cloud based environment a service utilized in the cloud based environment a software role performed by an installed application in the cloud based environment a data package holding data to be used during deployment or operation of the cloud based environment or a combination of one or more thereof. The specification language supports dependency between class definitions and a definition dependency between a first class and a second class represents a deployment dependency between respective components modeled by the first and the second class. The definition dependency between the first class and the second class is expressed by a class parameter of the first class where the class parameter of the first class refers to an instance of the second class. The specification language supports connectivity between class definitions and a value assignment linking an instance of a second class to a class parameter of a first class represents a connectivity between respective components modeled by the first class and the second class. The specification language is object oriented.

Other embodiments of this aspect include corresponding computer systems apparatus and computer programs recorded on one or more computer storage devices each configured to perform the actions of the methods. A system of one or more computers can be so configured by virtue of software firmware hardware or a combination of them installed on the system that in operation cause the system to perform the actions. One or more computer programs can be so configured by virtue having instructions that when executed by data processing apparatus cause the apparatus to perform the actions.

Particular embodiments of the subject matter described in this specification can be implemented so as to realize one or more of the following advantages.

A high level object oriented specification language allows configurable components of a cloud based deployment to be modeled by a class definition that includes a group of configurable class parameters. The object oriented specification language supports extension of an existing base class definition to create new class definitions and supports inheritance of class parameters from the existing base class definition by the new class definitions. An administrative user of a cloud based service can customized a cloud based deployment based on class definitions used in configuring one or more generic deployments such as by modifying class parameter values of the class definitions varying interrelationships between the classes and supplementing existing class parameters with new class parameters.

The object oriented specification language allows multiple layers of abstraction to be made on the different types of cloud service components that are configurable. For example the high level object oriented specification language not only supports class definitions that model hardware and virtual resources but also software roles and service roles served by software applications and services in a cloud based deployment. In addition the object oriented specification language provides syntax for specifying dependency and connectivity between classes. Cloud components that involve multiple sub components and complex structures can be modeled by class definitions that refer to multiple types of base classes and specify respective interrelationships between the base classes.

A configuration specification can rely on existing class definitions to configure some aspects of a cloud deployment at a high level of abstraction while customizing other aspects at a more detailed level using newly derived class definitions. An administrative user of a cloud based service is able to control the level of customization for a cloud based deployment by choosing an appropriate set of class definitions to include and instantiate in the configuration specification for the cloud based deployment.

In addition the object oriented specification language allows many class definitions that model common or special purpose cloud service components to be created and stored. These stored class definitions can be extended or reused as is in configuration specifications of future deployments by different cloud service customers. This reuse of class definitions in specification configurations can improve the speed and efficiency of the deployment process.

Because class definitions can be reused and shared among many cloud service customers the efforts for developing suitable configuration specifications for the same or similar purposes do not have to be duplicated by the cloud service customers. A marketplace for sharing reusable class definitions can be developed such that a cloud service customer can choose to purchase or license the use of existing class definitions developed and provided by other cloud service customers for a fee. In addition software applications can be provided with different types of configuration specifications i.e. as config wrapped software solutions that are suitable for different usage demands and organizational infrastructures of the cloud customers.

When a configuration specification of a cloud based deployment is written in the object oriented specification language the cloud service provider is able to parse the configuration specification to identify the class definitions that are involved in configuring each data or functional component of the cloud based deployment. Further when the deployment is carried out according to the configuration specification the cloud service provider is also able to identify the underlying software or virtual resources associated with each of the data or functional components of the deployment. Therefore the object oriented specification language enables the cloud service provider to monitor the performance of the data and functional components of the cloud based deployment and associate the performance with the class definitions that are used to configure each of the data and function components. Thus the cloud service provider can provide guidance to the cloud service customers on which parts of the configuration specification needs to be modified to improve the performance of the deployment.

In some implementations the cloud service provider can generate a block diagram for the cloud based deployment based on the configuration specification. The performance of the different components of the deployment can be visually represented on the block diagram. Various reconfiguration triggers specified in the configuration specification can also be represented in the block diagram. This visual representation allows an administrator of the cloud based deployment to adjust the configuration parameters of the deployment timely and appropriately.

The object oriented specification language allows class definitions to be reused in multiple configuration specifications and potentially by multiple cloud service customers. The cloud service provider can track the performances of multiple cloud based deployments that have been configured using configuration specifications involving reused class definitions. For each reused class definition the cloud service provider can evaluate the quality of the class definition based on the aggregated performance of the multiple deployments that have been configured using the class definition. In a marketplace for sharing reusable class definitions a ranking or quality scores of the class definitions based on the quality of the class definitions can be provided. This ranking or quality scores help cloud service customers to better select the class definitions to reuse in their own cloud based deployments. The ranking or quality scores may also help providers of reusable class definitions to improve their class definitions.

The details of one or more embodiments of the subject matter described in this specification are set forth in the accompanying drawings and the description below. Other features aspects and advantages of the subject matter will become apparent from the description the drawings and the claims.

In a cloud computing environment cloud service customers e.g. end users or enterprises obtain access to software platform and or infrastructure services through one or more networks e.g. the Internet . The cloud service customers are able to scale the service level e.g. in terms of service type quality and amount up and down as needed for example through configuration user interfaces provided by the cloud service providers and or through programmably established configuration specifications stored at the cloud service providers. Correspondingly a cloud service provider pools resources and serves its customers via a multi tenant model where physical and virtual resources are assigned and reassigned configured and reconfigured according to customer demands. The locations of the physical resources underlying the cloud infrastructure are not exposed to the cloud service customers and can change dynamically.

In one example the cloud service provider is conceptually structured in multiple layers. The lowest layer is the firmware and hardware layer on which other layers of the cloud service provider are built. The firmware and hardware layer includes generic contributing nodes e.g. data centers computers and storage devices geographically distributed across the Internet and provide the physical resources for implementing the upper layers of the cloud service provider .

Above the firmware and hardware layer is the software kernel layer . The software kernel layer includes the operating system and or virtual machine manager that host the cloud infrastructure services provided by the cloud service provider . The software kernel layer controls and communicates with the underlying firmware and hardware layer through one or more hardware firmware level application programming interfaces APIs . The hardware firmware level APIs can be provider specific and implemented to support Hypertext Transfer Protocol HTTP and HTTP Secure HTTPS based communications protocols. Examples of provider specific APIs include Amazon Web Services APIs Google App Engine APIs and Microsoft SQL Azure APIs.

The infrastructure services provided by the cloud service provider include virtualized resources such as virtual machines virtual storage e.g. virtual disks virtual network appliances e.g. firewalls and so on. The infrastructure servicers also include virtualized services such as database services networking services file system services web hosting services load balancing services MapReduce services message queue services map services e mail services and so on. Each of these infrastructure services can be employed by a cloud service customer and deployed in an infrastructure service layer above the software kernel layer .

The scale and various aspects e.g. data connectivity and dependency relationships within and between service components of an infrastructure service deployment are configurable by an administrator user of the cloud service customer. In one example the administrator user submits a configuration specification to the cloud service provider via a frontend interface of the cloud service provider . The cloud service provider translates the configuration specification into instructions e.g. API calls to the infrastructure service layer and the kernel layer according to the APIs of the involved infrastructure services and the APIs of the underlying software kernel layer . These instructions are executed to provision and configure the infrastructure services requested in the configuration specification of the deployment. For example a configuration specification can be translated into infrastructure and kernel level APIs calls that create re create move or delete components e.g. virtual machines and services and assign or change attributes e.g. memory and CPU allocations network settings disk sizes and volumes of the components.

In addition to the infrastructure services the example cloud service provider also provide platform services such as an environment e.g. Linux Solaris Microsoft Windows etc. for running virtual machines or a framework e.g. .NET Java Oracle Database etc. for developing and launching a particular type of software applications. The platform services are implemented in a platform service layer over the infrastructure service layer and can employ one or more infrastructure services configured in a particular manner. Configuration of platform services can be accomplished by program code written according to the APIs of the platform services and optionally the APIs of the infrastructure services that are employed in enabling the platform services.

In this example the cloud service provider also provides software application services in an application service layer . A software application e.g. a commercially available software application can be installed on one or more virtual machines or deployed in an application framework in the platform service layer . The software application can also communicate with one or more infrastructure service components e.g. firewalls databases web servers etc. in the infrastructure layer . The installation and configuration of the software application in the application service layer can be accomplished through APIs of the software itself and the APIs of the underlying platform and infrastructure service components.

To manage the deployment and operation of the cloud based services provided to the cloud service customers e.g. the example cloud service provider includes a cloud service manager . The example cloud service manager communicates with the frontend interface to receive service requests from the cloud service customers. The example cloud service manager is further responsible for the managing of the cloud resources and services including service enrollment provisioning coordination monitoring scheduling etc. As described in this specification the example cloud service manager also includes tools and libraries for translating the user requirements e.g. as expressed in one or more configuration specifications and service level agreements SLAs in the different service layers e.g. the layers and into physical resources demands e.g. as expressed in one or more kernel and hardware firmware level API calls .

Although the example cloud service provider provides all three types of cloud based services in some implementations fewer or more types of services may be provided. In some implementations the cloud service provider may outsource some of the cloud services or portions of a service to other cloud service providers. The cloud service manager may implement API calls to these other cloud service providers for supporting some of its services to the cloud service customers. In addition the conceptual layers of the cloud service provider shown in are merely illustrative. Other conceptual structure of a cloud service provider may be provided for example depending on the types of services actually offered by the cloud service provider.

In this example the cloud service customers can employ cloud based services offered in each of the services layers and . Depending on the type of services that a cloud service customer has employed the cloud service customer is granted different levels of control in configuring the services. For example if a software application service is employed an administrator user of the cloud service customer is given control over how the software application is configured but controls over the underlying platform and infrastructure services supporting the software application remains with the cloud service provider . If a platform service is employed an administrative user of the cloud service customer is given control over how the platform and or application frameworks are configured but the control over the infrastructure services that support the platform and or application frameworks remains with the cloud service provider . Similarly if infrastructure services are employed an administrative user of the cloud service customer is given control over the particular infrastructure services employed but not the underlying kernel layer and firmware and hardware layer .

In the cloud computing environment the cloud service customers access the cloud based services using data processing apparatus such as personal computers smart phones and tablet computers. Depending on the type of service being employed different user interfaces or programming interfaces may be used to communicate with the cloud service provider .

For example if a software application service is being employed an end user can access and use the software application through a web browser. If platform or infrastructure services are being employed a user of the service e.g. an administrator user of a cloud service customer can access a configuration user interface that includes administrative functions to control and configure the services. The administrative functions include for example starting or stopping virtual machines managing cloud storage installing and deploying software on virtual machines or setting up web servers etc. In addition a cloud service provider can optionally allow an administrator user of a cloud service customer to write program code according to various provider platform framework and or service dependent application program interfaces APIs to control and configure various aspects of the services that the cloud service customer receives. In some implementations if an open standard is used for a cloud computing environment provider platform framework and service independent APIs can be used to control and configure the services as well.

When configuring a cloud based service for deployment a service user or service developer provides one or more configuration files to the cloud service provider . The configuration files set forth the desired initial state of the service expressed in terms of various configuration parameters. Typically the configuration file is written in a structured way according to the rules and syntax provided or recognized by the cloud service provider such that the configuration file will be parsed and interpreted correctly by the cloud service provider .

As illustrated in the example conventional configuration specification relies on nested markup constructs e.g. code blocks and to describe the components of a deployment and relationships among the components. The user writing the configuration specification needs to be familiar with the details within each markup construct that goes into the configuration specification and the markup construct s meaning to the API translator of the cloud service provider. For a large and complex deployment the configuration file can become very long and complex with many layers of markups and duplicate statements. Furthermore the possibility of code reuse decreases as a configuration specification becomes long and complex because customization of the configuration specification for another deployment would require many changes and debugging the customized configuration file would also become more difficult.

As disclosed in this specification instead of providing a configuration specification written in a markup language or through a graphical user interface a cloud service customer or service developer can provide a configuration specification written in a high level object oriented specification language. The high level object oriented specification language allows components e.g. infrastructures storage devices services software package to be installed and software roles played by installed software applications of a cloud based deployment to be specified as instances of one or more reusable and modifiable classes where each class models a component of the deployment using a group of configurable class parameters. The value of each class parameter can be specified reused or modified for particular deployments using the syntax and functions provided by the object oriented specification language. The instance of each reusable and modifiable class declares the desired state of the component that is modeled by the class.

As described in this specification inheritance of class definitions is supported by the high level object oriented specification language. New class definitions can be provided based on statements relating or modifying one or more existing class definitions using the high level specification language. Statements relating different classes capture the relationships between multiple aspects e.g. data or functional components of a deployment. Examples of such relationships include the dependencies between software installations and service activations in a deployment the connectivity between multiple software roles in a deployment and the connectivity between a software role and a service or virtual device in a deployment. New class definitions can also be created by extending an existing class definition with the addition of new class parameters and or methods. A user can customize a deployment by specifying a new class derived from one or more existing base classes and instantiate the new class.

According to this specification a cloud service provider is able to compile a configuration specification written in the high level object oriented specification language into a set of API calls based on the requirements specified by the class definitions included in the configuration specification. The inclusion of a class definition in a configuration specification refers to a request in the configuration specification to instantiate the class definition or to instantiate a new class definition derived from the class definition.

In some implementations different service layers of the cloud service provider and different services within the same layer have different APIs. To compile the configuration specification written in the object oriented specification language the cloud service provider stores a set of rules and protocols for translating each of a set of most basic class definitions or core class definitions of the specification language to a respective group of API calls. The group of API calls for each core class definition conforms to the API of the type of components modeled by the core class definition. The compiler is then able to use the set of rules and protocols to translate all class definitions derived from the core class definitions into an appropriate combination of API calls to configure all of the components of a particular deployment. In some implementations the API calls are sent to and executed on one or more servers of the cloud service provider. Alternatively some of the API calls may be passed to an intermediary component of the cloud service provider or a third party service provider where the API calls are further processed into lower level API calls and carried out by the sub components of the intermediary component or third party service provider.

In some implementations the high level object oriented specification language also includes syntax for specifying triggers for scaling or dynamically reconfiguring various aspects of the deployment. For example a class definition that models a virtual machine can include one or more class parameters for a scaling policy such that the compiler can derive API calls to dynamically adjust the number of virtual machines deployed based on various performance metrics monitored by the cloud service manager e.g. the cloud service manager shown in .

The following examples shown in illustrate the syntax and various properties of an example object oriented specification language and how a cloud based deployment can be specified according to the example object oriented specification language and based on existing and newly derived class definitions.

In the first example an example configuration specification written in an example object oriented specification language is shown in . The deployment made according to this configuration specification is for launching a virtual machine with a web server e.g. an Apache web server installed and serving the files present in a data package.

This example assumes the existence of a number of base class definitions that the compiler is able to parse and translate to API calls. The existing base class definitions include a set of core class definitions provided by the compiler and possibly other class definitions that extend from one or more of the core class definitions either directly or via one or more intermediate class definitions.

In some implementations the existing base class definitions are grouped into modules e.g. modules utils std shown in and classes included in each module are referenced in a configuration specification by a module name followed by a class name e.g. std.Parameters utils.ConfiguratorLAMP std.DataPackage std.Role utils.PublicTCPFirewall utils.BaseDeployment as shown in the specification . Each of the base class definitions specifies an initial configuration state of a corresponding component of a cloud based deployment subject to the modifications and component relationships set forth in the configuration specification .

As shown in the configuration specification includes new class definitions that extend from the existing base class definitions. For example a new class Params extends from the base class std.Parameters a new class SimpleHostingPackage extends from the base class std.DataPackage a new class SimpleHostingVM extends from the base class utils.Configurator.LAMP a new class SimpleHostingRole extends from the base class std.Role a class SimpleHostingFirewall extends from the base class utils.PublicTCPFirewell and a class SimpleHostingDeployment extends from the base class utils.BaseDeployment as shown by the new class definitions and respectively. The configuration specification triggers the deployment of a simple hosting application by creating an instance of the SimpleHostingDeployment class e.g. as shown by statement which in turn creates instances of other classes from which the SimpleHostingDeployment class is derived.

In this example the SimpleHostingDeployment class definition customizes the definition of the base class utils.BaseDeployment by modifying two class parameters a roles parameter and a firewall parameter. The roles parameter specifies the respective software roles that one or more installed software packages are supposed to play in the deployment. The firewall parameter specifies that a firewall service is to be included as part of the deployment. In this case the class definition specifies that a single software role is to be included which is represented by an instance of the SimpleHostingRole class. The class definition further specifies that the firewall service to be included in this deployment is represented by an instance of the SimpleHostingFirewall class. According to the properties of the object oriented specification language the SimpleHostingDeployment class inherits other class parameters defined in the base class utils.BaseDeployment without further modification. These other class parameters describe other aspects of the deployment that need not be further customized for this simple hosting deployment.

According to the class definition instantiation of the SimpleHostingDeployment class requires instantiation of the SimpleHostingRole and the SimpleHostingFirewall classes as well. As shown in the SimpleHostingRole class definition extends from the base class std.Role. Both classes are based on a software role model that categorizes a software installation according to the role that the software installation plays in a cloud based deployment. For example a software package may be installed to play a role of a webhost a frontend a backend a communication interface and so on. Depending on the particular role that a software installation plays different parameters may be used to configure the software installation. Each configurable parameter for the software role can have a corresponding class parameter or function in the class definition created based on the software role model.

In one example in addition to an identifier or name of the role that the software installation plays in a deployment a software role model can include model parameters for configuring various aspects of the software installation including the virtual machines on which the software is to be installed the location of the software binary instructions on which installer program should be used to install the software and so on. If the software installation requires other services or software installations to be performed first this dependency is optionally included in the software role model as well. Example of dependency relationships are start after or stop before. Other dependency types e.g. install on the same virtual machine etc. can be supported as well.

In this example in the class definition for the SimpleHostingRole class specifies that the role of the software installation in the deployment is to serve as a webhost. How the webhost software is to be deployed is made known to the compiler through the class definition of the simplehosting.webhost class. In this example the simplehosting.webhost class definition includes the configurations of a simple apache web server which is already written and made known to the compiler. When the SimpleHostingRole class is instantiated the simplehosting.webhost class is instantiated as well.

The class definition for the SimpleHostingRole class further declares that the data package that is needed to run this webhost is represented by an instance of the SimpleHostingPackage class and that the webhost is to be installed on virtual machines that are represented by instances of a SimpleHostingVM class.

In this example each of the roleName moduleName dataPackages and vms are parameters of the std.Role class and are customized in the SimpleHostingRole class definition . Other class parameters of the std.Role class are inherited by the SimpleHostingRole class without modification.

The class definition of the SimpleHostingRole class also defines a few new parameters such as the serving domain and document root parameters whose values are assigned either indirectly through another parameter name e.g. serving domain of the Params class or by a direct value entry e.g. var www static . In this example only one software role is defined so no dependency between software roles is specified for the software role e.g. the SimpleHostingRole in terms of installation or execution.

With respect to the firewall component of the deployment the class definition of the SimpleHostingFirewall class is based on the existing utils.PublicTCPFirewall class definition. In this example the utilis.PublicTCPFirewall class defines a public firewall with Transmission Control Protocol TCP set as the protocol. The only parameters of the PublicTCPFirewall class that are modified for this deployment are the target and ports parameters. In the class definition the target of the firewall is represented by an instance of the SimpleHostingRole class while the port of the firewall is set to port 80. Other parameters e.g. the source and the protocol parameters that are needed to configure the firewall are specified in the base class definition of PublicTCPFirewall and are inherited by the SimpleHostingFirewall class without modification. In this example a connectivity between the firewall component and the simple hosting software role e.g. represented by an instance of the SimpleHostingRole class is specified by the value assignment to the target parameter.

In this example the class definitions of the SimpleHostingFirewall and the utils.PublicTCPFirewall classes are both based on a firewall service model. Unlike a software role model a service model does not need to include parameters for the underlying virtual machines disks or software packages. Instead these aspects are controlled by the cloud service provider and not subject to the configuration by the users of the service. Like in a software role model a service model also optionally includes parameters that specify dependences between services and between services and software roles. In this example the firewall component is connected to the web server component but no dependencies of the firewall service are specified for this simple hosting deployment.

As set forth earlier and shown in the class definition of the SimpleHostingRole class requires instantiation of the SimpleHostingPackage class and the SimpleHostingVM class. The class definition of the SimpleHostingPackage class specifies the source of the data e.g. data in the current directory that is to be copied to the virtual machine hosting the SimpleHostingRole. The class definition further specifies a destination directory e.g. var www static of the copied data on the virtual machine. When the deployment is carried out according to the configuration specification the data package data is copied from the directory in which the configuration file resides to the destination directory var www static on the virtual machine that has been deployed according to the SimpleHostingVM class definition .

As shown in the SimpleHostingVM class definition extends from the utils.ConfiguratorLAMP class definition. Both classes are based on a virtual machine model and specify how a virtual machine can be configured. In this example the utils.ConfiguratorLAMP class configures a customized virtual machine that already has an Apache web server installed. Therefore by extending from the utils.ConfiguratorLAMP class rather than a standard virtual machine class a user can simplify and speed up the configuration process. The SimpleHostingVM class definition also specifies the number of virtual machines to be deployed in this deployment and the external IP addresses to be bound to the virtual machines through the newly added replicas and staticIP class parameters. Other parameters that are commonly used to configure a virtual machine or virtual machines for supporting a software role include for example configuration parameters for the CPU and memory requirements of the virtual machine s storage disks to be attached to the virtual machine s read only storage sources attached to the virtual machine s IP addresses network interfaces of the virtual machine s the data center location of the virtual machine s and so on. Each of these virtual machine model parameters is optionally included as a class parameter in a virtual machine class definition or another class that extends from a virtual machine base class definition.

Optionally a special Params class is included in the configuration specification of a deployment such as that shown in the example configuration specification . Parameter values can be provided in this class definition and used to assign values to parameters in other class definitions that are included in the same configuration file. For example the values of parameters replica count serving domain and ip array are injected into the class definitions and through references made to the respective names of parameters.

As illustrated in the example configuration specification it is possible to create class definitions for different components of a cloud based deployment based on different component models. A high level object oriented specification language can be developed based on models of various types of infrastructures storage services and software roles that commonly occur in a cloud based computing environment. Each model describes a corresponding infrastructure component storage service or software role using a number of model parameters. Core class definitions that represent generic initial configuration states of some most common and basic components of the cloud based environment can be created based on these component models. As more complex components can be built from combinations of multiple basic components class definitions that represent the initial configuration states of more complex components can be created from multiple core class definitions and or other class definitions that are derived from the core class definitions.

A compiler of the high level object oriented specification language is created to parse the class definitions created based on these component models extract the configuration requirements expressed by the values of the class parameters and translates the requirements into a proper set of API calls for configuring the types of components represented by these component models. In some implementations a compiler is implemented as a software program or script that reads a configuration file and outputs a set of API calls. In some implementations the compiler also direct the API calls to appropriate components of the cloud service provider or third party providers for execution.

The example in has illustrated class definitions developed based on an example software data package model an example virtual machine model an example software role model an example firewall service model and an example deployment model respectively. As an additional example an example storage model includes model parameters for configuring aspects of a storage option of a deployment such as the size of the storage mounting points of the storage and so on. In some implementations a storage model optionally includes a scaling policy for dynamically adjust the size of the storage based on monitored usage of the storage. Furthermore in addition to a firewall service a cloud based environment can include many platform and infrastructure services such as a database service a message queue service a load balancing service a map service a MapReduce service and so on. Different service models can be developed for each of these cloud based services and class definitions for configuring the different services can be created based on the different service models.

As illustrated by the example of an object oriented specification language enables the creation of class hierarchies that represent different levels of customization for components in various layers of the cloud computing environment. A configuration specification written in the object oriented specification language can reuse existing class definitions either by extending from an existing class definition or referring to an instance of an existing class definition when assigning a value to a class parameter. Reusing existing class definitions simplifies the configuration specification for a new deployment. Furthermore when reusing an existing class definition a user only needs to know the configuration state that can be accomplished by the existing class definition but not all the literal details set forth within the class definition to accomplish that configuration state.

In addition class definitions of highly complex components e.g. components involving multiple services multiple data sources and multiple levels of deployments can be developed based on multiple existing class definitions with or without modification to the class parameters of the existing class definitions. These highly complex class definitions can be reused by a user in a new deployment without in depth understanding of these complex class definitions on all levels.

By choosing the appropriate base classes to customize and modify in a new configuration specification the user also gains more refined control over particular aspects of the deployment while leaving other aspects of the deployment generic to definitions of the base classes.

The following describes how the based class definitions in the lamp module are used to establish a basic LAMP deployment structure. In the lamp module the special Params class includes some parameters that are used in multiple class definitions such as a flag single node indicating whether the Apache software and the MySQL software should be installed on the same virtual machine a frontend ip parameter for specifying the IP addresses to be bound to the LAMP frontend component a serving domain parameter for specifying the domain name of the Apache website a doc root parameter for setting the document root of the Apache server a mysqldatafolder parameter for setting the database folder relative to the persistent disk mount point a mysql pdname parameter for specifying the name of the persistent disk a mysql pd mount point parameter for specifying the mount point of the persistent disk a pd size gb parameter for specifying the size of the persistent disk in GB. Optionally the parameter values in the special Params class can be changed through a command line tool provided by the cloud service provider to make it more convenient for users to adjust deployments based on the lamp module.

A LAMP based application deployment typically includes the following components a frontend i.e. the software role of a frontend software application virtual machines on which the frontend software application e.g. an Apache web server application is installed a database i.e. the software role of a database software application virtual machines on which the database software application e.g. a MySQL software application is installed a permanent disk for storing the database and a firewall. Each of the above components is modeled by a respective set of class parameters that are configurable for a particular LAMP based application deployment.

As shown in the class definition FrontendVM extends from an existing class definition utils.ConfiguratorLAMP which configures a virtual machine image that already has an Apache web server software pre installed. In this case the MySQL database software is to be installed on the same virtual machine as the Apache software as indicated by the single node flag in the Params class definition . Therefore the DatabaseVM class definition also extends from the class definition utils.ConfiguratorLAMP. 

In the lamp module the MysqlPD class definition models the permanent disk on which the database is to be stored. The MysqlPD class definition includes class parameters that specify the name of the persistent disk the size of the persistent disk and the mount point of the persistent disk for example. Other parameters that specify how the persistent disk should be configured are inherited from an existing std.PersistentDiskSpec class definition without modification.

The FrontendRole class definition models the frontend component of the LAMP based environment. The FrontendRole class definition extends from a standard software role modeled by an existing base class definition std.Role. The FrontendRole also refers to a lampfront placeholder class and a lamp placeholder module as the temporary values assigned to the roleName and the moduleName class parameters. These temporary values will be replaced by the names of the actual module and class that configure the LAMP frontend software application to be deployed. As will be shown in the class definition that configures the front end software e.g. the Mantis debugging software is the mantis frontend class in the mantis module. The class definition also sets forth that the virtual machine on which the LAMP frontend role is to be installed is represented by an instance of the FrontVM class .

The DatabaseRole class definition models the database component of the LAMP based environment. The DatabaseRole class also refers to a placeholder class in a placeholder module e.g. lamp and lamp backend for the backend software configuration. The names of the placeholder class and the placeholder module will be replaced by the actual names of the class and module that configure the backend database software. The DatabaseRole class definition also specifies that the persistent disk storing the database is represented by an instance of the MysqlPD class definition . In addition a vms parameter is defined to indicate that the virtual machine for installing the backend database software of the LAMP environment is to be represented by an instance of the FrontendVM class if the single node flag is set to TRUE otherwise the virtual machine is to be represented by an instance of the DatabaseVM class.

Lastly in the lamp module the firewall component of the LAMP based environment is modeled by the HttpFirewall class definition . The HttpFirewall class definition extends from the existing utils.PublicTCPFirewall class definition such as the protocol source and target parameters of the util.PublicTCPFirewall class are inherited by the HttpFirewall class. The HTTPFirewall class definition modifies the port parameter of the utils.PublicTCPFirewall from any to 80. 

Each class definition set forth in the lamp module shown in is extendable modifiable and or usable as is for an application specific deployment and or for creating new class definitions in other modules. The configuration specification shown in includes and builds upon the class definitions in the lamp module shown in . A statement at the beginning of the configuration specification points to a file containing the class definitions of the lamp module to indicate to the compiler where to locate the base class definitions that are used in the configuration specification .

The configuration specification is for configuring an application deployment that launches virtual machines in a LAMP structure and installs the Mantis debugging software on the virtual machines. Mantis is a web based bug tracking system written in the PHP scripting language and works with a MySQL database and a webserver.

As specified in the in the MantisDeployment class definition the deployment calls for two software roles and a firewall to be installed. In this case the two software roles are created according to the MantisFrontend class definition and the MantisDatabaseRole class definition while the firewall is created according to the MantisFirewall class definition . When the configuration specification is compiled the statement makes an instance of the MantisDeployment class and causes the other classes on which the MantisDeployment class depends to be instantiated as well.

In this example the MantisFrontend class definition extends from the lamp.FrontendRole class definition shown in . The class parameters that are modified for the Mantis software installation include the roleName moduleName of the software configuration specification the dataPackages from which the Mantis software binaries can be copied and the database host to be associated with the Mantis application deployment. The configuration parameters for the virtual machine aspect of the Mantis frontend are inherited from the lamp.FrontendRole class definition without modifications. In other words the user writing the configuration specification accepts the default virtual machine configuration specified in the lamp module and needs not customize the Mantis application deployment with that level of details.

Similarly the MantisDatabaseRole class definition extends from the lamp.DatabaseRole class definition shown in . The class parameters that are modified for the Mantis software installation includes the roleName and moduleName of the configuration specification for the backend database role. In addition the frontend host of the database role is set to be an instance of the MantisFrontendRole class. The configurations for the virtual machine aspect and the persistent disk aspect of the database backend role are inherited from the lamp.DatabaseRole class definition without modification.

In addition the MantisFirewall class definition inherits the parameters from the lamp.HTTpFirewall and modifies only the value for the target parameter to an instance of the MantisFrontendRole class. Other parameters such as the port and protocol parameters of the MantisFirewall class are inherited from the base class lamp.HTTpFirewall defined in the lamp module .

Other parameters and values specific to the Mantis deployment are set forth in the special Params class definition and the data package from which the Mantis software is copied is specified in the MantisPackage class definition .

In the above example the configuration specification for the Mantis software deployment is derived from the base class definitions e.g. class definitions in the lamp module created for a generic LAMP based application deployment. Configurations of many aspects of the LAMP based deployment do not have to be redefined for the Mantis application deployment. The configuration specification for the Mantis application deployment only needs to specify new parameters or new parameter values that are particular to the Mantis application deployment or in need of customization. Parameters that are already defined for other more generic aspects of the deployment do not need to be re specified or modified in the configuration specification . The details of these other aspects of the deployment can remain opaque to the user.

The examples shown in are merely illustrative of the properties of an object oriented specification language for writing configuration specifications of cloud based deployments. In various implementations the exact syntax of the object oriented specification language can depart from what is shown in the examples. Furthermore many types of base classes can be created to model the components that may exist in a cloud environment. Syntax for specifying relationships between components modeled by the classes can also vary from one object oriented specification language to another object oriented specification language. For a given object oriented specification language a compiler can be created to parse the class definitions included in a configuration specification written in the object oriented specification language according to a predetermined set of syntax rules to extract the parameters that are used to configure the various types of components in the cloud environment.

After the frontend receives the configuration specifications from an administrative user of the cloud service customers the frontend passes the received configuration specifications to an API translator of the cloud service manager . The API translator have access to a library of core class definitions e.g. stored in a definition database and translation protocols e.g. stored in a rule database on how to translate the core class definitions into respective sets of API calls for configuring various components of a cloud based environment of the cloud service provider .

For example the API translator can include a compiler e.g. a parsing script or program that parses the class definitions received in a configuration specification identify all the base classes from which the classes in the configuration specification are derived and extract the base class parameters that are left unmodified as well as the class parameters that are modified or new. In addition the compiler also identifies all the relationships e.g. connectivity and dependencies among the components of the cloud based deployment from the statements in the class definitions. Based on the values of the class parameters and the stored translation protocols the API translator generates an appropriate set of API calls to configure various aspects of the cloud based deployment.

For example the translation protocols can include a mapping between a core class definition modeling a respective modular aspect of the cloud based environment to a group of API calls that are used to configure that aspect of the cloud based environment. The translation protocols can further include protocols for modifying the set of API calls e.g. changing default parameters used in the API calls with parameter values specified for that modular aspect of the cloud based environment in classes derived from the core class definition.

As a more specific example suppose a standard virtual machine class definition e.g. a std.VM class is a core class definition known to the compiler. The compiler would have access to a translation rule mapping the core class definition to a set of provisioning API calls made to the VM manager in the kernel layer of the cloud service provider for deploying a standard virtual machine image. A default set of parameters e.g. duplicate count IP address memory requirement etc. can be used in the provisioning API calls. The protocol for modifying the API calls can include protocols for changing the default parameter values according to the parameter values specified in the specification configuration and in intermediate class definitions that are derived from the standard virtual machine class definition. For example if a class parameter of a new class definition derived from the standard virtual machine image specifies the software package to be installed on the virtual machine image the translation protocols would specify how the additional API calls for installing software packages on a designated virtual machine should be added to the group of API calls associated with configuring the standard virtual machine image.

In some implementations the protocols for translating class definitions to API calls are written as program scripts. As new core class definitions are added to the class definition database the protocol for translating the new class definition can be created and added to the translation rules database . The translation protocols can be created for example by the cloud service provider . In some implementations when encountering a particular class definition in parsing a received configuration specification the API translator locates and runs a corresponding script to parse the class definition into a set of API calls. The API calls when executed cause the configuration specified by the class definition to be achieved in the cloud based environment.

In some implementations the API calls generated by the API translator are sent to a service launcher component of the cloud service manager . The service launcher component is responsible for channeling the API calls to various layers of the cloud service environment or components of the cloud service provider where the API calls can be executed. In some implementations where the deployment are to be carried out in several stages due to the dependencies between various aspects of the deployment the service launcher component is also responsible in checking the order by which the API calls are sent out to the layers and or components for execution and verify that the API calls have been completed in a proper sequence.

Since class definitions written in an object oriented specification language as disclosed in this specification can be reused in multiple configuration specifications an administrator user of a cloud service may wish to employ class definitions provided by a third party e.g. another user a service developer of the cloud service provider or third party developers in their own configuration specifications rather than developing those class definitions by themselves. In some implementations a marketplace for sharing sale and selection of existing configuration specifications and reusable class definitions can be provided for example by the cloud service provider or a third party provider.

In this example the cloud service provider provides such a platform for the sharing of reusable configuration specification and class definitions. In some implementations the frontend of the cloud service provider provides a definition submission user interface and a definition selection interface to facilitate the sharing of reusable configuration specifications and class definitions. The parties that provide the configuration specifications and class definitions for reuse by others serve as definition suppliers for the cloud service provider . The potential definition users include administrative users of cloud based services. The potential definition users also optionally include definition suppliers who will create new reusable class definitions or class definitions for submission based on the existing class definitions provided by other definition suppliers.

As shown in the cloud service manager of the cloud service provider or a component of the cloud service manager can serve to manage the platform for sharing reusable class definitions . The definition suppliers submit reusable class definitions to the cloud service manager through the definition submission user interface provided by the frontend . Each class definition submission can include multiple reusable class definitions such as in a class module. Each class definition in the submission is accompanied by descriptions of the initial configuration state that the class definition can accomplish if subsequently used in a configuration specification. In some implementations the description also includes instructions on how the class parameters in the class definition can be subsequently modified in configuration specifications to suit the needs of particular deployments.

When a definition supplier submits a reusable class definition or a module of reusable class definitions the cloud service manager can store the received class definitions in a class definition database e.g. the definition database . In some implementations the frontend provides registration and authentication services for the definition suppliers . Each class definition or class module received from a registered definition supplier is stored in association with the identifier of the definition supplier such that the definition supplier can be properly credited when the class definition is subsequently used or purchased by a definition user.

In some implementations the definition suppliers can provide reusable class definitions for free or for a cost. The cloud service manager can facilitate the sale or license of the reusable class definitions to the potential definition users e.g. administrative users of the cloud service customers through the definition sharing platform. In some implementations the definition supplier provides and the cloud service manager stores respective prices associated with the sale or licenses for different usage levels for the reusable class definitions provided by the definition suppliers .

In some implementations the cloud service manager provides a definition selection user interface over the frontend . The definition selection user interface presents the class definitions that are available for reuse such as in defining new class definitions. The new class definitions include those included in the configuration specification of a new deployment and optionally those that are submitted to the cloud service provider for reuse by others. The potential definition users e.g. administrative users of the cloud service customers and definition suppliers can view the class definitions that are available for selection through the definition selection interface along with their prices and descriptions and optionally reviews and quality scores and decides on whether to reuse one or more of the class definitions in a configuration specification or for deriving a new class definition.

In some implementations potential definition users provide the definition selection user interface with criteria that specify a configuration to be deployed. The criteria can include one or more class definitions. The cloud service manager processes the criteria and provides to the user collections of class definitions satisfying the criteria. A collection of class definitions can include additional class definitions that are not explicitly specified in the criteria as long as the additional class definitions are compatible with class definitions specified in the criteria. The collections of class definitions can be ranked using methods further described below in . If the user selects a collection of class definitions the cloud service manager identifies a configuration specification associated with the collection of class definitions and deploys the configuration specification to the cloud environment of the cloud service provider .

In some implementations definition selection user interface allows the user of the class definitions to download or copy a reusable class definition available for selection. In some implementations the user does not have to copy or download the class definition and can use the class definitions by simply identifying the module and class name in a configuration specification submitted to the cloud service provider for deployment. The cloud service manager will identify and locate the class definitions that are referenced in the specification file and keep track of the usage of the class definition.

In some implementations the reuse involves an entire module e.g. the lamp module shown in where the module includes a collection of multiple interrelated class definitions for configuring a cloud component that includes multiple sub components. In some implementations the class definitions or class modules are categorized based on the type of components they model. In some implementations the definition selection interface allows the potential users of the class definitions to search or review available class definitions by categories functions definition suppliers and other attributes associated with the class definitions and modules.

In some implementations the cloud service provider or a third party provider also provides a platform for software suppliers to provide software solutions accompanied by multiple alternative configuration specifications or alternative collections of class definitions for configuring the software solutions. For example a personnel management program can be accompanied by configuration specifications that are tailored for cloud service customers that have different scale needs and internal infrastructures. When a cloud service customer purchases or licenses the software solution for deployment in the cloud environment of the cloud service provider the cloud service customer can choose the configuration specification that best suits its needs.

In some implementations the service manager can receive submissions of software solutions with accompanying configuration specifications e.g. either as configuration specifications or modules of reusable class definitions through a software submission user interface provided through the frontend . In some implementations the software submission user interface includes registration and authentication capabilities such that each submission of a configuration wrapped software solution is stored in association with the software provider that submitted the configuration wrapped software solution .

The cloud service provider can provide the configuration wrapped software solutions in a software selection interface to the cloud service customers through the frontend . The software selection interface can also provide the descriptions of the different configuration specifications accompanying each software solution. When a user e.g. an administrative user of an cloud based application service select a software solution and one of the accompanying configuration specifications from the software selection interface the cloud service provider can launch the software solution in the cloud based environment according to the selected configuration specification with or without additional customizations.

In some implementations the cloud service provider facilitates the accounting e.g. by an accounting component for the sale and purchase of the reusable configuration specifications reusable class definitions and configuration wrapped software solutions that are accomplished through the platforms provided by the cloud service provider . In some implementations the cloud service provider does not need to directly provide these platforms but provide accounting services e.g. by the accounting component to the user and provider of the reusable configuration specifications reusable class definitions and configuration wrapped software solutions based on actual usage that has occurred in the cloud environment of the cloud service provider .

In some implementations the cloud service manager includes a service monitor . The service monitor monitors the statuses of the cloud services that have been deployed in the cloud environment of the cloud service provider . The statuses monitored by the service monitor include for example the virtual resources that are employed for each component of a cloud based deployment the usage level of the virtual resources the cloud services that are employed by each component of the cloud based deployment the usage level of the cloud services. The service monitor can compute performance metrics associated with each cloud based deployment based on the statuses of the virtual resources and the cloud based services that are associated with the deployment. The performance metrics include for example the number of user requests received the latency associated with the responses the availability of the virtual resources and services the failure rate of each virtual resource or service the fault tolerance level of the virtual resources and services and so on. In some implementations the performance metrics is stored in a performance data store of the cloud service manager .

As disclosed in this specification cloud based deployments can be carried out according to configuration specifications written in an object oriented specification language where the configuration specifications include class definitions that model different aspects of the cloud based deployments at different levels of abstraction. When the cloud service manager processes a configuration specification into a set of class definitions the cloud service manager is able to track the hierarchy of class definitions that have influenced the configuration of each of those different aspects of the deployment. Further the cloud service provider is able to associate the virtual resources and services that are dedicated to the different aspects of the cloud based deployment to the different class hierarchies that have influenced the configuration of those aspects of the cloud based deployment.

Therefore the object oriented specification language allows performance metrics to be derived for each of these different aspects based on the status and performance of the virtual resources and services that contribute to the performance of the aspect of the cloud based deployment. In particular the performance associated with each aspect of the cloud based deployment is associated with the class definitions that are involved in configuring that aspect of the cloud based deployment. Then the performance associated with a class definition can be used as a factor in determining a quality measure for the class definition. If a class definition is used in configuring multiple cloud based deployments the aggregated performance associated with the class definition can be used to assess the quality of the class definition.

Using the reusable class definitions and configuration specification shown in as an example when the service cloud manager deploys the Mantis and MySQL software applications and the firewall service in the Mantis application deployment according the MantisDeployment class definition and all the base classes on which the MantisDeployment class definition depends the service manager can monitor the respective performances of the software roles the firewall service and the underlying virtual machines supporting the software roles. The cloud service manager can associate the respective performances of the frontend role with the classes that influenced the configuration of the frontend component of the Mantis deployment associate the respective performance of the firewall component with the classes that influenced the configuration of the firewall component associate the respective performance of the virtual machines underlying the frontend role with the classes that influenced the configuration of the frontend virtual machines and so on for example.

In some implementations the cloud service manager can generate a system block diagram of the cloud based deployment according to the configuration specification writing in the object oriented specification language. For example the nature of the infrastructural components storage services software roles as well as their interrelationships e.g. dependencies and connectivity and reconfiguration triggers can be identified from the class definitions in the configuration specification and represented as corresponding elements in the system block diagram of the deployment. The basic system block diagram can be created when the configuration specification is parsed by the API translator for example.

Next according to the class definition of the MantisFrontendRole class the cloud service manager determines that the software application serving the frontend role is to be deployed according to the class definition of the mantis frontend class. The cloud service manager therefore adds a block within the block to represent the frontend software that is serving the frontend role. Similarly from the class definition of the MantisDatabaseRole class the service manager determines that the software application serving the database role is to be deployed according to the class definition of the the mantis backend class. Therefore the service manager adds a block within the block to represent the backend database software that is serving the database role.

Furthermore according to the class definitions and of the MantisFrontendRole and the MantisDatabaseRole the frontend role and the database role are connected to each other. Based on the class definition of the MantisFirewall the firewall is connected to the frontend role. Therefore the cloud service manager can insert a connection between the block and the block to represent the connectivity relationship between the frontend role and the database role. In addition the cloud service manager also inserts a connection between the block and the block to represent the connectivity relationship between the frontend role and the firewall.

In addition since the MantisFrontRole class definition extends from the FrontendRole class definition the cloud service manager determines from the class definition of the FrontendRole class that the frontend software e.g. the Mantis software is to be installed on a virtual machine modeled by the FrontendVM class definition . Similarly the MantisDatabaseRole class definition extends from the DatabaseRole class definition and the cloud service manager determines from the class definition of the DataBaseRole class that the backend database software e.g. the MySQL database software is to be installed on the same virtual machine as the frontend role software. Based on the above information the service manager adds a block under the blocks and to represent the underlying virtual machine for the frontend role and the database role.

Furthermore according to the DatabaseRole class definition the cloud service manager determines that a persistent disk is connected to the database role by a mount point on the underlying virtual machine. The persistent disk is deployed according to the specification specified in the MysqlPD class definition . Therefore the service manager adds a block to the block representing the mantis deployment and adds a connection to represent the connectivity relationship between the database software its underlying virtual machine and the permanent disk.

In some implementations when the components of the deployment is deployed the service manager can also record identifiers associated with the underlying infrastructure components e.g. process IDs or identifiers of the virtual machines and other virtual resources for each block or connection represented in the block diagram . When the cloud service manager monitors the statuses of the underlying virtual resources and services for the deployment the cloud service manager optionally determines the performance or usage metrics for each component e.g. blocks and connections represented in the block diagram . The cloud service manager can also optionally represent the performances and usage of the different component in the system block diagram .

In some implementations visualization of the performances and usage of these different components of the deployment and their changes over time can be shown on the block diagram . In some implementations the cloud service manager can present the performance and usage statistics in a visual form on the block diagram in a management interface of the cloud services for each cloud service user. For example the performance and usage statistics can be represented as a histogram or pie chart that dynamically changes according to the actual conditions of the components in the cloud environment. In some implementations the cloud service provider bills the cloud service customers according to the performance and usage statistics.

In some implementations the configuration specification optionally includes programmatically triggered reconfiguration requests. For example the configuration specification for a component can specified that when a particular monitored parameter reaches a specified threshold value the cloud service manager is to scale the provisioned virtual machine or services by a specified amount. For a more specific example the class definition of the persistent disk class e.g. the MysqlPD class definition can include a statement that requests an increase in the size of the persistent disk when the disk capacity is 80 utilized the class definition of the frontendVM class can request that when the latency of the frontend role is more than one second the replica count parameter of the FrontendVM is to be increased by one and so on.

As set forth in this specification the object oriented specification language allows the configuration of each component in a cloud based deployment to be specified by a respective set of class definitions. When parsing a configuration specification the service manager is able to identify the components of the deployment and identify all of the base classes whose class parameters contributed to or influenced the configuration state of the component. In some implementations the performance of each component is associated with the class definitions that contributed to the configuration of that component. If a class definition contributed to the configuration of multiple components in multiple deployments the performance of these multiple components in the multiple deployments can all be associated with that class definition. The quality of the class definition can be assessed based at least in part on the aggregated performance of all of the multiple components in the multiple deployments.

In some implementations the cloud service manager keeps track of the usage of each class definition in the cloud based environment and charges the cloud service users that have used the class definition in their deployments. Optionally the amount of charge billed to the users is based on the amount of usage the user has accrued for the class definition in all of the deployments the user has requested. In some implementations where the class definitions are provided by third party definition providers the cloud service manager can record a credit to the third party definition provider for each use of the class definition provided by the third party definition provider.

For example when parsing the configuration specification for the Mantis application deployment shown in the cloud service manager records that the Mantis frontend component is deployed according to the MantisFrontendRole class definition which extends the lamp.FrontendRole class definition uses the mantis frontend class definition for software configuration and the MantisPackage class definition to identify the location of the software package and is connected to the MantisDatabaseRole class . Further the service manager determines that the lamp.FrontendRole class definition further extends from the std.Role class definition uses the FrontendVM class definition and that the FrontendVM class definition extends from the utils.ConfiguratorLAMP class definition.

The cloud service manager can continue to identify the class definitions that are involved in the configuration of the frontend role component of the deployment by tracing the class hierarchies connected to the MantisFrontendRole class definition until the most fundamental sets of class definitions are identified. All of the class definitions that contributed to the configuration of the frontend role component are associated with the frontend role component for the deployment. A similar process can be carried out for each component of the deployment.

When the deployment is carried out the cloud service manager can record the usage of each class definition in configuring the deployment according to the number of times that the class definition is used in the deployment. In some implementations multiple uses of a class definition is counted only once in each deployment or for each user depending on the payment structure e.g. fees per use license or per sale established by the definition supplier of the class definition.

In some implementations in a marketplace of reusable class definitions each reused class definition can be ranked against other reused class definitions according to the aggregate performance of the class definition in all the deployments that used the class definition. In some implementations the performance of a deployment can be associated with each class definition that contributed to the configuration of the deployment and used in evaluating the quality of the class definition. In some implementations only performances of those components whose configurations are influenced by a class definition are associated with the class definition and used in evaluating the quality of the class definition.

For example when the cloud service manager identified multiple components in multiple deployments that are influenced by a virtual machine class definition the aggregated performance of the multiple components are used in evaluating the quality of the virtual machine class definition. In addition when the cloud service manager identifies all of the class definitions that contributed to the configuration of a frontend role component of a deployment the performance associated with the frontend role component in the deployment will be associated with each of these identified class definitions.

In some implementations a quality score is calculated for each class definition based on the aggregated performance associated with all or multiple components or deployments that are configured based at least in part on the class definition. The quality score can be presented with the class definition in the definition selection interface provided by the cloud service provider. In some implementations multiple quality metrics can be calculated for each class definition based on for example the scales of the deployments that utilized the class definition the weight or influence of the class definition in each deployment that utilized the class definition the availability fault tolerance scalability and failure rate of the components configured according to the class definition the types of problems encountered the modifications required to solve the encountered problems explicit user feedback and so on. Based on the various quality metrics one or more types of quality scores can be provided for each shared class definition and a potential definition user can browse the list of available shared class definitions based on the quality scores.

Although the above example describes the quality scores with respect to reusable class definitions similar quality scores can be calculated for reusable class modules reusable configuration specifications or configuration wrapped software solutions.

In the example process a configuration specification for configuring a cloud based deployment is received e.g. by the API translator of a cloud service provider . The configuration specification is written in an object oriented specification language and requires instantiation of class definitions of one or more classes. Each class models a respective data or functional component of the cloud based deployment using a group of configurable class parameters. The respective class definition of each class represents a requested state of the data or functional component modeled by the class. A plurality of API calls for configuring the cloud based deployment are derived based on the class definitions of the one or more classes . Then the API translator of the cloud service provider causes the plurality of API calls to be executed to configure the cloud based deployment .

In some implementations the one or more classes include at least an existing base class and at least a customized class extended from the existing base class. In some implementations the customized class inherits respective class parameters of the existing base class and modifies a value of at least one of the class parameters inherited from the existing base class. In addition or alternatively the customized class inherits respective class parameters of the existing base class and includes at least one new class parameter not present in the existing base class.

In some implementations a modification of a base class propagates to deployments of configuration specifications that include the base class or classes that inherit the base class. The cloud service provider can modify a base class. Once the base class is modified the cloud service provider propagates the modification to deployments having configuration specifications that include the base class or a class inheriting the base class. In some implementations the propagation can trigger a redeployment for each configuration specification having a modified base class. For example if a more improved solution is discovered for executing a functional component e.g. a faster method of running a web server is discovered the cloud service provider can modify the base class for the functional component to implement the improved solution. The cloud service provider identifies configuration specifications that include the base class or classes that inherit the base class. The cloud service provider then redeploys these configuration specifications with the improved solution.

In some implementations the data or functional component modeled by each class is one of a virtual device supporting a cloud based environment a service utilized in the cloud based environment a software role performed by an installed application in the cloud based environment a data package holding data to be used during deployment or operation of the cloud based environment or a combination of one or more thereof.

In some implementations the object oriented specification language supports dependency between class definitions and a definition dependency between a first class and a second class represents a deployment dependency between respective components modeled by the first and the second class. In some implementations the definition dependency between the first class and the second class is expressed by a class parameter of the first class where the class parameter of the first class refers to an instance of the second class.

In some implementations the object oriented specification language supports connectivity between class definitions and a value assignment linking an instance of a second class to a class parameter of a first class represents a connectivity between respective components modeled by the first class and the second class.

In the example process the cloud service provider identifies based on the respective class definitions of the one or more classes in a configuration specification a plurality of data and functional components modeled by the one or more classes and one or more dependency and connectivity relationships existing among the plurality of data or functional components . Then the cloud service provider derives a block diagram of a cloud based environment based on the identified plurality of data and functional components and the identified dependency and connectivity relationships . In some implementations when deriving the block diagram the cloud service provider also represents trigger events for dynamic reconfiguration of the cloud based environment in the block diagram.

In the example process for each class definition the cloud service provider identifies an aspect of the cloud based deployments that are influenced by the class definition in terms the respective initial configuration state of the aspect . The cloud service provider monitors one or more performance metrics associated with the identified aspect . The cloud service provider associates the one or more performance metrics with the class definition . Then the cloud service provider utilizes the one or more performance metrics in calculating a quality metric of the class definition .

In the example process the cloud service provider identifies a plurality of cloud based deployments each having been carried out according to a respective configuration specification written in the object oriented specification language . The cloud service provider then identifies at least one base class whose class definition is used in multiple of the plurality of cloud based deployments . The cloud service provider monitors respective performance of each of the multiple of the plurality of cloud based deployments . The cloud service provider then calculates a quality metric of the at least one base class based on aggregated performance of the multiple of the plurality of cloud based deployments . In some implementations the respective performance of each of the multiple of the plurality of cloud based environment is a performance associated with a data or function component modeled by the at least one class.

In the example process the cloud service provider stores respective class definitions of a plurality of core classes of the object oriented specification language . Each core class corresponds to a modular component of a cloud based environment and each core class is extendable with additional class parameters to configure the respective modular component. The cloud service provider also stores a mapping between each of the core classes and a respective group of API calls . The respective group of API calls is for configuring the modular component associated with the core class according to the class parameters of the core class. The cloud service provider also stores a plurality of protocols for modifying the respective groups of API calls associated with each core class to obtain a new group of API calls for a new class definition derived from the core class .

In some implementations to derive the plurality of API calls for configuring the cloud based deployment the cloud service provider derives the plurality of API calls based on the respective groups of API calls associated with one or more of the plurality of core classes from which the one or more classes of the configuration specification are derived and based on the plurality of protocols for modifying the respective groups of API calls.

In some implementations the plurality of protocols further includes rules for imposing an ordering of the groups of API calls according to dependency and connectivity relationships specified in class definitions written according to the object oriented specification language.

In the example process the cloud service provider or platform provider receives a respective definition submission from each of a plurality of definition suppliers . The respective definition submission includes one or more class definitions written in an object oriented specification language. Each class definition models a data or functional component of a cloud based deployment using a group of configurable class parameters and is extendable to create at least one new class definition by a modification to one or more of the group of configurable class parameters or an addition of one or more new class parameters. The cloud service provider or platform provider then provides a user interface that presents the class definitions received from the plurality of definition suppliers for review and selection by a plurality of definition users .

In the example process the cloud service provider receives a plurality of distinct configuration specifications written in the object oriented specification language . The plurality of distinct configuration specifications are each for configuring a distinct cloud based deployment and including a distinct class definition that extends from the same one of the class definitions received from the plurality of definition suppliers. Then the cloud service provider configures each of the distinct cloud based deployments based at least on the same one of the received class definitions and the distinct class definition that extends therefrom in the distinct configuration specification of the distinct cloud based deployment .

In the example process for each of the received class definitions the cloud service provider monitors usage of the class definition in a plurality of configuration specifications that have been used to configure a plurality of cloud based deployments . The cloud service provider records for each use of the class definition in the plurality of configuration specifications a credit to a definition supplier of the class definition and a charge to a definition user associated with the use .

In some implementations the usage of the class definition includes an instantiation of the class definition in a respective configuration specification that has been used to carry out a respective cloud based deployment. In some implementations the usage of the class definition includes an extension of the class definition to create a new class definition that is instantiated in a respective configuration specification used to carry out a respective cloud based deployment.

In the example process the cloud service provider or platform provider receives a software submission from a software supplier . The software submission includes a software application to be deployed in a cloud based environment and a plurality of distinct configuration specifications each for deploying the software application in the cloud based environment in a distinct manner. Then the cloud service provider or platform provider provides the plurality of distinct configuration specifications for review and selection by a software user .

In the example process the cloud service provider receives selection of one of the plurality of distinct configuration specification by the software user . The cloud service provider deploys the software application in the cloud based environment according to the selected distinct configuration specification . Then the cloud service provider records a charge to the software user and a credit to the software supplier based on a respective price associated the selected distinct configuration specification . In some implementations to provide the plurality of class definitions for selection the cloud service provider provides the respective performance metrics with each of the plurality of class definitions for user review in a selection user interface.

In the example process the cloud service provider provides a plurality of class definitions for selection . Each class definition models a respective data or functional component of a cloud based environment using a group of configurable class parameters. Each class definition supports instantiation and inheritance of the class definition in a configuration specification for a cloud based deployment. The cloud service provider also derives respective performance metrics associated with each of the plurality of class definitions based on aggregated performance of multiple cloud based deployments where the multiple cloud based deployments had been carried out according to respective configuration specifications that require instantiation of the class definition or a new class definition derived from the class definition . Then the cloud service provider utilizes the respective performance metrics associated with each of the plurality of class definitions in ranking the plurality of class definitions .

In the example process the cloud service provider categorizing the plurality of class definitions based on the respective data or functional components of the cloud based environment modeled by the plurality of class definitions . Then the cloud service provider ranks the plurality of class definitions within the class definitions respective categories .

In the example process for each of a plurality of class definitions the cloud service provider identifies a plurality of cloud based deployments that had been carried out according to respective configuration specifications that required instantiation of the class definition or at least one new class definition derived from the class definition . The cloud service provider monitors respective performances of the plurality of cloud based deployments . The cloud service provider then associates the respective performances of the plurality of deployments with the class definition .

When deriving respective performance metrics associated with each of a plurality of class definitions based on aggregated performance of multiple cloud based deployments the cloud service provider performs the example process . In the example process the cloud service provider for each of the plurality of class definitions identifies one or more data or functional components in the plurality of cloud based deployments that were configured according to the class definition or a new class definition derived from the class definition . The cloud service provider identifies one or more performance metrics associated with the identified one or more data or functional components . Then the cloud service provider derives the respective performance metrics associated with the class definition by aggregating the identified one or more performance metrics . In some implementations the performance metrics include one or more measures of latency reliability scalability availability or security.

In the example process for each class definition the cloud service provider tracks a respective count of cloud based deployments that have been configured at least in part according to the class definition . Optionally the cloud service provider tracks a respective count of problems encountered in cloud based deployments that have been configured at least in part according to the class definition. Optionally the cloud service provider also tracks a number of required changes to resolve the problems encountered in the cloud based deployments that have been configured at least in part according to the class definition. Then the cloud service provider utilizes the respective counts associated with the plurality of class definitions in the ranking of the plurality of class definitions . Optionally the cloud service provider also utilizes the respective counts of the problems and the respective numbers of required changes associated with the plurality of class definitions in the ranking of the plurality of class definitions.

In some implementations the respective numbers of required changes associated with the plurality of class definitions are used to calculate respective weights given to the respective performance metrics associated with the plurality of class definitions in ranking the plurality of class definitions.

Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry or in computer software firmware or hardware including the structures disclosed in this specification and their structural equivalents or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs i.e. one or more modules of computer program instructions encoded on a computer storage medium for execution by or to control the operation of data processing apparatus. Alternatively or in addition the program instructions can be encoded on a propagated signal that is an artificially generated signal e.g. a machine generated electrical optical or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. The computer storage medium can be a machine readable storage device a machine readable storage substrate a random or serial access memory device or a combination of one or more of them.

The term data processing apparatus encompasses all kinds of apparatus devices and machines for processing data including by way of example a programmable processor a computer or multiple processors or computers. The apparatus can include special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit . The apparatus can also include in addition to hardware code that creates an execution environment for the computer program in question e.g. code that constitutes processor firmware a protocol stack a database management system an operating system or a combination of one or more of them.

A computer program also known as a program software software application script or code can be written in any form of programming language including compiled or interpreted languages or declarative or procedural languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program may but need not correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data e.g. one or more scripts stored in a markup language document in a single file dedicated to the program in question or in multiple coordinated files e.g. files that store one or more modules sub programs or portions of code . A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.

The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by and apparatus can also be implemented as special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit .

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processors of any kind of digital computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for performing or executing instructions and one or more memory devices for storing instructions and data. Generally a computer will also include or be operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. However a computer need not have such devices. Moreover a computer can be embedded in another device e.g. a mobile telephone a personal digital assistant PDA a mobile audio or video player a game console a Global Positioning System GPS receiver or a portable storage device e.g. a universal serial bus USB flash drive to name just a few.

Computer readable media suitable for storing computer program instructions and data include all forms of nonvolatile memory media and memory devices including by way of example semiconductor memory devices e.g. EPROM EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory can be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user embodiments of the subject matter described in this specification can be implemented on a computer having a display device e.g. a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input. In addition a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user for example by sending web pages to a web browser on a user s user device in response to requests received from the web browser.

Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification or any combination of one or more such back end middleware or front end components. The components of the system can be interconnected by any form or medium of digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN and a wide area network WAN e.g. the Internet.

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

While this specification contains many specific implementation details these should not be construed as limitations on the scope of any invention or of what may be claimed but rather as descriptions of features that may be specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover although features may be described above as acting in certain combinations and even initially claimed as such one or more features from a claimed combination can in some cases be excised from the combination and the claimed combination may be directed to a subcombination or variation of a subcombination.

Similarly while operations are depicted in the drawings in a particular order this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order or that all illustrated operations be performed to achieve desirable results. In certain circumstances multitasking and parallel processing may be advantageous. Moreover the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.

Particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. For example the actions recited in the claims can be performed in a different order and still achieve desirable results. As one example the processes depicted in the accompanying figures do not necessarily require the particular order shown or sequential order to achieve desirable results. In certain implementations multitasking and parallel processing may be advantageous.

