---

title: Application access to native and bundled libraries
abstract: An application executing on a computing device may invoke a function call of a first function. The computing device may support a bundled application library of functions and a native library of functions. It may be determined that code for executing the first function exists in both the bundled application library and the native library, and the application may execute the first function using the code in the native library. While the application continues execution on the computing device, the application may invoke a function call of a second function. It may be determined that, of the bundled application library and the native library, the code for executing the second function exists in the bundled application library. The application may execute the second function using the code in the bundled application library.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09575737&OS=09575737&RS=09575737
owner: Google Inc.
number: 09575737
owner_city: Mountain View
owner_country: US
publication_date: 20160421
---
This application claims priority to U.S. patent application Ser. No. 14 620 647 filed Feb. 12 2015 which claims priority to U.S. provisional patent application No. 62 002 326 filed May 23 2014. Both applications are hereby incorporated by reference in their entirety.

Computing devices may incorporate one or more processors that execute machine code including code that implements an operating system OS . Machine code executed by a computing device may also include both application code developed either by the provider of the computing device or by a third party. To aid the development of applications application developers may use a software development kit SDK and or one or more application programming interfaces APIs that can be integrated into or accessed by applications that the developers create. An SDK may include a native library that provides the basic programming language functions on which application developers may rely.

Each version of an operating system may be shipped with a corresponding version of a native library. On a particular device such as a particular model of wireless communication device WCD or smartphone the native library may be arranged to provide streamlined or customized implementations designed specifically to execute rapidly and or efficiently on the particular device. Thus for instance if version A of a native library includes a graphics function func1 and the particular device includes a graphics co processor func1 may make use of the graphics co processor to improve its performance. However on a device that does not include a graphics co processor a different version of func1 may be deployed that uses the main processor instead. A goal of such an arrangement may be to provide application developers with the same APIs regardless of the physical hardware to which their applications are targeted.

As the operating system matures new versions of the native library may be provided. These new versions may include additional functionality improved performance and or improved hardware compatibility. In some cases for example version B of the native library may include func2 a function not available in version A of the native library. In order to provide func2 on computing devices that support version A of the native library applications may be compiled with or arranged to be linked to or otherwise use a bundled application library that contains func2 and potentially other functions as well.

The choice of whether to use a native library or a bundled application library has been an all or nothing situation. Thus an application can either use functions in the native library the bundled application library but not functions from both. While this arrangement enables functionality and backwards compatibility it can significantly reduce the performance of some functions. For instance suppose that the bundled application library includes a non customized version of func1 . If an application requires use of func2 on a computing device with version A of the native library the application might be required to use the bundled application library instead. Thus the application may use the non customized version of func1 from the bundled application library instead even if the computing device that the application is executing on supports the graphics co processor and the customized version of func1 in its native library.

Accordingly in a first embodiment an application executing on a computing device may invoke a function call of a first function. The computing device may support a bundled application library of functions and a native library of functions. It may be determined that code for executing the first function exists in both the bundled application library and the native library and the application may execute the first function using the code in the native library. While the application continues execution on the computing device the application may invoke a function call of a second function. It may be determined that of the bundled application library and the native library the code for executing the second function exists in the bundled application library. The application may execute the second function using the code in the bundled application library.

In a second example embodiment a native library may be provided with an operating system of a computing device. The native library may be represented in machine code of the computing device. A bundled application library may also be provided with an application configured to execute on the computing device. The bundled application library may be represented in intermediate code e.g. byte code . A first function may be supported by the both the bundled application library and the native library and a second function may be supported by the bundled application library but not supported by the native library. The application may be configured to execute the first function using the code in the native library and execute the second function using the code in the bundled application library.

A third example embodiment may include a non transitory computer readable storage medium having stored thereon program instructions that upon execution by a computing device cause the computing device to perform operations in accordance with the first and or second example embodiments.

A fourth example embodiment may include a computing device containing at least a processor and data storage. The data storage may include program instructions that when executed by the processor cause the computing device to perform operations in accordance with the first and or second example embodiments.

These as well as other embodiments aspects advantages and alternatives will become apparent to those of ordinary skill in the art by reading the following detailed description with reference where appropriate to the accompanying drawings. Further it should be understood that this summary and other descriptions and figures provided herein are intended to illustrate embodiments by way of example only and as such that numerous variations are possible. For instance structural elements and process steps can be rearranged combined distributed eliminated or otherwise changed while remaining within the scope of the embodiments as claimed.

Example methods devices and systems are described herein. It should be understood that the words example and exemplary are used herein to mean serving as an example instance or illustration. Any embodiment or feature described herein as being an example or exemplary is not necessarily to be construed as preferred or advantageous over other embodiments or features. Other embodiments can be utilized and other changes can be made without departing from the scope of the subject matter presented herein.

Thus the example embodiments described herein are not meant to be limiting. It will be readily understood that the aspects of the present disclosure as generally described herein and illustrated in the figures can be arranged substituted combined separated and designed in a wide variety of different configurations all of which are explicitly contemplated herein.

As one way of making computer application development simpler and more tractable common functions that multiple applications may perform can be provided in one or more separate libraries. These libraries may include source code intermediate code e.g. byte code or some form of object code or machine code of a processor or processing system. In this way these common functions can be developed and tested in an isolated environment and may be used by one or more applications. Consequently these applications need not implement functions that are found in the libraries.

A difference between a function implemented within an application and one in a library may be based on how the code of the application is organized. Library functions may be written in such a way that they can be used by multiple related or unrelated applications. On the other hand a function implemented within an application might only be able to be used by that particular application.

Library functions may have well defined interfaces sometimes referred to as library interfaces or APIs. The interface of a particular function may characterize the formats types and or quantities of input parameters taken by the function as well as the formats types and or quantities of output provided by the function. To use a library function an application developer need only know the function s interface s and not necessarily know the internal details of the function.

Applications may be linked to libraries in a static or dynamic fashion. Relevant functions from static libraries may be compiled into executable applications. Therefore those applications can use make use of the functions even if the application is executed on a platform that does on provide a library with the functions. The functions may be statically linked to the application by a linker program when the application is compiled from source and or object code.

Dynamic libraries on the other hand may be linked to applications at the beginning of or during the applications execution. The linker program may record what library routines the application uses and makes references to these routines in the appropriate dynamic libraries. The linker program may be part of the operating system or the application itself.

In some embodiments a particular native library e.g. a math library a string processing library or a graphics library may be provided with the operating system. A bundled version of this library may also be provided with applications that use functions found in that library. In this way applications can take advantage of native libraries that are potentially designed for enhanced performance on particular computing devices executing particular versions of the operating system. But when these applications are deployed on a computing device that does not support certain functions in its native libraries e.g. the computing device does not include the library or includes an older version of the native library that doesn t support the certain functions the applications may use the functions from their bundled libraries instead.

As an example consider a math library that contains a function sqrt that calculates the square root of a number. This function s interfaces may be defined as float sqrt float . This definition indicates that the function takes a floating point number as input and returns a floating point number as output. The function may be called from an application using the command y sqrt x where x and y are floating point variables. Thus for instance if x has a value of 4.0 in the application the function will return a value of 2.0 for assignment to y.

In some math libraries a sqrt function may be implemented algorithmically in software as a series of generic program steps. The advantage to doing so is that the sqrt function can be used on a wide variety of computing systems. But the disadvantage of this approach is that the performance of the sqrt function is likely to be slow.

On computing devices with specialized hardware such as a mathematics co processor a native platform specific sqrt function may be used instead. This sqrt function may use the co processor s built in mathematical abilities to perform the square root calculations. In some cases this might entail the co processor using machine code large pre calculated tables and or parallel calculations to speed up the rate at which the sqrt operates.

Therefore it may be advantageous for an application to be linked to and use a native sqrt function when such a function is available. But in order to provide a sqrt function on a wide variety of computing devices including those without such platform specific functions a generic software based sqrt function may be available in some math libraries bundled with applications.

In general for each type of library e.g. math string processing graphics etc. an application can only be linked to one version of this library. In some implementations doing otherwise could potentially cause a linking error because an application would not know which library s version of a given math function to use.

To that point suppose that the native math library does not contain sine and cosine functions but the application s bundled math library does contain these functions and the application uses these functions. Then the application will be linked to the bundled math library and use this library exclusively for its supported math functions. For instance if the application uses the square root function it will use the square root function of the bundled math library rather than that of the native library.

Since application calls functions that are not defined in native library application may be linked with bundled application library . This may result in application using generic non customized variations of these functions. On the other hand since native library supports the function called by application application may be linked with native library . This may result in application having access to a customized version of the sqrt function but no access to math functions such as sin and cos not supported by native library .

Herein the terms customize customized and customization may refer to ways in which software can be made operate more efficiently and or in a more desirable fashion on a particular computing device or class of computing devices. These terms do not imply that the most efficient implementation or the best possible performance is obtained only that the software has been specialized in some fashion.

The embodiments herein may facilitate an application using functions from two different versions of a particular library. For instance the application may be bundled with a generic version of the particular library and may invoke one or more functions in this bundled application library. The application may also have access to a native version of the library and may also invoke one or more functions in this library as well.

As an example depicts an application that calls functions func1 and func2 . Application is linked to bundled application library which defines func1 and func2 . Thus these functions may be executed by using the code in bundled application library . However native library is another version of the same library as bundled application library but only defines func1 .

Possibly to utilize advantages associated with the implementation of func1 in native library application may invoke directly or indirectly func1 in native library . However since func2 is not defined in native library application may invoke func2 in bundled application library .

For instance native library function table may contain a list of functions supported by native library . Thus native library function table may contain an entry for func1 possibly amongst other entries. However native library function table might not contain an entry for func2 .

In a possible embodiment application calls func1 which invokes func1 in bundled application library . Bundled application library looks up func1 in native library function table and determines that func1 is supported in native library . Then bundled application library invokes func1 in native library . Application also calls func2 which invokes func2 in bundled application library . Bundled application library looks up func2 in native library function table and determines that func2 is not supported in native library . Accordingly bundled application library runs func2 . Results of both functions may be passed back to application .

The applications and libraries of may operate on or be supported by one or more computing devices. These computing devices may be organized in a standalone fashion in cloud based networked computing environments or in other arrangements. Non limiting examples are provided in the next section.

Each of applications and may include instructions that when executed cause computing device to perform specific tasks or functions. Applications and may be native applications i.e. installed by a manufacturer of computing device and or a manufacturer of operating system or may be third party application installed by a user of computing device after purchasing the computing device.

A non exhaustive list of example applications includes a media player application that accepts media files as inputs and generates corresponding video and or audio to the output device s an e reader application which accepts electronic documents books magazines etc. as input and presents the content of the document via the output device s a feed reader that accepts feeds delivered over the Internet e.g. RSS feeds and or feeds from social network sites as input and presents the feeds via the output device s a map application that displays a map via the output device s a note taking application a bookmarking application and a word processing spreadsheet and or presentation application that accepts specifically formatted files as inputs and presents them via the output devices for viewing and or editing.

Operating system may interact with and manage hardware to provide services for applications and . For example application may request that operating system direct an integrated camera of hardware to capture a visual image and that hardware store the image to memory.

Hardware may include for example a central processing unit CPU a graphics processing unit GPU memory an input output I O interface user input device s output device s or other sensors. Components of hardware may be controlled by instructions contained in applications and and operating system .

The CPU may be configured to effectuate the operation of the computing device by executing instructions stored in memory or disk storage. Such instructions may include the operating system and the applications and . The CPU may for example comprise a single or multi core processor an application specific integrated circuit ASIC field programmable gate array FPGA and or any other suitable circuitry.

The GPU may be operable to generate a video stream for output to the screen based on instructions and or data received from the CPU. That is data structures corresponding to images to be displayed on the screen may be stored to and read from the memory or disk storage by the CPU. The CPU may convey such data structures to the graphics processor via a standardized API such as for example Standard Widget Toolkit SWT the DirectX Video Acceleration API the Video Decode Acceleration Framework API or another suitable API.

The memory may include program memory and run time memory. The memory may for example comprise non volatile memory volatile memory read only memory ROM random access memory RAM flash memory magnetic storage and or any other suitable memory which may be non transitory media . Program memory may store instructions executable by the CPU to effectuate operation of operating system and applications and . Runtime memory may store data generated or used during execution of operating system or applications and

The input output I O interface may be operable to receive signals from the input device s and provide corresponding signals to the CPU and or the GPU for example. The input device s may include for example a mouse a touchpad a motion sensor a trackball a voice recognition device a keyboard or any other suitable input device which enables a user to interact with computing device . The output devices may include for example a screen and speakers. The screen may be for instance a liquid crystal display LCD screen an organic light emitting diode OLED screen an e ink screen and or any other suitable device for presenting a graphical user interface.

Kernel may include drivers that enable software such as the operating system and applications to interact with input output devices. Kernel may also include power management processes that coordinate hardware power usage and provide alerts when an integrated battery is running low on power for example. Kernel may also provide memory management and process scheduling functions.

Libraries may include several subcomponents such as media framework graphics library and OpenGL ES . Media framework may include functionality that supports standard video audio and still frame formats. Graphics library may support two dimensional graphics rendering. OpenGL ES may support gaming and three dimensional graphics rendering.

Operating system runtime may include core system libraries and virtual machines . Virtual machines may be custom virtual machines that run a customized file format. Virtual machines may be used with an embedded environment since virtual machines use runtime memory efficiently implement a CPU optimized byte code interpreter and support multiple virtual machine processes per device.

Application libraries may include libraries for view system resource manager and content providers . These application libraries may provide support for applications . Application libraries may also include SDKs and app compatibility both of which may be associated with or used by applications to perform functions of the applications . Either core system libraries application libraries or both may be considered native libraries.

SDKs may further adapt applications to be able to communicate with one or more pieces of code or functions in operating system . As an example an application may incorporate an SDK that may adapt the application to be able to communicate with one or more content servers. A content server may provide advertisements and the content SDK may include information about where to get the advertisements for example an address of the content server.

Applications may include any number of applications and examples include dialer messaging and browser . Dialer may provide functionality related to placing or receiving phone calls. Messaging may provide functionality related to receiving and sending messages such as email voice mail or text messages. Browser may provide functionality related to sending or receiving information via the World Wide Web. Many other types of applications exist as well and may be downloaded and installed on a computing device.

System services may include status bar application launcher and package manager . Status bar may provide functionality related to providing system notifications. Application launcher may provide functionality related to organization and execution of applications . Package manager may maintain information for installed applications .

In application bundled application library native library function table and native library may be stored on and or configured to operate on a particular computing device. Native library function table and native library may be separate modules or combined in the same module. In distributed environments some of these components may be on different computing devices and may communicate with one another for instance over a network.

In application is linked to bundled application library and bundled application library is in communication with native library . In this way application may be able to invoke functions in both of these versions of the particular library. Native library function table may include a list of functions supported by native library and possibly references to the locations of these functions in memory.

At step application may invoke function func1 . For instance application may call this function with zero or more parameters. Bundled application library may support func1 and may be able to run func1 to provide a result to application . However if bundled application library is a generic version of the particular function it may be beneficial to determine whether another version of func1 exists in native library . For instance such a native version of func1 may be customized for operation on the computing device.

Thus at step bundled application library may query native library function table for func1 . At step native library function table may indicate to bundled application library that native library supports func1 .

Then at step bundled application library may invoke func1 in native library . For instance bundled application library may call func1 with the same more or fewer parameters as were used in step . In response to this invocation native library may run func1 with these parameters. At step the results of running func1 may be provided to bundled application library and at step these results may be provided to application . The results may include any changes to parameters made by native library and or the determination of a return value.

In some cases like the one encompassing steps the presence of a function in a particular library may be checked for in both a bundled application library and a native library but preference may be given to the version supported by the native library. In other cases preference may be given to the version in the bundled application library. For instance in some cases the implementation of the function in the native library may have known limitations or defects and the version in the bundled application library may overcome these limitations or defects. Therefore any performance degradation due to using the version of the function in the bundled application library may be offset by its greater reliability or robustness. Alternatively the function might not be supported in the native library.

While application is still running and perhaps while func1 is being invoked at step application may invoke func2 . Application may call this function with zero or more parameters. Bundled application library may support func2 and may be able to run func2 to provide a result to application . However as was the case for func1 it may be beneficial to determine whether another version of func2 exists in the native version of the library.

Thus at step bundled application library may query native library function table for func2 . At step native library function table may indicate to bundled application library that native library does not supports func2 .

In this case bundled application library may run func2 with the provided parameters. At step the results of running func2 may be provided to application . The results may include any changes to parameters made by bundled application library and or the determination of a return value.

In application bundled application library bundled application library function table and native library may be stored on and or configured to operate on a particular computing device. Bundled application library and bundled application library function table may be separate modules or combined in the same module. In distributed environments some of these components may be on different computing devices and may communicate with one another for instance over a network.

In application is linked to native library and native library is in communication with bundled application library . In this way application may be able to invoke functions in both of these versions of the particular library. Bundled application library function table may include a list of functions supported by bundled application library and possibly references to the locations of these functions in memory.

At step application may invoke function func3 . For instance application may call this function with zero or more parameters. Native library may support func3 and may be able to run func3 to provide a result to application . Alternatively native library might not support func3 . Regardless it may be beneficial to determine whether another version of func3 exists in bundled application library . For instance in some cases the version of the function in bundled application library may support more features than the one in native library or may be more reliable or robust.

Thus at step native library may query bundled application library function table for func3 . At step bundled application library function table may indicate to native library that bundled application library supports func3 . In some embodiments bundled application library function table may also contain information that helps native library determine whether to run its own version of func3 . This information may include for example a version number for the version of func3 supported by bundled application library .

At step native library may invoke func3 in bundled application library . For instance native library may call func3 with the same more or fewer parameters as were used in step . In response to this invocation bundled application library may run func3 with these parameters. At step the results of running func3 may be provided to native library and at step these results may be provided to application . The results may include any changes to parameters made by bundled application library and or the determination of a return value.

While application is still running and perhaps while func3 is being invoked at step application may invoke func4 . Application may call this function with zero or more parameters. Native library may support func4 and may be able to run func4 to provide a result to application . However as was the case for func3 it may be beneficial to determine whether another version of func4 exists in bundled application library .

Thus at step native library may query bundled application library function table for func4 . At step bundled application library function table may indicate to native library that bundled application library does not support func4 .

In this case native library may run func4 with the provided parameters. At step the results of running func4 may be provided to application . The results may include any changes to parameters made by bundled application library and or the determination of a return value.

For the operations illustrated by the communication between bundled application library and native library may involve passing data and or references to data between these libraries. For instance at step when bundled application library invokes func1 in native library bundled application library may provide a reference to or a copy of the data stored in each parameter passed to func1 . Similarly at step when native library invokes func4 in bundled application library native library may provide a reference to or a copy of the data stored in each parameter passed to func4 .

In situations where a reference e.g. a pointer to the data is passed as a parameter the library that runs the function may manipulate the data via the pointer. In the case where a copy of the data is passed the library that runs the function may manipulate the copy of the data directly and may pass the manipulated copy back to the invoking function. The invoking function may then replace the original version of the data with at least some of the copy.

Furthermore either or both of bundled application library and native library may be represented in byte code. In some implementations byte code may form an instruction set that can be executed by a software interpreter. Byte code may be executed by a virtual machine by parsing and directly translating the byte code instructions into machine language at runtime. Often referred to as just in time compilation the virtual machine may be specific to a particular type of computing device but the byte code may maintain its portability between different types of computing devices. Examples of programming languages that may use byte code based virtual machines are Java Python and PHP.

At block an application executing on a computing device may invoke a function call of a first function. The computing device may support a bundled application library of functions and a native library of functions. The bundled application library may be represented in intermediate code and the native library may be represented in machine code of the computing device. The bundled application library may be provided with the application and the native library may be provided with the operating system of the computing device. In some embodiments the bundled application library and the native library may be different versions of the same library and may define at least some of the same functions.

At block it may be determined that code for executing the first function exists in both the bundled application library and the native library. At block possibly in response to determining that code for executing the first function exists in both the bundled application library and the native library the first function may be executed using the code in the native library. Executing the first function may involve linking by a linker application executing on the computing device the application with at least some of the machine code of the native library.

At block while the application continues execution on the computing device the application may invoke a function call of a second function. At block it may be determined that of the bundled application library and the native library the code for executing the second function exists in the bundled application library. For instance the second function might not be defined or supported by the native library.

At block in response to determining that of the bundled application library and the native library the code for executing the second function exists in the bundled application library the second function may execute using the code in the bundled application library. In some embodiments executing the second function using the code in the bundled application library may involve compiling by a just in time compiler application executing on the computing device the intermediate code into a unit of machine code and linking by a linker application executing on the computing device the application with at least part of the unit of machine code.

Determining that code for executing the first function exists in both the bundled application library and the native library may involve passing invocation of the function call of the first function to the bundled application library. The bundled application library may determine that code for executing the first function exists in the bundled application library. The bundled application library may query a function table associated with the native library and then receive an indication that the first function exists in the function table.

Determining that of the bundled application library and the native library the code for executing the second function exists in the bundled application library may involve passing invocation of the function call of the second function to the bundled application library. The bundled application library may determine that code for executing the second function exists in the bundled application library. The bundled application library may query the function table associated with the native library and receive an indication that the second function does not exist in the function table.

Alternatively determining that code for executing the first function exists in both the bundled application library and the native library may involve passing invocation of the function call of the first function to the native library. The native library may determine that code for executing the first function exists in the native library. The native library may query a function table associated with the bundled application library and then receive an indication that the first function exists in the function table and that the function table indicates that the first function in the bundled application library is compatible with the first function in the native library.

Further determining that of the bundled application library and the native library the code for executing the second function exists in the bundled application library may involve passing invocation of the function call of the second function to the native library. The native library may determine that code for executing the second function does not exist in the native library. The native library may query the function table associated with the bundled application library and then receive an indication that the second function exists in the function table.

Executing the first function using the code in the native library may involve requesting by the bundled application library access to data associated with the first function. The data may be accessible to the native library. The bundled application library may receive a pointer to the data from the native library modify the data via the pointer and release access to the data. Alternatively executing the first function using the code in the native library may involve requesting by the bundled application library access to data associated with the first function. The data may be accessible to the native library. The bundled application library may receive a copy of the data from the native library modify the copy of the data and provide the copy of the data to the native library.

Moreover a computing device such as computing device may be configured to support the process illustrated by . For instance the computing device may include a native library provided with an operating system of the computing device. In some embodiments the native library may be represented in machine code of the computing device.

The computing device may also be configured to support a bundled application library provided with an application configured to execute on the computing device. The bundled application library may be represented in intermediate code. A first function may be supported by the both the bundled application library and the native library and a second function may be supported by the bundled application library but not supported by the native library.

The computing device may also be configured to support the application. The application in turn may be configured to execute the first function using the code in the native library and to execute the second function using the code in the bundled application library.

The present disclosure is not to be limited in terms of the particular embodiments described in this application which are intended as illustrations of various aspects. Many modifications and variations can be made without departing from its scope as will be apparent to those skilled in the art. Functionally equivalent methods and apparatuses within the scope of the disclosure in addition to those enumerated herein will be apparent to those skilled in the art from the foregoing descriptions. Such modifications and variations are intended to fall within the scope of the appended claims.

The above detailed description describes various features and functions of the disclosed systems devices and methods with reference to the accompanying figures. The example embodiments described herein and in the figures are not meant to be limiting. Other embodiments can be utilized and other changes can be made without departing from the scope of the subject matter presented herein. It will be readily understood that the aspects of the present disclosure as generally described herein and illustrated in the figures can be arranged substituted combined separated and designed in a wide variety of different configurations all of which are explicitly contemplated herein.

With respect to any or all of the message flow diagrams scenarios and flow charts in the figures and as discussed herein each step block and or communication can represent a processing of information and or a transmission of information in accordance with example embodiments. Alternative embodiments are included within the scope of these example embodiments. In these alternative embodiments for example functions described as steps blocks transmissions communications requests responses and or messages can be executed out of order from that shown or discussed including substantially concurrent or in reverse order depending on the functionality involved. Further more or fewer blocks and or functions can be used with any of the ladder diagrams scenarios and flow charts discussed herein and these ladder diagrams scenarios and flow charts can be combined with one another in part or in whole.

A step or block that represents a processing of information can correspond to circuitry that can be configured to perform the specific logical functions of a herein described method or technique. Alternatively or additionally a step or block that represents a processing of information can correspond to a module a segment or a portion of program code including related data . The program code can include one or more instructions executable by a processor for implementing specific logical functions or actions in the method or technique. The program code and or related data can be stored on any type of computer readable medium such as a storage device including a disk hard drive or other storage medium.

The computer readable medium can also include non transitory computer readable media such as computer readable media that store data for short periods of time like register memory processor cache and random access memory RAM . The computer readable media can also include non transitory computer readable media that store program code and or data for longer periods of time. Thus the computer readable media may include secondary or persistent long term storage like read only memory ROM optical or magnetic disks compact disc read only memory CD ROM for example. The computer readable media can also be any other volatile or non volatile storage systems. A computer readable medium can be considered a computer readable storage medium for example or a tangible storage device.

Moreover a step or block that represents one or more information transmissions can correspond to information transmissions between software and or hardware modules in the same physical device. However other information transmissions can be between software modules and or hardware modules in different physical devices.

The particular arrangements shown in the figures should not be viewed as limiting. It should be understood that other embodiments can include more or less of each element shown in a given figure. Further some of the illustrated elements can be combined or omitted. Yet further an example embodiment can include elements that are not illustrated in the figures.

While various aspects and embodiments have been disclosed herein other aspects and embodiments will be apparent to those skilled in the art. The various aspects and embodiments disclosed herein are for purposes of illustration and are not intended to be limiting with the true scope being indicated by the following claims.

