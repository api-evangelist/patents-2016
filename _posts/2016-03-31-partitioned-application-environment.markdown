---

title: Partitioned application environment
abstract: A partitioned application environment is disclosed. In various embodiments, a request associated with an application environment in which an application is running is received from the application. A determination is made to fulfill the request at least in part via a call to a node at which application code associated with the application is running in an application environment partition provided at the node. A call associated with the request is sent to the node, based at least in part on the determination.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09465677&OS=09465677&RS=09465677
owner: MOBILE IRON, INC.
number: 09465677
owner_city: Mountain View
owner_country: US
publication_date: 20160331
---
This application is a continuation of co pending U.S. patent application Ser. No. 13 922 077 entitled PARTITIONED APPLICATION ENVIRONMENT filed Jun. 19 2013 which claims priority to U.S. Provisional Patent Application No. 61 662 162 entitled LOAD BALANCING OF A VIRTUALIZED PARTITIONED APPLICATION ENVIRONMENT AND ITS ADMINISTRATION VIA A MANAGEMENT CONSOLE filed Jun. 20 2012 both of which are incorporated herein by reference for all purposes.

The most common way in which an end user interacts with a computing device is through applications. Applications are packaged into application binaries which are serialized representations of the application s programming logic. Operating systems OSs provide an application environment AE or a set of AEs one of which is used when the end user instructs the OS to launch an application binary. The choice of which AE to use and how to deploy the application binary within it is usually the task of a specialized OS component called a loader.

The loader on instruction from the OS will attempt to retrieve the application binary from one of the OS services that manages serialized media. Typical serialized media can be physical storage devices eg floppy disks hard drives ROMs CDROMs etc. networked components and services eg network storage application stores etc. or local system non persistent resources such as main memory eg RAM and other form of caches. The loader then attempts to deserialize the application binary into a storage area designated for execution by the OS. This storage area is typically called a process and is budgeted a set of resources eg virtual address space CPU time etc. by the OS. On a successful deserialization operation by the loader and execution of the process by the OS the application binary becomes an application that is evident to the end user.

Once an application has been started it will attempt to consume resources provisioned to it by the OS. Certain resources are privileged and cannot be directly consumed by the application as they fall under the authority of the OS or a delegated authority DA of the OS. An example of such resource ownership is the Graphical User Interface GUI subsystem which typically is managed by an application called the Window Manager WM in the Microsoft Windows OS and is appointed by the OS as the DA for GUIs. In order to use these types of resources an application must interact with the owning DA WM in the case of GUI resources via an OS gateway known as the Application Programming Interface API . This gateway provides a fundamental abstraction for the OS and DA to manage and arbitrate privileged resources.

The set of resources available to be used by an application which typically includes both resources that can be consumed directly and those accessed via APIs is termed as the Application Environment AE . A compatible AE is fundamental to running any application on a given OS.

Application Environments AE have been virtualized in two ways. In one approach of the host operating system OS that provides the specified AE is virtualized. This is typically done with a system hypervisor that uses a combination of hardware and software to replicate the physical machine specification for the OS into a virtual machine. Note that there are at least two OS instances running concurrently in this model. In a second approach emulation is used to translate the specified AE into that of another which uses a different OS. Note that there are no virtual machines in this model and only one OS is running.

The invention can be implemented in numerous ways including as a process an apparatus a system a composition of matter a computer program product embodied on a computer readable storage medium and or a processor such as a processor configured to execute instructions stored on and or provided by a memory coupled to the processor. In this specification these implementations or any other form that the invention may take may be referred to as techniques. In general the order of the steps of disclosed processes may be altered within the scope of the invention. Unless stated otherwise a component such as a processor or a memory described as being configured to perform a task may be implemented as a general component that is temporarily configured to perform the task at a given time or a specific component that is manufactured to perform the task. As used herein the term processor refers to one or more devices circuits and or processing cores configured to process data such as computer program instructions.

A detailed description of one or more embodiments of the invention is provided below along with accompanying figures that illustrate the principles of the invention. The invention is described in connection with such embodiments but the invention is not limited to any embodiment. The scope of the invention is limited only by the claims and the invention encompasses numerous alternatives modifications and equivalents. Numerous specific details are set forth in the following description in order to provide a thorough understanding of the invention. These details are provided for the purpose of example and the invention may be practiced according to the claims without some or all of these specific details. For the purpose of clarity technical material that is known in the technical fields related to the invention has not been described in detail so that the invention is not unnecessarily obscured.

A partitioned application environment AE is disclosed. In various embodiments an AE is split partitioned effectively into two or more AEs which are used in coordination to provide access to an application and the functionality the application embodies to an end user of the application.

In various embodiments a logically partitioned AE that enables compute workloads of a contained application to be distributed across various logical and physical entities is disclosed. In various embodiments the partitioned environment may span a plurality of networked computing nodes and a plurality of Operating Systems each deployed on a unique computing node.

For example an AE may in some embodiments be split into two sometimes herein designated as AE and AE for example one of which executes in the intended host OS AE e.g. an app written by an app developer for mobile devices having a particular OS and the other which executes in by way of example but not limited to a server OS AE . Each split AE may be run either within a virtual machine or on a physical machine. In yet another example an AE can be split into two AE and AE for example where a first application environment AE executes on the host OS but related application environments used to provide the application AE could be split into further AEs such as AE to AE n and cumulatively all these AE s still function to provide one application. The execution of the AEs e.g. the split AEs in a controlled and coordinated manner provide the environment under which application binaries may be deployed.

In the examples shown in the AE has been split between two or more AEs each of which is designated a specific role. In other embodiments the division of work across AEs may be determined dynamically for example based on dynamic determinations of resource availability current workload current capacity etc. In either approach to an Application deployed within this AE set the AE set appears as a singular homogeneous AE no different from that for which the Application was originally designed for.

By way of example consider an application designed for the Microsoft Windows OS. A typical application for this OS is written using the Win32 API and the C programming language. At its simplest form an application written for the Win32 API involves initializing its own internal state services and data structures and then interfacing with the Win User function set provided by the Win32 API to construct Windowing objects. The sequence for creating a trivial window is by invoking the RegisterClassEx routine followed by a Create Window and ShowWindow routine. This allows the application to instruct the WM to allocate internal data structures to track the newly created window create a visual object for the computer screen and display it.

This Application may be run in an AE that is split along the API interface boundary. The API interface boundary is an example of one possible split point that can be used to divide an AE. For the purposes of illustration the above example of a Win32 Application can be split along the Dynamic Link Library DLL boundary to produce the an AE that can run on the server AE using any OS and a corresponding AE that talks to the Microsoft Windows OS instance AE . Communication between the two AEs can be facilitated by using standard Inter Process Communication IPC see Remote Procedure Calls RPC see FIG. A or any other service which provides a logical connection and preserves the illusion to the application of a homogeneous Win32 API AE.

In various embodiments the remote AEs AE in the AE set can be intelligently placed across nodes in a network in order to address various use cases. For example in order to preserve a native user experience the set of function calls in an API that constitute GUI functionality can be bundled into an AE that can be placed in close proximity to the end user. This is illustrated by where the client provides AE and the server provides AE . Depending on various policy decisions such as but not limited to security network bandwidth consumption etc. the Distributed Load Balancer DLB may decide to position an AE at different points in a network topology. The decision to position an AE at any network location can be either a static decision immutable after the user launches the application or dynamic based on a set of variables and circumstances that occur when the application is running .

In the example shown in application data may be stored in data storage associated with nodes represented by node . Data may be accessed for example by an application instance executing in AE and results of the processing thereof may be caused to be displayed to an associated end user of a client device such as client device or client device .

In various embodiments and examples described herein an application is partitioned to have a first application partition realized on a server side application environment and a second application partition realized on a corresponding client side application environment. For example a user interface and other user experience related aspects of the application may be realized by application code running in a client side application environment while backend processing data access from an external or other data storage system etc. may be performed by application code running in a corresponding server side application environment. However in various embodiments using techniques disclosed herein an application may be partitioned across any two or more nodes with various corresponding application partitions being realized on the respective nodes by application code running in an associated application environment on that node.

In some embodiments techniques described herein may be used to facilitate simultaneous and or otherwise collaborative use of application data. The application data may reside at and be modified by application code running in a server side application environment for example and an application hypervisor at the server may facilitate collaborative access to and or modification of the application data e.g. document or other content data by multiple users each interacting with the application via a user experience portion of the application executing in an application environment partition provided at a client system being used by that user. In various embodiments an application hypervisor at the server may be configured to broker access to the content including by resolving any conflicts between actions taken by the different users e.g. by implementing conflict resolution logic user specified policies etc.

Referring further to the server includes a LINUX or other operating system kernel a POSIX compatibility layer a user space GNU runtimes and user interface library . An application hypervisor running on the aforementioned stack in various embodiments emulates an application environment AE with which the application is associated. In various embodiments the application hypervisor includes software code that when executed makes remoting decisions with respect to the application. Server side remoting services enable remote calls to be communicated to the client device and or enables remote calls sent to the server to be received and processed. Application comprises application binary executing in an emulated AE provided at the server . User experience elements enable certain user experience related processing to be performed at server .

In various embodiments applications may utilize some form of user identification tracking for example iOS and Android have a Unique Device Identifier UDID for each physical device. This may raise security concerns about user tracking based on the physical device s identification. In various embodiments application deployment as disclosed herein resolves this issue. Instead of providing a single fixed binary a one time application token is embedded in some embodiments into a small binary under a megabyte that is tied to the user installing the application. A token is uniquely generated for each thin application client that the user downloads to their device. Once the client is launched it checks to see if a device token is found within the secure storage of the device. If it is not found then the client provides its embedded application token to an authentication server which generates a unique device token which is returned to the client and stored in the secure storage on the device. This device token is used to securely identify and authenticate the device to all services going forward.

In some embodiments of this authentication model the user initially sends a request to the Enterprise Application Store EAS to download the thin client application. The EAS then retrieves the template thin application binary from data storage. It then generates a unique Application Token for the request and injects it along with other useful data into the binary. The thin application binary is digitally signed then returned to the initial request for the application and loaded onto the user s device. Once the application is launched the application will check the secure storage for a Secure Token . If a Secure Token is not found then the application will send the user s credentials plus the embedded Application Token to the assigned server over a secure connection. The server then validates the user based on the user s credentials as well as validates the Application Token . If the Application Token is valid the server then generates a Secure Token and stores this for future processing. The server then sends this Secure Token back to the application over secure connection. The application then stores this Secure Token in the device s secure storage for future processing requests. The application then interacts with the server as needed.

The benefit of this token authentication in some embodiments is that it securely identifies enrolled devices as belonging to a user without relying on system provided credentials which are available to other applications on the device preventing many potential spoofing attacks against the system.

A partitioned application environment and an infrastructure and techniques to provide same have been disclosed. In various embodiments processing to realize an application and associated functionality may be performed across two or more AE partitions which present themselves to the application with the aid of an application hypervisor on a server side and or an application partition manager on a client device as a single homogeneous application environment. Use of such an architecture to provide access to and use of mobile or other applications as a service and or to maintain synchronization between multiple instances of a stored application object such as a file have been described.

Although the foregoing embodiments have been described in some detail for purposes of clarity of understanding the invention is not limited to the details provided. There are many alternative ways of implementing the invention. The disclosed embodiments are illustrative and not restrictive.

