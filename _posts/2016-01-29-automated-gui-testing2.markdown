---

title: Automated GUI testing
abstract: The invention relates to a computer system that may include a processor, an accessibility API, a GUI, and a test module. The test module may use the accessibility API for analyzing GUI elements of the GUI and for automatically identifying GUI element features and inter-GUI-element dependencies. The test module may use the GUI element features and inter-GUI-element dependencies to generate a graph. The test module may traverse the graph and analyzes the GUI element features assigned to each currently accessed node or said node's child or sibling node. Thereby, the test module may identify predefined GUI element patterns in the graph and in the GUI. In case a matching GUI element pattern was identified, the test module may automatically identify one or more test routines associated with the identified GUI element pattern and automatically perform the one or more identified test routines on the GUI.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09600401&OS=09600401&RS=09600401
owner: International Business Machines Corporation
number: 09600401
owner_city: Armonk
owner_country: US
publication_date: 20160129
---
The present invention relates to the testing of software and more specifically to the testing of graphical user interfaces GUIs .

Software applications typically include various modules implementing business logic and include a graphical user interface allowing a user to interact with that business logic e.g. by entering text via a keyboard or applying a mouse click on elements of the graphical interface. Before a program is released to the public it typically requires extensive testing in order to ensure that the business function modules as well as the GUI operate correctly and reliably. GUI testing is complex and time consuming a software developer requires domain knowledge in order to create appropriate GUI test scenarios that cover all possible user actions or combination of user actions on said GUI. To execute such scenarios manually is highly time consuming. Often only a small fraction of the theoretically possible combinations and sequences of actions can be tested. On the other hand automated GUI tests are highly inflexible. Development cycles in general have become shorter in particular in agile software development and software builds are often scheduled on a daily or even hourly basis. In such an agile testing scenario specifying testing scripts is often not feasible as said scripts may become outdated within hours.

It is an objective of the present invention to provide for an improved system method and computer program product for performing GUI tests as specified in the independent claims. Embodiments of the invention are given in the dependent claims. Embodiments of the present invention can be freely combined with each other if they are not mutually exclusive.

According to one embodiment a method for automatically testing a graphical user interface GUI is provided. The method may include using by a test module an accessibility application programming interface API for analyzing a plurality of GUI elements of the GUI and for automatically identifying a plurality of GUI element features and a plurality of inter GUI element dependencies. The method may also include using by the test module the plurality of identified GUI element features and the plurality of identified inter GUI element dependencies for automatically generating a graph of a plurality of nodes whereby each node within the plurality of nodes represents a GUI element of the GUI and having assigned the plurality of identified GUI element features and the plurality of identified inter GUI element dependencies of the GUI element is represented by each node. The method may further include traversing by the test module the generated graph thereby automatically analyzing the plurality of identified GUI element features assigned to at least one of each currently accessed node and any child node or any sibling node of the currently analyzed node for identifying a plurality of GUI element patterns whereby a GUI element pattern is a predefined set of one or more nodes having at least one of a plurality of assigned predefined GUI element features and being a predefined set of two or more nodes representing a plurality of GUI elements linked to each other by a predefined functional dependency. The method may also include in case a GUI element pattern was identified that matches a set of one or more nodes of the generated graph automatically identifying by the test module one or more test routines associated with the identified GUI element pattern. The method may also include automatically performing by the test module the one or more identified test routines on the plurality of analyzed GUI elements in the GUI represented by the plurality of nodes matching the GUI element pattern.

According to another embodiment a computer program product for automatically testing a GUI is provided. The computer program product may include one or more computer readable storage devices and program instructions stored on at least one of the one or more tangible storage devices the program instructions executable by a processor. The computer program product may include program instructions to use by a test module an accessibility application programming interface API for analyzing a plurality of GUI elements of the GUI and for automatically identifying a plurality of GUI element features and a plurality of inter GUI element dependencies. The computer program product may also include program instructions to use by the test module the plurality of identified GUI element features and the plurality of identified inter GUI element dependencies for automatically generating a graph of a plurality of nodes whereby each node within the plurality of nodes represents a GUI element of the GUI and having assigned the plurality of identified GUI element features and the plurality of identified inter GUI element dependencies of the GUI element represented by each node. The computer program product may further include program instructions to traverse by the test module the generated graph thereby automatically analyzing the plurality of identified GUI element features assigned to at least one of each currently accessed node and any child node or any sibling node of the currently analyzed node for identifying a plurality of GUI element patterns whereby a GUI element pattern is a predefined set of one or more nodes having at least one of a plurality of assigned predefined GUI element features and being a predefined set of two or more nodes representing a plurality of GUI elements linked to each other by a predefined functional dependency. The computer program product may also include in case a GUI element pattern was identified that matches a set of one or more nodes of the generated graph program instructions to automatically identify by the test module one or more test routines associated with the identified GUI element pattern. The computer program product may further include program instructions to automatically perform by the test module the one or more identified test routines on the plurality of analyzed GUI elements in the GUI represented by the plurality of nodes matching the GUI element pattern.

In yet another aspect the invention relates to a computer system that includes a processor an accessibility API a GUI and a test module. The GUI includes data objects executable by the processor. The test module includes instructions executable by the processor. The execution of the instructions by the processor may cause the system to use the accessibility API for analyzing GUI elements of the GUI and for automatically identifying GUI element features and inter GUI element dependencies. The execution of the instructions by the processor may also cause the system to traverse the graph thereby automatically analyzing the GUI element features assigned to each currently accessed node and or assigned to any child or sibling node of the currently analyzed node for identifying GUI element patterns a GUI element pattern being a predefined set of one or more nodes having assigned predefined GUI element features and or being a predefined set of two or more nodes representing GUI elements linked to each other by a predefined functional dependency. The execution of the instructions by the processor may further cause the system to in case a GUI element pattern was identified that matches a set of one or more nodes of the graph automatically identify one or more test routines associated with the identified GUI element pattern. The execution of the instructions by the processor may also cause the system to automatically perform the one or more identified test routines on the GUI elements in the GUI represented by the nodes matching the GUI element pattern.

Embodiments of the invention may have the advantage that a method for automatically testing graphical user interfaces is provided that this capable to rapidly and automatically adapt to any change introduced into a GUI. Although accessibility APIs where originally designed to enable people with disabilities to use the computer embodiments of the current invention use an accessibility API for a completely different purpose i.e. for providing a runtime access to a descriptive information about a GUI.

A graphical user interface GUI is a piece of software program logic configured to generate and manage data objects which are to be displayed on a display device e.g. a screen and which enable a user to interact with the GUI and thereby with an application program interoperatively coupled to said GUI.

A GUI element is a data object representing an element of a graphical user interface GUI . A GUI element may be configured to be displayed on a screen or to be hidden. A GUI element includes a plurality of features or attributes whereby some of said features specify the shape layout and or behavior of an area displayed on a graphical user interface. A GUI element can be a standard GUI element such as a button a text box a tab an icon a text field a pane a check box item or item group or the like. A GUI element can likewise be a widget provided by program libraries an image an alphanumeric character or any combination thereof.

An accessibility API accessibility application programming interface is a program interface originally intended to be used by developers for creating applications and GUIs that are accessible to persons with permanent or temporary disabilities. Accessible applications are compatible with assistive technologies such as screen readers speech recognition systems and refreshable braille displays. In some embodiments the accessibility API acts as a bridge between the operating system and a GUI of an application. Typically there are several pieces of information for an object exposed by an accessibility API to other programs said pieces of information including in respect to a particular GUI element its role for example it might be a button an application window or an image a name identifying the GUI element within the interface if there is a visible label like text on a button this will typically be its name but it could be encoded directly in the object its state or current condition for example a checkbox might currently be selected partially selected or not selected . Examples for an accessibility API are Microsoft Active Accessibility MSAA Java Accessibility API a cross platform toolkit independent API designed to give assistive technologies direct access to the information in user interface Assistive Technology Service Provider Interface AT SPI the User Interface Automation UTA API the IAccessible2 the UI Accessibility API of Apple iOS 3 the SWT accessibility API and others.

 Inter GUI element dependencies are functional or structural dependencies between two or more GUI elements of a particular GUI. For example parent child relationships or sibling node relationships are structural relationships between different GUI elements. Relations indicating that upon a Select action on a first GUI element the state or behavior or data content of a second GUI element changes is an example for a functional dependency.

A test routine is a piece of executable program logic e.g. a rule or a compiled class object configured for testing a test scenario on one or more GUI elements matching a particular pattern. By performing said test scenario GUI elements which do not function correctly or do not function at all are identified. In case a GUI element is identified that does not function as expected by the test routine the test routine may for example throw an error or write an error notification to a test log.

A database as used herein is an information structure which includes one or more data containers e.g. tables and views whereby the use of said data containers is controlled by a DBMS. Said use may include for example reading data from a data container storing data in a data container manipulating or evaluating the structure of a data container or planning query execution on multiple ones of said data containers. The database may be a relational database an object oriented database or any other kind of database. Accordingly the DBMS may be a relational DBMS an object oriented DBMS an OLAP DBMS an OLTP DBMS or any other kind of DBMS.

 Black box testing approaches are software tests which do not rely on code analysis but rather rely on treating a piece of software on the test as a black box and merely evaluate the behavior of the software under test in response to performing some test scripts on the tested software. Compared to black box testing approaches which are based on recorded or manually created test scripts the automatic testing method according to embodiments of the invention may provide for a much greater flexibility as a plurality of test paths is automatically derived from the GUI element graph. Thus it is neither necessary to manually specify a test script nor to record a sequence of user actions e.g. by means of a macro recorder in order to create a test script. Test scripts generated manually or by means of a macro recorder have the disadvantage that in an agile software development approach said scripts would often have to be rewritten or the recording step would have to be repeated as even minor changes to the GUI structure often result in test script execution failure.

 White box testing approaches are based on source code analysis in order to generate executable test scripts. Compared to white box testing approaches embodiments of the invention may have the advantage that it is possible to test a piece of software even in case the source code is not available. By using an accessibility API embodiments of the invention are able to create a graph of GUI elements to automate the generation of test scripts by traversing that graph whereby the accessibility API provides valuable information on the structure type and functionalities of the respective GUI elements which allows for the automated identification of topological dependencies and the automated creation and application of test scripts on appropriate GUI elements are GUI element groups.

According to embodiments the analyzing of the GUI and the generation of the graph is performed at runtime of the GUI. The analysis is devoid of an analysis of source code having been compiled into an executable program logic implementing the GUI.

This may be advantageous as the source code of an application is often not available at the testing system. Commonly software is developed in a testing environment e.g. a first computer system. In order to test a new software built the source code is compiled into an executable code and the executable code is deployed e.g. via a network to a second computer system on which the tests are performed. By automatically determining topological and functional properties of a GUI by means of an accessibility API it is possible to perform the software test and automatically identify test scripts e.g. based on paths spanning the graph from the root node to a leaf node by a testing module running on the second computer system even in case the source code is not available on that second computer system.

According to embodiments the GUI elements under test include or consist of complied executable program logic whose source code cannot be derived by analyzing a GUI element. Thus by making use of an accessibility API topological as well as functional features of GUI elements and GUI element containers can be derived even in case the GUI element per se does not disclose any source code.

According to embodiments the accessibility API is configured to identify at runtime of the GUI the GUI element features and functional GUI element dependencies for the following types of GUI elements 

According to embodiments the accessibility API is provided by an operating system OS of a data processing machine on which the test module is executed and or by a program logic library loaded to a GUI test engine including the test module.

According to embodiments the functional GUI element dependencies are selected from the group including 

According to embodiments the GUI element features identified by the accessibility API of one or more nodes of the graph include state information of one or more of the GUI elements of the graph. State information can be for example the state SELECTED for check boxes radio buttons or an option in an option list. The test module repeatedly generates a state value that is indicative of a current state of the GUI and the GUI elements contained therein. Each state value is generated as a derivative of at least one GUI element feature of each of the totality of nodes of the graph. The test module analyzes the generated state values for identifying one or more malfunctioning GUI elements. For example the state values resulting e.g. from a select action of a user or of the test module may be stored to a log of the operating system or of the test module. The log may be implemented as a file or a database table of a relational database management system DBMS .

Said features may be advantageous as they allow implementing highly generic test routines. For example a test routine could specify that a user action on a GUI element of a particular set of GUI containers should be encapsulated and should never affect the state of a GUI element in a particular set of other GUI element containers. Another test routine could check if a select action on a GUI element resulted in a state change in at least one GUI element of the GUI. If this is not the case the GUI element on which the select action was performed may be automatically identified by the test module as a malfunctioning GUI element.

According to embodiments the generation of one of the state values at a particular time point includes 

Said features may be advantageous because the test module may be enabled to identify track and evaluate the state of the GUI under test for automatically identifying malfunctioning GUI elements. Thus it is not necessary to run a debugger or to set the breakpoints in order to monitor the state of a GUI and its elements in dependence on the actions performed by a user or by a script on said GUI. The concatenated value and also the hash generated therefrom represent unique identifiers of a particular state of a particular GUI. Whenever the GUI is modified e.g. by setting the state of a particular GUI element to selected or deselected the concatenated value and also the hash value derived therefrom will change. Thus by checking if two hash values having been created before and after a particular select action on the GUI are identical or not it is possible to automatically determine if a particular action on a GUI element recited in the state change of that or any other element of the GUI or not.

According to embodiments the generation of the state values and the analysis of the state values includes 

According to embodiments the storing of the first state value in the first database includes using the first state value as a database key for a first data record including human readable state information on the GUI at the first time point. The storing of the second state value in the first database includes using the state value as a database key for a second data record the second data record including human readable state information on the GUI at the second time point. According to embodiments a database index is created in the database over all state values stored in the database as a key.

Using the state value as a database key may be advantageous because it is possible to very quickly determine if a particular state of a GUI has already been observed while performing a GUI test or not and to quickly determine if two particular states are identical or not. By using an index it is possible to avoid a sequential scan for identical key values and rather use the index instead.

According to embodiments the traversing is performed via multiple different paths. Each path is a set of nodes connecting the root node of the graph with a plurality of different leaf nodes of the graph or is a set of nodes connecting the root node of a sub graph of the graph with a plurality of different leaf nodes of the sub graph. For each of the multiple paths having been traversed the test module creates a path ID from the GUI element features assigned to all nodes contained in said traversed path. Then the test module stores the path IDs created in a time period during which the test routines were repeatedly performed on the graph or on the sub graph in a second database. The second database can be for example a log file or a database table of a relational DBMS. The first and the second database can be contained in the same log file or in different log files and or can be contained in the same database are in different databases. The test routines may be performed automatically manually or semi automatically.

Using the accessibility API for identifying visited paths in the graph and generating and storing a path ID from GUI element features of the nodes in that path may be advantageous because an automatic method is provided that ensures for any possible topology or size of a GUI graph provided by the accessibility API that any path contained in that graph can clearly be identified. In case the path IDs are stored in a relational database an index may be created that covers all the path IDs and allow for a particularly fast determination if a particular path was already traversed or not upon having finished traversing a particular path by the test module the test module may automatically generate and store a path ID of a traversed graph in the database.

According to embodiments the method further includes analyzing by the test module all path IDs in the second database or log for automatically identifying one or more paths whose frequency of traversion is below a threshold.

That features may be advantageous because the accessibility API automatically identifies all paths in a GUI element graph that can be traversed for testing respective GUI elements. That features provide the basis for a more complex statistical analysis on the frequency of path traversal and thus on the frequency of the type of GUI tests performed.

According to embodiments the method further includes automatically traversing by the test module the one or more identified paths whose frequency of traversion is below the threshold thereby using the accessibility API for automatically identifying GUI element features and inter GUI element dependencies of GUI elements represented by the nodes contained in said traversed path and for performing the test routines on the GUI elements in the GUI represented by nodes of said path matching one of the GUI element patterns.

The features may be advantageous as they may ensure that rarely visited paths are identified automatically and the testing routines are specifically performed for the rarely visited paths. According to embodiments the automated graph traversed can be triggered for example by a cron job or other regularly executed job e.g. on a daily basis.

An example for a pattern P1 matching a particular set of functionally interrelated GUI elements is given below 

Set1 a GUI element is of type LINK triggers upon being selected the displaying of a window including a language option list whereby the selected language determines if a further GUI element in said window being of type label displays Stadt or city .

Set2 a GUI element is of type Button triggers upon being selected the displaying of a panel including a currency check box field whereby the selected currency check box item determines if a further GUI element in said panel being of type label displays EURO or USD .

The pattern P1 may have assigned one or more test routines to check if particular failure scenarios apply to any set of GUI elements S1 S2 matching the pattern P1. Such failure scenarios respectively being implemented in the form of a test routine R1 R2 and R3 assigned to pattern P1 could be for example 

R2 A SELECT action on an option in the second GUI element has no impact on the content of the third GUI element 

R3 A SELECT action on an option in the second GUI element has an erroneous impact on the content of the third GUI element or on one or more other GUI elements of the GUI under test 

According to embodiments the creation of a path ID from the GUI element features assigned to all nodes contained in said traversed path including ignoring GUI element features including GUI element features including state information. Said features may be advantageous because they ensure that for a particular testing path through the GUI element graph the test module always creates the same path ID irrespective of the state of the GUI elements contained in that path.

According to embodiments the generation of a path ID of one of the paths includes concatenating by the test module at least one GUI element feature of each node contained in said path for generating a concatenated value and using the concatenated value as the path ID of the one path.

According to embodiments the storing of each of the path IDs in the second database includes using the path ID as a database key for a second data record including human readable path information on the nodes contained in the path identified by said path ID.

According to embodiments the test module may automatically select the root node of the graph as a starting node for traversing the graph. Typically the main menu of the GUI under test will be the root node of the graph. For example the test module may be initialized upon a user selecting a particular GUI element of the GUI under test. The test module may automatically identify a node in the graph representing the selected GUI element. In case the identified node is not the root node of the graph the test module may automatically navigate to the root node of the graph. In Java Swing this can be for example the top level container. It serves as an anchor point from which all elements of the GUI can be reached.

Before the actual GUI test is started the test module may identify the state of the whole GUI and store the state value for later evaluation. The state is a derivative of the number type features and states of all GUI elements of the graph at test begin. The GUI element graph may also include hidden GUI elements not visible to a user and may include nodes that are not testable e.g. GUI containers such as panes and panels.

According to embodiments the test module receives configuration data e.g. by receiving a user s entry via a GUI or reading a configuration file . The configuration data is at least indicative of a user s preference to perform a breadth first or a depth first graph traversal. The test module accesses a database including a plurality of different graph traversal algorithms. The plurality of graph traversal algorithms includes at least one breadth first traversal algorithm and at least one depth first graph traversal algorithm. It is possible that multiple different breadth first traversal algorithms and or multiple depth first graph traversal algorithms are contained in the configuration data. The test module automatically identifies one of the graph traversal algorithms in the database that best fits to the received configuration data. Then the test module performs the graph traversal through the graph in accordance with the identified graph traversal algorithm.

Using configurable path traversal strategies may have the advantage that a software tester can easily change the graph traversal strategy depending on the current requirements. For example in case the GUI has a structure in which GUI elements nodes of the same level represent highly similar functions it may be preferable to perform a depth first test strategy fast coverage instead of completeness . Thus by traversing nodes in the depth first approach the chance is higher that multiple different GUI element function types are evaluated and that different types of errors can be identified quickly. To the contrary traversing graph nodes according to the breadth first approach the coverage of each level of the hierarchical graph is better but it may happen that all or most of the tested GUI elements relate to the same type of GUI element.

According to embodiments the test module accesses a current GUI container of the GUI. The current GUI container includes a plurality of the GUI elements of the GUI. The plurality of GUI elements is represented by nodes belonging to a sub graph of the graph the sub graph being a tree. Thus the graph may include one or more sub trees. Each sub tree corresponds to a GUI container e.g. a window of the GUI. The GUI container is accessed at runtime of the GUI. The test module uses the sub graph as the graph for performing the test routines and or for computing a state value and or for computing one or more path IDs of the path spanning said sub graph.

Said features may be advantageous as they allow for considering sub graphs related to GUI element containers and the GUI elements contained therein as independent graphs which are traversed and evaluated individually. Thus it may be possible to perform the testing selectively for individual GUI windows or panes.

Embodiments of the invention may be used in test scenarios where GUI functionalities and business logic functionalities are developed and tested separately at least in an early phase of development. According to embodiments the GUI when creating and traversing the graph is a GUI of an application program that is under development. The application program lacks the desired business functionality partly or completely.

Many existing test tools test the GUI and the underlying function in one and the same test. But especially in the early phase of GUI testing there are numerous errors in the GUI itself which could be detected without testing or involving the underlying function. By performing tests which selectively addressed GUI functionalities it is possible to test a GUI in an early testing phase independent of the business functionality of an application under development.

In a further beneficial aspect the automation of the GUI testing provided by embodiments of the invention allow to separate the task of GUI element function testing from the task of testing the overall functionality of an application which includes the testing of the correct orchestration of business functions and GUI element functions. Performing the GUI element function testing includes checking navigation paths checking the implementation of commonly used GUI element patterns and testing easily testable behavior. The testing of the correct orchestration of business logic functions and GUI element functions can often not completely be automated. However by performing the testing of the GUI internal errors automatically the early phase of GUI testing can tremendously be facilitated and accelerated thereby freeing testing resources for other tasks. Moreover a tester can expect the GUI to be of a higher quality when starting with the manual testing phase at a later stage of development. This also helps saving time that can be spent on performing more complex test cases for improving the quality of the product. For automating the first type of tests the GUI internal tests .

The computer system may include one or more processors a volatile main memory and a non volatile data storage medium including computer interpretable instructions which implement the test module configured to perform the method depicted in . The test module may be part of a larger software test engine configured for testing GUIs and optionally also further software modules e.g. software modules related to the business logic of an application to be tested. The GUI may include one or more GUI element containers e.g. a dialog box including a panel which again includes multiple GUI elements e.g. a text field for entering a name of a person a text field for entering a street name a text field for entering a city and a button submitting the entered strings to the business logic of the application.

In addition to the test module an accessibility API is installed or stored on the computer system . For example in case the GUI is based on Java Swing classes the accessibility API may be the Java Accessibility Utilities . The accessibility API may act as a GUI element reader providing runtime access to descriptive information about the GUI . For example different GUI element types may be identified and their attributes or at least their testing relevant attributes may be retrieved.

The test module is configured to use in step the accessibility API for analyzing the GUI elements of the GUI and for automatically identifying GUI element features state attribute values element type assigned actions and other features of each GUI element and for automatically identifying inter GUI element dependencies. The identification of the features and dependencies is performed at runtime of the GUI without performing any source code analysis of the source code underlying the GUI. Rather the test module parses the structure of a given GUI element as revealed by the accessibility API for identifying the GUI element features and interdependencies.

In step the test module uses the identified features and dependencies for automatically generating a graph of nodes as depicted for example in . The graph can be for example a tree. Each node of the graph represents a GUI element or a GUI element container of the GUI and has assigned the GUI element features and inter GUI element dependencies of the GUI element represented by said node. All GUI elements and containers are part of the tree and can be reached from any other GUI element. In an initialization phase of the software GUI test the test module traverses the graph. Thereby it automatically analyzes the identified GUI element features and dependencies assigned to each currently accessed node and or analyzes the GUI element features and dependencies assigned to any child or sibling node of the currently analyzed node. The analysis is executed for identifying GUI element patterns . According to embodiments of the invention the test module is capable of traversing the graph according to different graph traversal algorithms as depicted for example in . Which one of the supported graph traversal algorithms is chosen depends for example on configuration data that may be dynamically retrieved from a database or from data entered by a user.

A GUI element pattern is a predefined set of one or more nodes having assigned predefined GUI element features and or is a predefined set of two or more nodes representing GUI elements linked to each other by a predefined functional dependency. For example a plurality of predefined patterns can be stored in a database that is hosted by the computer system or by a remote computer system accessible by the test module via a network. Each pattern may have assigned one or more test routines configured for testing the functionality of the respective pattern. For example there may exist test routines for radio button groups only one radio element in a radio group is allowed to have selected state for selectable buttons which should change their own state or the state of at least one other GUI element of the GUI upon being selected and four sets of one or more functional interconnected GUI elements e.g. of a combo box whose content depends on the selection of another combo box.

In case the test module identifies a GUI element pattern that matches a set of one or more nodes of the graph the test module automatically identifies in step one or more test routines associated with the identified GUI element pattern and applies that predefined test routine or routines on the GUI elements represented by nodes which match said identified predefined GUI element pattern.

In step the test module automatically performs the one or more identified test routines on the GUI elements in the GUI represented by the nodes matching said GUI element pattern.

As depicted in the graph is traversed in step by the test module according to a breadth first graph traversal algorithm. Said graph traversal and GUI test algorithm is also referred to as fast coverage instead of completeness approach. The main menu of the application under test may constitute the root node of the graph and is chosen a starting node for the GUI test. In Java Swing the root node is typically the top level container of the GUI.

At first the whole graph is traversed in order to identify the GUI feature values including state values for computing a state value that depends on the state of each GUI element. Preferentially GUI elements which are hidden are also evaluated and their states are considered during this step. For example the type and or the ID and state information of each GUI element which are assigned to a respective node in the graph may be concatenated and a hash value may be calculated from the concatenated value. The state value may be stored in a respective table in a database or a log. Then the graph is traversed a second time to actually perform the GUI test whereby the root node is again used as a starting node.

According to embodiments the configuration data configures the test module such that the breadth first graph traversal algorithm depicted in is preferentially performed in a first phase of the software test. shows a sequence of graph traversal steps as indicated by the numbers. The idea of this algorithm is to test all paths starting from a node in the second top most hierarchical level of the graph here file edit view format help with only one tested node per path and per hierarchical level rather than testing all nodes contained in a particular path. It may have the advantage that errors of GUI elements at a lower position in the hierarchy of the graph are identified earlier compared to the breath first graph traversal algorithm depicted in . Thus by applying the graph traversal algorithm depicted in it may be possible to test many different GUI elements with a limited amount of time without trying to achieve complete coverage for only one or very few GUI components in a limited amount of time. As can be inferred from with the same number of tests steps it is possible to test GUI functions that are dissimilar like safe and zoom . However functions that are quite similar like save and save as are not completely covered in this test scenario.

According to embodiments the configuration data configures the test module such that the depth first graph traversal algorithm depicted in is preferentially performed in a later phase of the software test. shows a sequence of graph traversal steps as indicated by the numbers. The idea of this algorithm is to test one or very few paths per given node in the second top most hierarchical level of the graph here file edit view format help whereby all nodes at all hierarchical levels belonging to an evaluated path are traversed and evaluated path rather than evaluating only one node per path and per level. The approach depicted in may have the advantage that the whole GUI element graph evaluated and tested and that a high test coverage is provided. As can be inferred from with the same number of tests steps it is possible to test GUI functions that are similar like safe and save as . However functions that are quite different like the ones of the edit path are not tested.

According to embodiments the test module traversing the graph according to a graph traversal algorithm such as depicted for example in may in addition apply a heuristics in order to determine which ones of multiple child nodes to chose as the next node. For example the test module checks if the end of a navigation path has been reached. In this case there is no node in the current path in which an action can be performed to navigate to the next GUI element. In case the current GUI element is a back button or home button or is associated with a new menu entry the end of the path is not reached.

In the case the test module determines that the currently evaluated GUI element is a home button or back button the test module checks if a next navigation path can be reached from the container including the currently selected GUI element. For example this might be the case if the currently evaluated GUI element has assigned an action to open or display a non tested menu item. If this is the case the non tested GUI element e.g. a non tested menu item is selected as the next GUI element to be tested. If this is not the case the test module automatically selects said back or home button. Said features may be advantageous as the test module may thus be enabled to autonomously identify the most interesting path and avoid repeatedly traversing the same path.

The test module in step checks if the end of a navigation path has been reached. In this case there is no node in the current path in which an action can be performed to navigate to the next GUI element. In case a GUI element relates to a back button or home button or is associated with a new menu entry the end of the path is not reached.

In the case that the end of the navigation path has been reached the currently evaluated GUI element is a home button or back button the test module checks if the node e.g. the File Edit View . . . nodes of in the second highest hierarchy of the graph selected when starting traversing the path the initial root node is identical to the current root node . The current root node is one of the nodes e.g. the File Edit View . . . of the second highest level of the currently evaluated path that is reached by traversing the currently evaluated path upwards. Said two root nodes may differ in case during graph traversal the test module selected a node of another path as the next node e.g. based on a pointer or an initialization action encoded in a currently evaluated GUI element. Such a switching of paths may be called a path jump event .

In the case that the two compared nodes are identical i.e. that no path jump event occurred or the test module has meanwhile returned to the initial path the test module continues with step .

If the test module determines in step that said two root nodes are not identical i.e. the test module has meanwhile switched to another path in the tree and that the end of the navigation path has been reached in step the test module searches for a Back GUI element e.g. a Back button or link. In case such a Back GUI element was found the test module selects the GUI element that constitutes the starting point of the path jump event as the next GUI element to be evaluated in the test. Otherwise the test module continues with step .

According to embodiments multiple steps are performed for identifying and testing the parts of the GUI that have not been tested often during previous manual or automated tests. Depending on the embodiments steps may be combined with steps as depicted in or may be implemented independently of steps .

Before the test module executes steps the test module collects for every automatically or manually executed test in step the number of visits per node or at least per node representing a testable GUI element during the manual or automated test runs. The numbers of visits during previous test runs are stored to a log or a database . The previous test runs evaluated may be for example all test runs executed in a particular day in a particular week or in any other suitable time period. In addition the IDs of the tested paths and or the input values provided for the different GUI elements e.g. text fields or text areas or option lists entered when traversing the different paths may be stored in the database .

Then for all nodes in the graph or at least for all nodes representing a testable GUI element the test module determines in step e.g. by a database lookup the minimum number of visits observed for said nodes. A visit is an event in which the test module determines if a test pattern matches a GUI element represented by said node and if so applies a test routine assigned to said matching pattern on the GUI element. Said minimum number of visits in the past is referred to as min HIST USE MIN USE.

In step the test module identifies the node having assigned the MIN USE value as a candidate for the next node whose GUI element is to be tested.

In step the test module determines the number CUR USE of the selected node said number indicating how often said selected node has already been visited and tested during the current test run. This value may depend on multiple factors e.g. the position of the node in the graph on the selected graph traversal strategy on the number and type of predefined test patterns and test routines and the database and the like.

In step the CUR USE and the MIN USE values are compared. In case the two values are identical the test module selects this node to perform one or more test routines on said node if it matches a test pattern. In case the CUR USE value is larger than the MIN USE value the test module selects one of the nodes having the second lowest number of visits according to the HIST USE values assigned to the nodes and performs the test pattern matching and optionally also the test routines on said node with the second lowest HIST USE value. Said features may be advantageous as they ensure that rarely visited nodes and GUI elements are identified and preferentially used for testing in a fully automated manner.

For example an ID may be generated by the test module by concatenating feature values according to the schema Key ControlType Processld Name. For the selected node an ID may be computed by concatenating the following feature values of the node representing the Edit menu item UIA MenuItemControlTeId 9160 Edit .

By concatenating the dynamically computed node IDs of all nodes contained in a particular path and by computing a hash value from said concatenated value a path ID can be computed.

Aspects of the present invention are described herein with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer readable program instructions.

The present invention may be a system a method and or a computer program product. The computer program product may include a computer readable storage medium or media having computer readable program instructions thereon for causing a processor to carry out aspects of the present invention.

The computer readable storage medium can be a tangible device that can retain and store instructions for use by an instruction execution device. The computer readable storage medium may be for example but is not limited to an electronic storage device a magnetic storage device an optical storage device an electromagnetic storage device a semiconductor storage device or any suitable combination of the foregoing. A non exhaustive list of more specific examples of the computer readable storage medium includes the following a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory a static random access memory SRAM a portable compact disc read only memory CD ROM a digital versatile disk DVD a memory stick a floppy disk a mechanically encoded device such as punch cards or raised structures in a groove having instructions recorded thereon and any suitable combination of the foregoing. A computer readable storage medium as used herein is not to be construed as being transitory signals per se such as radio waves or other freely propagating electromagnetic waves electromagnetic waves propagating through a waveguide or other transmission media e.g. light pulses passing through a fiber optic cable or electrical signals transmitted through a wire.

Computer readable program instructions described herein can be downloaded to respective computing processing devices from a computer readable storage medium or to an external computer or external storage device via a network for example the Internet a local area network a wide area network and or a wireless network. The network may include copper transmission cables optical transmission fibers wireless transmission routers firewalls switches gateway computers and or edge servers. A network adapter card or network interface in each computing processing device receives computer readable program instructions from the network and forwards the computer readable program instructions for storage in a computer readable storage medium within the respective computing processing device.

Computer readable program instructions for carrying out operations of the present invention may be assembler instructions instruction set architecture ISA instructions machine instructions machine dependent instructions microcode firmware instructions state setting data or either source code or object code written in any combination of one or more programming languages including an object oriented programming language such as Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The computer readable program instructions may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider . In some embodiments electronic circuitry including for example programmable logic circuitry field programmable gate arrays FPGA or programmable logic arrays PLA may execute the computer readable program instructions by utilizing state information of the computer readable program instructions to personalize the electronic circuitry in order to perform aspects of the present invention.

Aspects of the present invention are described herein with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer readable program instructions.

These computer readable program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks. These computer readable program instructions may also be stored in a computer readable storage medium that can direct a computer a programmable data processing apparatus and or other devices to function in a particular manner such that the computer readable storage medium having instructions stored therein includes an article of manufacture including instructions which implement aspects of the function act specified in the flowchart and or block diagram block or blocks. The computer readable program instructions may also be loaded onto a computer other programmable data processing apparatus or other device to cause a series of operational steps to be performed on the computer other programmable apparatus or other device to produce a computer implemented process such that the instructions which execute on the computer other programmable apparatus or other device implement the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of instructions which includes one or more executable instructions for implementing the specified logical function s . In some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or carry out combinations of special purpose hardware and computer instructions.

