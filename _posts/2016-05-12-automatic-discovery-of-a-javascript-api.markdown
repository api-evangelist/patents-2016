---

title: Automatic discovery of a javascript API
abstract: An approach to creating a canonical representation of a JavaScript API. Objects associated with the JavaScript API are instantiated, creating entry points for analysis. A list of discovered objects is created based on parsing a document object model associated with the JavaScript API. The objects are instrumented and statically analyzed, creating an infrastructure associated with the JavaScript API. The infrastructure is updated based on analyzing the objects while the interface is being used and the objects are executing. A canonical representation, based on the updated infrastructure, is generated for further operations.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09495186&OS=09495186&RS=09495186
owner: International Business Machines Corporation
number: 09495186
owner_city: Armonk
owner_country: US
publication_date: 20160512
---
This application is a continuation of U.S. patent application Ser. No. 14 755 135 filed on Jun. 30 2015.

The present invention relates generally to utilizing JavaScript Application Programming Interfaces APIs and more specifically to optimizing the utilization of JavaScript APIs based on associated runtime platforms.

In recent years the popularity of implementing systems with JavaScript has dramatically risen with predictions that approximately 90 of all websites use JavaScript. Accordingly many of these websites and their associated web applications expose JavaScript APIs for consumption by client applications on a variety of runtime platforms. With the ever present benchmark measurements of user experience and performance consuming JavaScript APIs based on a native runtime environment of an associated platform becomes the desired path of implementation for client applications.

According to an embodiment of the present invention a computer program product for creating a canonical representation of a JavaScript API the method comprising one or more non transitory computer readable storage media and program instructions stored on the one or more non transitory computer readable storage media the program instructions comprising program instructions to instantiate a first one or more objects associated with the JavaScript API for use as one or more entry points to the JavaScript API program instructions to generate a list of the first one or more objects based on recursively parsing a Document Object Model DOM associated with the JavaScript API and filtering the first one or more objects to include objects associated with the JavaScript API and to exclude objects specified in a preconfigured exclusion list program instructions to instrument the first one or more objects for creating an infrastructure associated with the JavaScript API based on attaching a respective callback function to one or more class members for invocation each time each of the one or more class members are assigned a value for determining a data type of each value replacing one or more class functions with a respective first function that invokes a respective first callback function for analyzing input parameter types based on a data type matrix associated with a replaced function invokes the replaced function and invokes a second callback function for determining a return type based on a data type matrix associated with the replaced function and replacing one or more constructors with a respective second function that invokes a respective third callback function for determining input parameter types associated with a replaced constructor and invokes the replaced constructor program instructions to statically analyzing the first one or more objects for creating the infrastructure associated with the JavaScript API wherein statically analyzing comprises an analysis based on at least one of class hierarchy one or more class members one or more class functions and one or more class constructors program instructions to create an updated infrastructure based on substantially simultaneous execution and analysis of the first one or more objects and a second one or more objects created based on the execution of the first one or more objects wherein the updated infrastructure is a tree like data structure and wherein one or more elements of the update infrastructure change positions based on at least one of determining a return type and one or more input parameter types and program instructions to output an extensible markup language XML canonical representation of the JavaScript API based on the updated infrastructure.

The embodiments depicted and described herein recognize the challenges of consuming a JavaScript API in a runtime platform different than the runtime platform of the JavaScript API producer. For example consuming a Microsoft Windows Server JavaScript API from within an Apple Incorporated iOS mobile application can result in embedding a copy of the JavaScript API object model and portions of the object model logic in the mobile application platform. Embedding a copy of the JavaScript API object model and its associated logic in the mobile application runtime platform can result in application failures because any subsequent updates to the object model or the JavaScript API should be copied to the platform embedding the object model and or the JavaScript API to prevent interface synchronization problems.

Embodiments will now be described in detail with reference to the figures. It should be noted for the embodiments described herein that although JavaScript is the referenced programming language the embodiments are not limited to the JavaScript programming language i.e. the embodiments can be applied to other programming languages.

Client computer can be a laptop computer tablet computer netbook computer personal computer PC a desktop computer a personal digital assistant PDA a smart phone or any programmable electronic device capable of communicating with a server computer via network . Server computer includes JavaScript producer applications for providing data and or content via a JavaScript API. Client computer can include internal and external hardware components as depicted and described in further detail with respect to .

Network can be for example a local area network LAN a wide area network WAN such as the Internet or a combination of the two and can include wired wireless or fiber optic connections. In general network can be any combination of connections and protocols that will support communications between server computer and client computer .

JavaScript producer applications can be but are not limited to web pages online services or any other application presenting a JavaScript API for consumption and use by a client application. It should be noted in the embodiments that the JavaScript API consuming client application can be located on a client computer or it can be located on server computer .

In various embodiments of the present invention client computer can be a laptop computer tablet computer netbook computer personal computer PC a desktop computer a personal digital assistant PDA a smart phone or any programmable electronic device capable of communicating with server computer via network . Client computer includes one or more JavaScript consumer applications wherein each application further comprises an instantiation component a discovery component an instrumentation component a runtime component and an output component . It should be noted that although separate components are enumerated to describe the operations all of the operations can be performed by one or more components in any combination.

Instantiation component of an embodiment of the present invention provides the capability to determine one or more entry points presented by a JavaScript API producer . For example when a user takes an action that results in loading a web page containing JavaScript code one or more JavaScript objects are created and the instantiation component identifies these locations as one or more entry points for determining the JavaScript API associated with the JavaScript object.

Discovery component of an embodiment of the present invention provides the capability to recursively parse the Document Object Model DOM tree of a JavaScript API and discover the existing instances of the JavaScript objects. The discovery component provides a configuration capability allowing the user to specify classes that the embodiment should exclude from the JavaScript API output. In another aspect the discovery component provides a filter capability to exclude built in classes i.e. all instances of objects that do not belong to the JavaScript API subjected to discovery. It should be noted that a preconfigured exclusion list can be created for use during operation of discovery component .

Instrumentation component of an embodiment of the present invention provides the capability for a static analysis of objects determined by discovery component and to generate a framework for further discovery and analysis. The framework is based on an analysis of 4 elements associated with the JavaScript API comprising class hierarchy class members class functions and class constructors.

Runtime component of an embodiment of the present invention provides the capability for a dynamic analysis of objects created based on the use of the JavaScript API. Runtime component integrates results obtained from the runtime analysis into the framework generated by instrumentation component . Runtime component performs a similar analysis as described for instrumentation with regard to the 4 elements associated with the JavaScript API comprising class hierarchy class members class functions and class constructors.

Output component of an embodiment of the present invention provides the capability to output a canonical representation of the JavaScript API. The canonical representation of the JavaScript API allows an automatic and standard conversion of the JavaScript API to any other platform and programming language. For example an embodiment can output a canonical Extensible Markup Language XML representation of the JavaScript API.

The API instantiation step of embodiments depicted herein determines through instantiation component an entry point for beginning the analysis of an API. It should be noted that the API can be but is not limited to a JavaScript API. Entry points for the API can be determined from instantiated objects associated with the API. The instantiation of an object associated with the API occurs from actions such as but not limited to loading a web page presenting the API for consumption or manually creating an object of the API. One example of manually creating an object can be running a unit test designed to exercise the API. Once an entry point associated with the API is determined the embodiments can crawl through the API s object model and interface. It should be noted that crawling through an API s object model can be described generally as requesting data by use of the API parsing the response to the request and creating a hierarchical structure based on the parsed data.

Looking next to the API DOM Tree discovery step embodiments of the present invention through discovery component recursively parse the DOM Tree for discovering the existing API object instances. It should be noted that in dynamic language implementations objects are not created until they are instantiated by the calling program. Accordingly the embodiments can require a recursive procedure to walk through the objects of interest of the API.

Continuing with the API DOM Tree discovery step of an embodiment as the recursive analysis of the API continues via discovery component discovery of existing object instances of the DOM Tree are stored in a data structure such as but not limited to a linked list of the API object instances and any associated objects presently created. A filtering capability is provided with the embodiments allowing the user to exclude built in classes. It should be noted that built in classes are instances of discovered classes that do not belong to the API. Further a configuration function provides the capability for the user to predetermine instances of API classes that the user desires excluded from the discovered API output.

Next the API instrumentation step of an embodiment provides the capability to analyze instrument the presently discovered objects and create an infrastructure for further analysis through instrumentation component . For each instance previously discovered a four pronged analysis is performed which includes instrumenting based on callback functions the discovered objects. The four pronged analysis comprises determining class hierarchy class members class functions and class constructors.

The class hierarchy analysis is based on a building a tree like data structure for storing data associated with the class hierarchy such as but not limited to class inheritance class member origin class method origin class method overrides etc. It should be noted that the tree like data structure is dynamic in that the data describing the API evolves as the analysis progresses and elements of the tree like data structure can move to different locations positions within the tree like data structure. The class hierarchy analysis provides for the discovery of a general hierarchy of the currently instantiated objects assigning ownership of discovered class members to discovered classes and assigning ownership of discovered class methods to discovered classes. It should be noted that the aforementioned assignments can change based on additional object instantiation and or the discovery of parameters and parameter types as the analysis progresses.

The class member analysis comprises determining and storing a class member name and data type of any value assigned to each discovered class member. Instrumentation is inserted via a callback function attached to each class member providing the capability to watch the class member and receive notification as values are assigned to the class member i.e. the callback function is invoked each time a value is assigned to the class member.

The class function analysis is based on determining parameter types and return value types. Initially the class function parameter names if any are discovered and stored. Next further instrumentation is inserted e.g. the original class function is replaced with a function having the same name and body but including a first callback function at the beginning and a second callback function at the end. The first callback function provides the capability to discover the number and types of parameters passed to the class function and the second callback function provides the capability to discover the types of values returned from the class function as the analysis progresses.

The class constructor analysis is similar to the class function analysis with regard to parameter types but because a constructor does not return a value there is no requirement for determining the return value type.

Continuing with the API runtime analysis step of an embodiment the API is analyzed by runtime component while being exercised. It should be noted that the API can be exercised by either manual usage or automatic usage wherein an example of manual usage is a user clicking on different objects of a web page and an example of automatic usage is a test tool running a unit test associated with the API. It should further be noted that the API usage can be limited to relevant parts of the API wherein relevant is defined as those parts of interest to the user.

Based on the instrumentation previously inserted by instrumentation component in general class function invocations parameters passed to a class functions class member assignments and class function return values are tracked for updating the infrastructure data tree. Further any new class types discovered are added to the tree and instrumented as previously described for tracking. It should be noted that examples of new class type discoveries can be but are not limited to discovery based on assignment to a class member of a known class type passed as a parameter to a known class function and returned from a known class function. As previously described for each new class type a four pronged analysis is performed which includes instrumenting based on callback functions the discovered objects. The four pronged analysis comprises determining class hierarchy class members class functions and class constructors.

The runtime class hierarchy analysis determines changes in the class hierarchy as the API is exercised. The class hierarchy can change by events such as but not limited to discovery of a new class and a class member or a class method moving to a different location of the class hierarchy based on input parameters. It should be noted that a newly discovered class can be a parent and or a child of a known class.

The runtime class member analysis monitors each assignment of previously discovered class members through invocation of the previously inserted callback function. The callback function utilizes a data type matrix depicted in to determine the true type of the class member. For example if during one invocation of the callback function it is determined a class member was assigned a number and during another invocation of the callback function it is determined the class member was assigned a null the data type matrix indicates the class member is a nullable number type and the type is recorded in the tree like data structure.

The runtime class function analysis monitors each invocation of the class functions via the previously installed callback functions. The class functions are analyzed based on the input parameters and the return value. The analysis comprises comparing the stored count of input parameters and their types to the count of input parameters and their types of the current invocation and comparing the stored return type to the return type of the current invocation. Based on these comparisons conclusions can be drawn as follows a class function has optional parameters if the count of input parameters is different for different invocations of the class function the true type of input parameters and return values can be determined based on use of the data type matrix as previously described an overloaded class function can be determined if commonality does not exist between input parameters for different invocations of the class function e.g. a class function invoked once with two numbers for parameters and another invocation with a number and a string for parameters results in a determination of an overload condition and a parameter type belongs to a parent class of a previously known class based on previously stored inheritance information.

The runtime class constructor analysis is similar to the runtime class function analysis with regard to parameter types but because a constructor does not return a value there is no requirement for determining the return value type.

Next the API canonical output step provides the capability via output component to construct a canonical representation of the discovered API allowing an automatic and standard conversion to any platform and programming language. For example a canonical representation of the discovered API can be output in an XML format for use by any programming language on any platform.

Client computer includes communications fabric which provides communications between computer processor s memory persistent storage communications unit and input output I O interface s . Communications fabric can be implemented with any architecture designed for passing data and or control information between processors such as microprocessors communications and network processors etc. system memory peripheral devices and any other hardware components within a system. For example communications fabric can be implemented with one or more buses.

Memory and persistent storage are computer readable storage media. In this embodiment memory includes random access memory RAM and cache memory . In general memory can include any suitable volatile or non volatile computer readable storage media.

Instantiation component discovery component instrumentation component runtime component and output component are stored in persistent storage for execution by one or more of the respective computer processors via one or more memories of memory . In this embodiment persistent storage includes a magnetic hard disk drive. Alternatively or in addition to a magnetic hard disk drive persistent storage can include a solid state hard drive a semiconductor storage device read only memory ROM erasable programmable read only memory EPROM flash memory or any other computer readable storage media that is capable of storing program instructions or digital information.

The media used by persistent storage may also be removable. For example a removable hard drive may be used for persistent storage . Other examples include optical and magnetic disks thumb drives and smart cards that are inserted into a drive for transfer onto another computer readable storage medium that is also part of persistent storage .

Communications unit in these examples provides for communications with other data processing systems or devices including resources of enterprise grid and client computer . In these examples communications unit includes one or more network interface cards. Communications unit may provide communications through the use of either or both physical and wireless communications links. Instantiation component discovery component instrumentation component runtime component and output component may be downloaded to persistent storage through communications unit .

I O interface s allows for input and output of data with other devices that may be connected to client computer . For example I O interface may provide a connection to external devices such as a keyboard keypad a touch screen and or some other suitable input device. External devices can also include portable computer readable storage media such as for example thumb drives portable optical or magnetic disks and memory cards. Software and data used to practice embodiments of the present invention e.g. Instantiation component discovery component instrumentation component runtime component and output component can be stored on such portable computer readable storage media and can be loaded onto persistent storage via I O interface s . I O interface s also connect to a display .

The components described herein are identified based upon the application for which they are implemented in a specific embodiment of the invention. However it should be appreciated that any particular component nomenclature herein is used merely for convenience and thus the invention should not be limited to use solely in any specific application identified and or implied by such nomenclature.

The present invention may be a system a method and or a computer program product. The computer program product may include a computer readable storage medium or media having computer readable program instructions thereon for causing a processor to carry out aspects of the present invention.

The computer readable storage medium can be a tangible device that can retain and store instructions for use by an instruction execution device. The computer readable storage medium may be for example but is not limited to an electronic storage device a magnetic storage device an optical storage device an electromagnetic storage device a semiconductor storage device or any suitable combination of the foregoing. A non exhaustive list of more specific examples of the computer readable storage medium includes the following a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory a static random access memory SRAM a portable compact disc read only memory CD ROM a digital versatile disk DVD a memory stick a floppy disk a mechanically encoded device such as punch cards or raised structures in a groove having instructions recorded thereon and any suitable combination of the foregoing. A computer readable storage medium as used herein is not to be construed as being transitory signals per se such as radio waves or other freely propagating electromagnetic waves electromagnetic waves propagating through a waveguide or other transmission media e.g. light pulses passing through a fiber optic cable or electrical signals transmitted through a wire.

Computer readable program instructions described herein can be downloaded to respective computing processing devices from a computer readable storage medium or to an external computer or external storage device via a network for example the Internet a local area network a wide area network and or a wireless network. The network may comprise copper transmission cables optical transmission fibers wireless transmission routers firewalls switches gateway computers and or edge servers. A network adapter card or network interface in each computing processing device receives computer readable program instructions from the network and forwards the computer readable program instructions for storage in a computer readable storage medium within the respective computing processing device.

Computer readable program instructions for carrying out operations of the present invention may be assembler instructions instruction set architecture ISA instructions machine instructions machine dependent instructions microcode firmware instructions state setting data or either source code or object code written in any combination of one or more programming languages including an object oriented programming language such as Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The computer readable program instructions may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider . In some embodiments electronic circuitry including for example programmable logic circuitry field programmable gate arrays FPGA or programmable logic arrays PLA may execute the computer readable program instructions by utilizing state information of the computer readable program instructions to personalize the electronic circuitry in order to perform aspects of the present invention.

Aspects of the present invention are described herein with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer readable program instructions.

These computer readable program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks. These computer readable program instructions may also be stored in a computer readable storage medium that can direct a computer a programmable data processing apparatus and or other devices to function in a particular manner such that the computer readable storage medium having instructions stored therein comprises an article of manufacture including instructions which implement aspects of the function act specified in the flowchart and or block diagram block or blocks.

The computer readable program instructions may also be loaded onto a computer other programmable data processing apparatus or other device to cause a series of operational steps to be performed on the computer other programmable apparatus or other device to produce a computer implemented process such that the instructions which execute on the computer other programmable apparatus or other device implement the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of instructions which comprises one or more executable instructions for implementing the specified logical function s . In some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or carry out combinations of special purpose hardware and computer instructions.

The descriptions of the various embodiments of the present invention have been presented for purposes of illustration but are not intended to be exhaustive or limited to the embodiments disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The terminology used herein was chosen to best explain the principles of the embodiment the practical application or technical improvement over technologies found in the marketplace or to enable others of ordinary skill in the art to understand the embodiments disclosed herein.

