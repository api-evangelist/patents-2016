---

title: Distributed computation system incorporating agent network, paths and associated probes
abstract: A system and method of distributed computation based upon a novel partitioning of computer networks. In the distributed computing system of the present invention, instructions are disseminated to select agents on a computer network, each of which is a member of at least one “path,” a path being an ordered set of one or more connected agents within the network. The computation is then performed by the agents along the path, and any results then returned. A computation to be performed is broken down into instructions executed on a unique ordered sequence of agents making up a path. This vastly increases the expressive power of a single network to be not only the sum of its parts, but the sum of all possible configurations of those parts on a graph. The basic components of the computing system are agents, probes and paths. The agents are interconnected forming a network and a path is an ordered sequence of agents. Information is exchanged between agents by the sending and receiving of probes between the agents in the network.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09577911&OS=09577911&RS=09577911
owner: Black Cloud Analytics, Inc.
number: 09577911
owner_city: Basom
owner_country: US
publication_date: 20160321
---
The subject matter disclosed herein relates to the field of network computing and more particularly relates to a distributed computation system and method based on a network incorporating paths agents and related probes exchanged between the agents.

To aid in understanding the prior art and the problems associated therewith it is helpful to provide a brief overview of distributed computing environments. The field of distributed computing is a well known field in computer science that deals with distributed systems. A distributed system is a software system in which components located on networked computers communicate and coordinate their actions by passing messages. The components interact with each other in order to achieve a common goal. Three significant characteristics of distributed systems include concurrency of components lack of a global clock and independent failure of components. Examples of distributed systems vary from SOA based systems to massively multiplayer online games to peer to peer applications.

Distributed computing also deals with the use of distributed systems to solve computational problems. In distributed computing a problem is divided into many tasks each of which is solved by one or more computers which communicate with each other by message passing.

The computational entities are typically referred to as nodes. A distributed system may have a common goal such as solving a large computational problem. Alternatively each computer may have its own user with individual needs and the purpose of the distributed system is to coordinate the use of shared resources or provide communication services to the users.

Other typical properties of distributed systems include the ability to tolerate failures in individual computers and or nodes. The structure of the system i.e. network topology network latency number of computers is not known in advance the system may consist of different kinds of computers and network links and the system may change during the execution of a distributed program. In addition each computer has only a limited incomplete view of the system and each computer may know only one part of the input.

Distributed computing can make use of various hardware and software architectures. At a lower level multiple CPUs are interconnected with some sort of network regardless of whether that network is printed onto a circuit board or made up of loosely coupled devices and cables. At a higher level processes running on those CPUs are interconnected with some sort of communication system.

Currently distributed programming typically falls into one of several basic architectures client server three tier n tier or peer to peer or categories loose coupling or tight coupling. Client server architecture is a hierarchical architecture for distributed computing environments that is generally divided into two layers. One layer within the client server architecture includes most of the application systems. Application systems include fourth generation languages computer aided software engineering tools programming languages and their support tools and various other commercially available software products. This first layer typically represents the client layer. In client server architectures smart clients contact the server for data then format and display it to the users. Input at the client is committed back to the server when it represents a permanent change.

A second layer within the client server architecture includes most of the information service systems. The information service systems are software products such as database management systems and data repositories specialized data access methods application servers and any number of service based monolithic software systems. This second layer represents the server layer.

The client server architecture also includes a third or middle layer. This third layer typically includes software products designed to provide various infrastructure or interfacing services between other components of the distributed computing environment such as between an application system and an information service system. Such software products are classified as middleware products or systems. A recent term for the hierarchical architecture that utilizes middleware systems is a three tier system or multi tier system architecture where the middleware system consists of software products applications and services that had previously existed either in the client layer or server layer. Three tier or multi tier layers are well known in the art.

Three tier architectures move the client intelligence to a middle tier so that stateless clients can be used. This simplifies application deployment. For example the majority of web applications are three tier. n tier architectures refer typically to web applications which further forward their requests to other enterprise services. This type of application is the one most responsible for the success of application servers.

In peer to peer architectures there are no special machines that provide a service or manage the network resources. Instead all responsibilities are uniformly divided among all machines known as peers. Peers can serve both as clients and as servers. A peer to peer architecture provides any number of peers or service providers while removing some of the constraints imposed by a traditional client server or other hierarchical architecture. Within a peer to peer system architecture each peer provides one or more services and is able to cooperate and collaborate with fellow peers as services need to be performed concurrently or sequentially.

Another basic aspect of distributed computing architecture is the method of communicating and coordinating work among concurrent processes. Through various message passing protocols processes may communicate directly with one another typically in a master slave relationship. Alternatively a database centric architecture enables distributed computing without any form of direct inter process communication by utilizing a shared database.

One important requirement of application systems operating within a distributed computing environment is scalability. Scalability is the ability of an application system and information service system to address computer environments that range from small i.e. small numbers of users and computers to very large computing environments i.e. large numbers of users and computers without the significant loss of efficiency. There is a growing demand for a distributed computing system architecture to incorporate such advantageous features as scalability fault tolerance support of legacy applications and other features such as modeling and simulation capabilities etc. without significantly contributing to the complexity of the computing environment and without significantly sacrificing performance of the distributed computing system.

An alternative technique aimed at addressing some of the aforementioned problems arising in distributed computing environments is the application of agent technology. The notion of agents and agent technology already exists in the information industry. A standard definition of what an agent entails however does not exist. A common perception of an agent is a software module or process that accomplishes a task typically on behalf of a user. For example conventional agents can filter electronic mail messages for a user based on a specific criterion to reduce the number of junk mail that a user receives.

Disadvantageously the more an agent looks and functions as a customized software process the less likely that agents will be able to cooperate with other customized agents operating within the distributed computer environment. Many of the related art agents both static and dynamic operating within a distributed computing environment inevitably demonstrate different behaviors and characteristics. Because these different agents often need to cooperate with one another within the distributed computing environment to accomplish various tasks however there is a need to facilitate communication between different agents. This is especially true where the agents are associated with different application systems or services. To that end there is a need to provide a universal or generic architecture for agents which facilitates the cooperative behavior of agents associated with different applications or services. The architecture of an agent based computing system should be independent of the environment in which it exists and independent of the application system or service which it supports. Further there is a need for a distributed computing architecture that is capable of expanding the computing power that can be expressed by the nodes of a network.

The present invention is a system and method of distributed computation based upon a novel partitioning of computer networks. In the distributed computing system of the present invention instructions are disseminated to select agents on a computer network each of which is a member of at least one path a path being a set of one or more connected agents within the network. The computation is then performed by the agents along the path and any results then returned. The return value of a computation or task can be placed into the payload of a probe and returned to another agent. In one embodiment the return value typically travels from a primary agent through zero or more other agents to the control server but other paths for the return value are also possible.

The novelty of the distributed computing network of the present invention versus a conventional distributed computing architecture is in breaking down a computation not into instructions on individual agents but into instructions executed on a unique ordered sequence of agents. This vastly increases the expressive power of a single network to be not only the sum of its parts but the sum of all possible configurations of those parts on a graph.

The basic components of the distributed computing system are agents and paths. The agents are interconnected forming a network. A path is an ordered sequence of agents. Information is exchanged between agents by the sending and receiving of probes amongst the agents in the network. Probes are also used to distribute tasks to one or more agents in the network. Probes are not necessarily broadcast to all agents and neither are they sent only point to point. Rather probes follow the path assigned to them. Thus they only travel to the agents within the ordered sequence of the path.

There is thus provided in accordance with the present invention a distributed computing system comprising a plurality of interconnected hosts one or more of which are in communication with the control mechanism a plurality of agents each agent residing on a host wherein each host is operative to host one or more agents each agent linked to at least one other agent thereby forming a distributed computing network and operative to receive process and dispatch probes amongst the agents each agent comprising one or more probe queues operative to receive and hold probes for processing by the agent at least one task to be performed by the agent and wherein probes traverse the computing network in accordance with a defined path consisting of an ordered sequence of agents to be visited by a particular probe.

There is also provided in accordance with the present invention a distributed computing system comprising a plurality of interconnected hosts a plurality of agents each agent residing on a host wherein each host is operative to host one or more agents each agent linked to one or more other agents at least part of the time thereby forming a primary computing network and operative to implement a desired objective of the computing network each agent operative to receive process and dispatch probes amongst the agents each agent comprising one or more probe queues operative to receive and hold probes for processing by the agent at least one task to be performed by the agent a control mechanism connected to at least one agent and operative to control the computing network and to generate one or more control probes to be injected into the computing network via the connected agent wherein probes traverse the computing network in accordance with a defined path consisting of an ordered sequence of agents to be visited by a particular probe and wherein a probe task is defined along the ordered sequence of agents.

There is further provided in accordance with the present invention a method of distributed computing the method comprising providing a plurality of interconnected hosts providing a plurality of agents each agent residing on a host wherein each host is operative to host one or more agents each agent linked to one or more other agents thereby forming a primary computing network and operative to collectively implement a desired objective of the computing network on each agent receiving processing and dispatching probes amongst the agents on each agent receiving and holding probes for processing by an agent in a probe queue on each agent performing at least one task controlling the computing network utilizing a control mechanism in communication with at least one agent generating control probes and injecting them into the computing network via an agent in communication with the control mechanism wherein probes traverse the computing network in accordance with a defined path consisting of an ordered sequence of agents to be visited by a particular probe and wherein a probe task is defined along the ordered sequence of agents.

There is also provided in accordance with the present invention a method of distributed computing the method comprising providing a plurality of interconnected hosts providing a plurality of agents each agent residing on a host wherein each host is operative to host one or more agents each agent linked to one or more other agents thereby forming a computing network receiving processing and dispatching probes containing at least one of data object code and source code amongst the agents defining a path through the computing network to be traversed by the probes as an ordered sequence of agents to be visited by a probe breaking down a computation into task instructions to be performed on a path performing the computation by the agents within a path and returning any results controlling the computing network utilizing a control mechanism in communication with at least one agent and generating control probes and injecting them into the computing network via an agent in communication with the control mechanism.

In the following detailed description numerous specific details are set forth in order to provide a thorough understanding of the invention. It will be understood by those skilled in the art however that the present invention may be practiced without these specific details. In other instances well known methods procedures and components have not been described in detail so as not to obscure the present invention.

The subject matter regarded as the invention is particularly pointed out and distinctly claimed in the concluding portion of the specification. The invention however both as to organization and method of operation together with objects features and advantages thereof may best be understood by reference to the following detailed description when read with the accompanying drawings.

It will be appreciated that for simplicity and clarity of illustration elements shown in the figures have not necessarily been drawn to scale. For example the dimensions of some of the elements may be exaggerated relative to other elements for clarity. Further where considered appropriate reference numerals may be repeated among the figures to indicate corresponding or analogous elements.

Because the illustrated embodiments of the present invention may for the most part be implemented using electronic components and circuits known to those skilled in the art details will not be explained in any greater extent than that considered necessary for the understanding and appreciation of the underlying concepts of the present invention and in order not to obfuscate or distract from the teachings of the present invention.

Any reference in the specification to a method should be applied mutatis mutandis to a system capable of executing the method. Any reference in the specification to a system should be applied mutatis mutandis to a method that may be executed by the system.

The following definitions apply throughout this document. The term host is defined as a computer or computational device or entity within which an agent resides i.e. that contains an agent . The term host metric is defined as the one or more values that indicate the state information of a host. The term agent is defined as an entity that links to other agents thereby forming a network i.e. nodes in a directed graph or digraph . An agent performs a single unit of computation e.g. aggregating data performing complex mathematical computation with conditional factors etc. The term probe is defined as an entity that traverses a network of agents. The term distributed computing system is defined in its conventional sense and it intended to include a collection of interconnected agents the associated probes that traverse the network and their corresponding paths. The term path is defined as an ordered sequence of agents visited by a probe i.e. the particular vertices of the digraph traversed by a probe where each vertex is an agent host . The present invention enables a task to be defined along a sequence of agents hosted on one or more computers. Thus it is a sequence of agents that performs a task as a combined entity rather than a single node as in conventional distributed computing systems.

The term agent task is defined as those behaviors assigned to a particular agent. The term primary agent is defined as an agent that implements the primary functions of a computing network. The term control probe is defined as a probe that is used as part of a control mechanism for the distributed computing system. The term probe owner is defined as the agent that owns a particular probe. The term probe type is defined as an indicator that identifies the type of probe. Example types include messaging control or working probes. The term probe queue is defined as a component of an agent that receives and processes probes. The term foreign probe is defined as a probe not owned by the processing agent. The term free probe is defined as a probe without an owner. The term message probe is defined as a probe used to pass messages through the computing network. The term working probe is defined as a probe that executes the directives of a computing network. The term payload is defined as the information attached to a probe and carried over the path of the probe. The term path length or path depth is defined as the number of steps in a probe s path.

The term fitness metric is defined as the one or more values that indicate the fitness of a particular agent. The term fitness function is defined as the function for managing the fitness metric of an agent. The term memory depth is defined as how far into the past an agent remembers previous states.

As will be appreciated by one skilled in the art the present invention may be embodied as a system method computer program product or any combination thereof. Accordingly the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore the present invention may take the form of a computer program product embodied in any tangible medium of expression having computer usable program code embodied in the medium.

The invention may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

Any combination of one or more computer usable or computer readable medium s may be utilized. The computer usable or computer readable medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus device or propagation medium. More specific examples a non exhaustive list of the computer readable medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or flash memory an optical fiber a portable compact disc read only memory CDROM an optical storage device a transmission media such as those supporting the Internet or an intranet or a magnetic storage device. Note that the computer usable or computer readable medium could even be paper or another suitable medium upon which the program is printed as the program can be electronically captured via for instance optical scanning of the paper or other medium then compiled interpreted or otherwise processed in a suitable manner if necessary and then stored in a computer memory. In the context of this document a computer usable or computer readable medium may be any medium that can contain or store the program for use by or in connection with the instruction execution system apparatus or device.

Computer program code for carrying out operations of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C C or the like conventional procedural programming languages such as the C programming language and functional programming languages such as Prolog and Lisp machine code assembler or any other suitable programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network using any type of network protocol including for example a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

The present invention is described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented or supported by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instruction means which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The invention is operational with numerous general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers cloud computing hand held or laptop devices multiprocessor systems microprocessor microcontroller or microcomputer based systems set top boxes programmable consumer electronics ASIC or FPGA core DSP core network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

In addition the invention is operational in systems incorporating sensors such as found in automated factories in mobile devices such as tablets and smartphones smart meters installed in the power grid and control systems for robot networks. In general any computation device that can host an agent can be used to implement the present invention.

A block diagram illustrating an example computer processing system adapted to implement the electronic catalog system of the present invention is shown in . The exemplary computer processing system generally referenced for implementing the invention comprises a general purpose computing device . Computing device comprises central processing unit CPU host PIC cache bridge and main memory .

The CPU comprises one or more general purpose CPU cores and optionally one or more special purpose cores e.g. DSP core floating point etc. . The one or more general purpose cores execute general purpose opcodes while the special purpose cores execute functions specific to their purpose. The CPU is coupled through the CPU local bus to a host PCI cache bridge or chipset . A second level i.e. L2 cache memory not shown may be coupled to a cache controller in the chipset. For some processors the external cache may comprise an L1 or first level cache. The bridge or chipset couples to main memory via memory bus . The main memory comprises dynamic random access memory DRAM or extended data out EDO memory or other types of memory such as ROM static RAM flash and non volatile static random access memory NVSRAM bubble memory etc.

The computing device also comprises various system components coupled to the CPU via system bus e.g. PCI . The host PCI cache bridge or chipset interfaces to the system bus such as peripheral component interconnect PCI bus. The system bus may comprise any of several types of well known bus structures using any of a variety of bus architectures. Example architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Associate VESA local bus and Peripheral Component Interconnect PCI also known as Mezzanine bus.

Various components connected to the system bus include but are not limited to non volatile memory e.g. disk based data storage video graphics adapter connected to display user input interface I F controller connected to one or more input devices such mouse tablet microphone keyboard and modem network interface controller peripheral interface controller connected to one or more external peripherals such as printer and speakers . The network interface controller is coupled to one or more devices such as data storage remote computer running one or more remote applications via a network which may comprise the Internet cloud a local area network LAN wide area network WAN storage area network SAN etc. A small computer systems interface SCSI adapter not shown may also be coupled to the system bus. The SCSI adapter can couple to various SCSI devices such as a CD ROM drive tape drive etc.

The non volatile memory may include various removable non removable volatile nonvolatile computer storage media such as hard disk drives that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like.

A user may enter commands and information into the computer through input devices connected to the user input interface . Examples of input devices include a keyboard and pointing device mouse trackball or touch pad. Other input devices may include a microphone joystick game pad satellite dish scanner etc.

The computer may operate in a networked environment via connections to one or more remote computers such as a remote computer . The remote computer may comprise a personal computer PC server router network PC peer device or other common network node and typically includes many or all of the elements described supra. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN via network interface . When used in a WAN networking environment the computer includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external is connected to the system bus via user input interface or other appropriate mechanism.

The computing system environment generally referenced is an example of a suitable computing environment and is not intended to suggest any limitation as to the scope of use or functionality of the invention. Neither should the computing environment be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary operating environment.

In one embodiment the software adapted to implement the system and methods of the present invention can also reside in the cloud. Cloud computing provides computation software data access and storage services that do not require end user knowledge of the physical location and configuration of the system that delivers the services. Cloud computing encompasses any subscription based or pay per use service and typically involves provisioning of dynamically scalable and often virtualized resources. Cloud computing providers deliver applications via the internet which can be accessed from a web browser while the business software and data are stored on servers at a remote location.

In another embodiment software adapted to implement the system and methods of the present invention is adapted to reside on a computer readable medium. Computer readable media can be any available media that can be accessed by the computer and capable of storing for later reading by a computer a computer program implementing the method of this invention. Computer readable media includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by a computer. Communication media typically embodies computer readable instructions data structures program modules or other data such as a magnetic disk within a disk drive unit. The software adapted to implement the system and methods of the present invention may also reside in whole or in part in the static or dynamic main memories or in firmware within the processor of the computer system i.e. within microcontroller microprocessor or microcomputer internal memory .

Other digital computer system configurations can also be employed to implement the system and methods of the present invention and to the extent that a particular system configuration is capable of implementing the system and methods of this invention it is equivalent to the representative digital computer system of and within the spirit and scope of this invention.

Once they are programmed to perform particular functions pursuant to instructions from program software that implements the system and methods of this invention such digital computer systems in effect become special purpose computers particular to the method of this invention. The techniques necessary for this are well known to those skilled in the art of computer systems.

It is noted that computer programs implementing the system and methods of this invention will commonly be distributed to users on a distribution medium such as floppy disk CDROM DVD flash memory portable hard disk drive etc. From there they will often be copied to a hard disk or a similar intermediate storage medium. When the programs are to be run they will be loaded either from their distribution medium or their intermediate storage medium into the execution memory of the computer configuring the computer to act in accordance with the method of this invention. All these operations are well known to those skilled in the art of computer systems.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or by combinations of special purpose hardware and computer instructions.

As mentioned supra the distributed computing system of the present invention is a system and method for distributed computation based upon a novel partitioning of computer networks. In the system instructions are disseminated to select agents on a computer network each of which is a member of at least one path i.e. a set of one or more connected agents also within the network . The computation is then performed by the agents of the path then returned. The system is operative to break down a computation not into instructions on individual agents but rather into instructions on a unique ordered sequence of agents. This vastly increases the expressive power of a single network to be not only the sum of its parts but the sum of all possible configurations of those parts on a graph.

The fundamental components of the system are agents probes and paths. An agent is a computer or computational device that performs a single unit of computation e.g. aggregates data or performs a complex mathematical computation with conditional factors.

A path is an ordered sequence of agents. In a path of n agents we can identify agents by their sequence number i . . . i i. There is no restriction to path constructions as path lengths may be finite or infinite. Paths may loop be singular or overlap in any fashion. Thus if any given agent is i and its identity is ident i it may be that ident i ident i for any 1 j k n. Note that it is possible that a sequence of n agents be entirely composed of the same agent. Further a path is uniquely identified by the order of its members two paths with the same sequence of agent identity are by definition the same path. Note however that two probes can traverse an identical path and exhibit completely different behaviors. Further a probe can traverse the same path multiple times and exhibit different behavior each time. Note also that an effectively infinite path is possible if a free probe is assigned a non terminating random walk through the graph. Other quasi infinite pathing is also possible. In addition the traversal of the edge of a graph can have effects on the behavior of a computing network due to variations in transit time. This means that a set of probes cannot be counted on to arrive in any particular order and hence and agent could process the same set of probes at different times and get a different result each time.

In one embodiment agents are able to communicate with their neighbors. The underlying method of communication between any two agents in a path depends upon the underlying computing device. Throughput this document the term neighbor is used to describe the agents before and after the given agent in a path. Thus given agent iand j 0 agents iand iare the agent s neighbors. Note however that a path that terminates has no previous neighbor to the first agent of the path and no next neighbor to the last agent of the path.

Pathing is important to a computing network as communication with other agents happens through the exchange of probes along defined paths. The assignment of a path is performed using methods described infra. The actual structure of a path is also important. The path structure is dependent on the particular implementation. This document uses the term neighbor where two nodes of a graph are neighbors if the path length between them is one. This however is independent of the structure of the entire graph. The algorithm that determines the path is dependent on the purpose of the distributed computing network. For example consider an analysis of transit time between internet routers. In this case the pathing reflects the actual connections made among the internet infrastructure and their geographical location. In a financial application for example agents are attached to individual stock issues on the New York Stock Exchange and the pathing of the probes weighted according to industry segment. In one embodiment the pathing is generally assigned by the control system but paths can self modify by probes interacting with agents in their path. In this case the path would be modified without intervention from any control mechanism.

Regarding knowledge of the network agents generally know very little about the network as a whole. Agents only gain such knowledge by interacting with probes received from other agents. The knowledge an agent has can be effected by how the computing network is bootstrapped. In one embodiment the control server contains an exhaustive list of agents which is only necessary during bootstrapping. Once the computing network is initialized this knowledge is actually embodied in the probe payloads paths and agent states of the network itself. Once initialized the control server discards the exhaustive list and a properly implemented computing network can still function.

Regarding communication between agents communication via probes is differentiated from the communication protocols of the host devices. The only form of communication between agents is through the exchange of probes. The communication protocols of the hosts are utilized by the agents and probes.

As described supra an agent is connected i.e. in communication with to one or more other agents. The connection however may be temporary in that an agent only communicates with other agents part of the time. For example for security reasons an agent may lie disconnected from other agents for most of the time while connecting with one or more agents only for heartbeat purposes or to send and receive probes and then returns to a disconnected state.

A computing device participates in the network by running agent software. Any computer device may run multiple instances of the agent software each of which may be configured to connect and operate within different computing networks. This implies that each agent carries an identifier used to distinguish between traffic from other networks. There are no restrictions on the number of agents that may be hosted except for the limitations of system and network resources.

A computation in a distributed computing network comprises a sequence of instructions such as those described above upon the unique ordered sequence of agents in a path. Using the example of aggregating data data from each machine might be aggregated into a vector representative of the path where each vector s elements corresponding with the path index would be fulfilled by that agent in the path. Note that computation may occur in parallel or in ordered sequence across the path.

Note that path computation is not necessarily sequential across agents although in some instances e.g. network monitoring the transit time between agents is itself a component of the computation. In the parallel case computation is performed independently but accumulated in an ordered sequence.

A computation is not restricted to any form computation may be as simple as a single hardware instruction or as complicated as data analysis and beyond. Computation may consist of gathering and producing data performing some sort of processing etc.

A special type of computation performs administrative tasks on behalf of the network itself. For example assume a series of non overlapping computation paths on a network. Then create another path referred to as an administrative path that spans each of the computation paths at the head and tail of each path s sequence. The function of the administrative path could be to produce instructions to the head agent and consume from the tail.

By the definition of a sequence of agents i.e. a path neighboring agents must necessarily be connected. The manner of this connection is not restricted to any particular form and is not critical to operation of the invention agents may communicate indirectly through a relay server or by a direct network or modem connection.

An agent that cannot communicate with its neighbors is still a member of the path but that path is considered degenerative until communication is reestablished. The process of detecting degenerative paths may itself be a computation performed by a network where paths overlap strongly to enable detecting faulty links between any two neighbor agents.

An agent network is defined by the agents that identify with the given network. Thus for example if there are four uniquely identified agents within a system the network is said to be of size four.

The method of path construction can be either static i.e. exogenous or dynamic i.e. endogenous . For example a agent s paths may be predefined when that agent is installed. Path creation may also be part of a computation request in which case the path overlay is dynamic. Paths need not follow any special creation logic. In some embodiments paths may be completely random such as for an application for conditional logic analysis where random perturbations are important.

In some cases a network agent will start up and contact a predefined agent or set of agents within its network for a configuration where the set of agents have a long running instruction to perform this function. In other cases a fixed master administrative agent e.g. control mechanism fulfills this function. In other embodiments an agent starts up and broadcasts to any available configuration. In another embodiment an agent may have instructions to start up and failing to find any other agents itself listen for other agents and act as a master agent.

Control of a network depends upon its structure. In one embodiment agents are directly or indirectly part of an administrative path which may comprise one master agent which may be a control server for example . A human administrator may then execute commands on the control server which propagates through administrative paths to each agent. In one embodiment a control mechanism e.g. computer server mobile device etc. equipped with a user interface analytical tools databases etc. is connected to or co located on one of the agents in the network. Probes e.g. control probes containing control information and or control related tasks are generated by the control mechanism and passed to the agent on the agent. The agent functions to inject the control probes into the computing network.

A diagram illustrating the structure of an example probe in accordance with the present invention is shown in . The probe generally referenced comprises a plurality of fields including a path payload type and owner . Note that a probe may comprise other fields in accordance with the particular implementation of the present invention.

A diagram illustrating an example path portion of a probe consisting of an agent list is shown in . The path is a sequence of values e.g. A A . . . Ai . . . An specifying the graph edges traversed by a probe. Each value in the path specifies the location of an agent in the graph i.e. the computing network . In one embodiment the path is a list with an index pointing to the value that indicates the current location in the graph. In this example the current location is indicated by Ai. In operation the probe traverses the graph in list order unless overridden by specific actions of an agent. The path can be modified by any agent in a probe s path list.

In one embodiment agents do not require knowledge about the structure of the graph i.e. network . It simply passes probes to the next agent. Its task can include instructions to issue control probes under prescribed conditions.

Paths are generated and modified through multiple methods. Bootstrapping a computing system utilizes a control server that has a comprehensive list of all agents in a nascent computing system. The control entity or server assigns paths as needed to initialize the computing system. Once bootstrapped however the control mechanism can modify the probe paths of any agents in the system. An agent can even be tasked to create new agents and insert them into the primary computing network with or without the intervention of a control mechanism or server.

A diagram illustrating an example payload portion of a probe consisting of data object code and or source code is shown in . The payload of the probe is part of the storage and transport mechanism of a computing system. The payload may comprise any form of data data structure executable code i.e. object code or uncompiled code i.e. source code . The payload can also comprise an agent as object code or a serialized object. The payload can be added removed modified executed or compiled by any agent in the path list.

The type portion of a probe is an identifier that is used to encapsulate specific behaviors. Example behaviors include control messaging and working. Note that this field or element is programmable and is therefore not limited to these three types. Note also that the probe type can be correlated to a queue type.

A diagram illustrating an example owner portion of a probe consisting of an agent ID is shown in . A probe can be owned by a particular agent. The ownership field indicates the agent that owns the probe. An agent has special rights when processing a probe that it owns enabling operations that could not otherwise be performed if not owned by the agent. Note that ownership of a probe can be transferred or revoked. A probe without a designated owner is a free probe. Ownership can be identified by an agent ID field in a probe or a probe ID field in an agent. Note also that probes can be co owned by two or more agents.

Agents are the entities residing on hosts that receive process generate and transmit probes to other agents. A diagram illustrating the structure of an example agent in accordance with the present invention is shown in . In one embodiment agents generally referenced comprise one or more probe queues one or more fitness functions one or more fitness metrics one or more probe lists one or more tasks and one or more host metrics .

An agent comprises one or more probe queues . Each non empty probe queue queues may be empty comprises one or more probes . The probe queue receives and holds i.e. stores probes for processing by the agent. After processing is complete a probe is either 1 dispatched to the next agent in the probe s path list 2 deactivated or 3 destroyed.

The task is the agent s mandate or mission in the computing network and may include any interaction with the host probe probe queues host metrics fitness metrics or fitness functions. Alternatively the task may be entirely independent of any of the above elements. Example tasks include 1 reading a value from a sensor in a highly automated manufacturing system 2 processing a probe payload and 3 invoking host behaviors e.g. toggling a switch.

Host metrics comprise data and or functions that define the current state of the agent s host. An agent can own one or more probes. Ownership is indicated by 1 a probe list of probe IDs in the agent or 2 a probe list of agent IDs in a probe. Note that probes can be co owned by a plurality of agents.

The fitness function manages the fitness of an agent. The fitness metric represents the overall health of an agent. The fitness metric may comprise a single scalar value a complex set of values and data structures or another computing network. It is noted that the present invention supports flat hierarchical and recursive structures. A probe carrying an agent carrying a probe carrying an agent creates recursion. The ability to handle recursion enables the creation of numerous possibilities for network behavior. A probe may also have a null payload i.e. no payload . This is useful in situations where it is desired to modify network behavior by injecting multiple probes without a payload thereby slowing down the network or for identifying bottlenecks in network throughput.

A diagram illustrating the structure of an example distributed computing system in accordance with the present invention is shown in . The system generally referenced comprises a plurality of agents each residing on a host . Each agent comprising at least one probe queue comprising a plurality of probes . In operation any number of probes may be traversing the network being exchanged between agents.

The computing system is the collection of agents exchanging probes. Each agent resides on a host and a host may be hosting one or more agents. In one embodiment the exchange of probes is asynchronous. Although in an alternative embodiment the exchange of probes may be fully synchronous. A host may comprise any physical or virtual device or software. The hosts are not required to be of the same type. Note that a heterogeneous computing network may comprise any combination of software and hardware hosted agents.

In one embodiment. probes are owned by an agent. This does imply however that paths can be circular starting and ending at the owning agent. Ownership can allow selective processing of probes by an agent. An agent can be configured i.e. programmed to only respond to probes owned by a specific agent or it could be configured to clone or destroy probes owned by a particular agent. In the case where an agent is tasked with reacting to probes from a specific agent when a probe is received from that specific agent it can then be destroyed or re pathed never returning to the originating owner. In this case the original owner might be programmed to issue a probe at set time intervals or issue a new probe if an issued probe has not returned within a specified time interval.

Probes always have their paths assigned or altered by an agent or control server. This raises the possibility that a probe carrying an agent as a payload can arrive at an agent that interacts with that payload and adjusts the probe s path. A recursive network can be created for example if the carried agent also owns probes that have agents as payloads.

Note that an unconnected agent is generally considered an anomaly but may occur in practice. In one embodiment one or more agents can be tasked with reconnecting an orphaned agent. Alternatively an agent could be programmed to phone home if it remains disconnected for a predefined length of time. In addition note that an agent could deliberately disconnect itself from the network as a security measure reconnecting to one or more agents at some future time to complete its task s .

As described supra each agent comprises one or more probe queues. The queue plays a role in the control mechanism of the computing network. An agent receives probes from the network and processes them in accordance with instructions defined in the agent task . Note that probe queues can be typed. A typed probe queue can only receive probes that match its particular type e.g. control message working etc. . Typed probe queues make the implementation of probe processing less complex. Typed probes can be processed in a general queue as long as the agent task is configured i.e. programmed to handle that particular probe type. In another embodiment a single probe queue is used to receive all probes regardless of type.

A diagram illustrating an example structure of a general queue of an agent is shown in . The general queue generally referenced comprises one or more probes P P . . . Pn . The arrow indicates the next probe P to be processed. In one embodiment the default behavior is to process received probes in first in first out FIFO order but in other embodiments can be any order. This behavior however can be overridden by the task instructions of the agent. Note that a general probe queue can receive probes of any type.

A diagram illustrating an example structure of a control queue of an agent is shown in . The control queue generally referenced comprises one or more control probes P P . . . Pn . The arrow indicates the next probe P to be processed. A control queue is a specialized queue used to receive and process instructions from the network control mechanism. In one embodiment an agent comprises a control queue by default. In an alternative embodiment agents may not have a control queue by default. Note that the control queue can only receive control probes issued by the control mechanism. Note also that agents can issue control probes based on the state of the primary network or interactions with other agents without directive or intervention from the control mechanism.

A diagram illustrating an example structure of a message queue of an agent is shown in . The message queue generally referenced comprises one or more message probes P P . . . Pn . The arrow indicates the next probe P to be processed. The message queue functions to receive message probes from the computing network.

A diagram illustrating an example structure of an inactive queue of an agent is shown in . The inactive queue generally referenced comprises one or more deactivated probes P P . . . Pn . The arrow indicates the next probe P to be processed. The inactive queue is also a specialized queue. It is used to store probes that are deactivated by an agent. Probes in the inactive queue can be deactivated reactivated or destroyed by an agent based on the state of the agent or by a directive issued from the control mechanism.

Regarding the queues shown in practically the queues actually contain zero or more probes. In each Figure a queue can be empty which may occur in the event the fitness function is tied to queues in a manner where if a queue remains empty for a specified time interval the agent task invokes special behavior. In another embodiment an empty queue could similarly invoke behaviors on the host e.g. notify an operator that the agent is not receiving any probes.

A path as defined supra is the sequence of agents visited by a probe. Paths can be simple or complex depending on the configuration of the particular network. For example paths can have cycles terminate and branch or have any other combination of characteristics. Note that path branching is achieved by creating additional probes at the branch point. Several examples of different paths are presented below.

A diagram illustrating an example cyclic path for an agent is shown in . The example cyclic path generally referenced comprises a plurality of agents A A A A A A A and an example probe having a path A A A A A A A. A cyclic path returns a probe to the first agent in its path list. The probe continues to follow this path until it is deactivated or destroyed by an agent.

A diagram illustrating an example terminating path for an agent is shown in . The example terminating path generally referenced comprises a plurality of agents A A A A A and an example probe having a path A A A A A. A terminating path ends at the last agent in the path list. The probe is either destroyed deactivated or returned to the control system for reassignment to a different part of the computing network.

A diagram illustrating an example repeating multiple cycle path for an agent is shown in . The example repeating multiple cycle path generally referenced comprises a plurality of agents A A A A A and an example probe having a path A A A A A A A A A. In one embodiment a path can have repeating cycles and or multiple cycles.

A diagram illustrating an example branched path for an agent is shown in . The example branched path generally referenced comprises a plurality of agents A A A A A and A probe having a composite path A A A A A A A A A A probe having branched probe path A A A probe having branched probe path A A and probe having branched probe path A A . Note that to make the notation clear whether these paths terminate or return home the home agent is included as the final step in the path.

A diagram illustrating an example agent structure related to message passing is shown in . The agent generally referenced comprises a general queue message queue and task . A diagram illustrating an example message queue related to message passing is shown in . The message queue comprises a plurality of probes received from the network. In this message passing example the probe has a type Message. The probe payload comprises message ID message target ID and owner ID field.

In one embodiment the message processing utilizes a message queue . In an alternative embodiment the task may contain instructions for processing typed probes using a single general queue. In this case the separate message queue is not required for broadcasting and receiving messages. In general agents are operative to perform at least one task. The task however could be a no op i.e. no operation such as simply passing a probe to the next agent on the probe s path.

In the example embodiment presented herein each agent has ownership of a single message probe. Alternative implementations may or may not require ownership of a message probe or may allow for ownership of a plurality of message probes.

A flow diagram illustrating an example message processing method of the present invention is shown in . Initially a probe is first received from the network by an agent step . If the probe is a message probe step it is inserted into the message queue step . Otherwise the probe is inserted into the general queue step . The first probe in the message is then retrieved step . If the agent owns the received probe step the message is deleted and the probe is deactivated step .

If the agent does not own the probe then the agent then reads the message ID step and compares it to previously received messages step . If the message has been previously received it passes the probe to the next agent in the probe s path step . If the message has not been previously received the message and the message ID is written to a message table step . The message and message ID from the message table are then written to the agent s owned message probe step . Both the foreign message probe and the owned message probe are dispatched to the agent in their respective probes path step .

A diagram illustrating an example distributed computing system constructed in accordance with the present invention is shown in . The example system generally referenced comprises a control mechanism e.g. control server one or more agents A one or more control probes CP and one or more working probes WP . Note that the path of working probe is represented by dashed dotted arrows . Similarly the path of working probe is represented by dashed arrows . The path of working probe is represented by dotted arrows .

In one embodiment a distributed computing system comprises a minimum of a control server and agents . The agents within dashed circle are considered the primary computing network and function to execute the mandate or mission of the specific implementation of the computing network. The agents outside the dashed circle are tasked to function as part of the control mechanism. The method for exerting control over the computing network includes the control server inserting control instructions to a control probe and the injecting the probe into the agent network. Note that in one embodiment the top level control server or mechanism comprises multiple independent computers injecting control probes into different segments of agents. Recipient agents outside the dashed circle receive and process the injected control probes and pass them to the primary computing network inside the dashed circle. When a primary agent receives a control probe it executes any relevant instructions contained in the probe e.g. executing object code compiling and then running source code etc. Primary agents return data to the control server by inserting data into the payload of a control probe and injecting it into the network.

An agent is capable of receiving control probes and passing the control probes to the next agent in the path. An agent can modify a control probe issued from a control server or other agent or issue control probes based on the state of the primary computing network its own state or the aggregate state of other agents that it interacts with.

In one embodiment typed queues are a convenience for implementation. This allows programming to prioritize probe processing in different ways depending on the intent of the network. For example an agent can be programmed to always process any control probes in the control queue before processing probes in the working queue. This could be accomplished in a single general queue but it would require scanning the entire queue for control probes before processing a working probe that is at the head of the queue. Similarly message queues could be prioritized over working queues. Alternatively the queues could be processed by stepping through each queue type in sequence always processing the first probe in each queue. Again this could be accomplished in a single queue but it would require scanning the queue for the desired probe type. It is possible that the type of probe being sought could reside at the tail of the queue forcing a scan of the entire queue to find it. If the queue is extremely large this could affect performance.

With reference to it is noted that the control example illustrated therein embodies a strongly hierarchical structure between agents and the control server. There is however nothing preventing the control server from being a network itself or the agent network structure not being a flat layer. In addition these structures can be recursive as shown in . In this Figure probes carrying payloads incorporating other probes or agents are illustrated as well as probes carrying probes carrying agents with queues containing probes carrying other probes or agents.

A diagram illustrating an example control server is shown in . The example control server generally referenced may comprise a general purpose computer such as shown and described in connection with . In one embodiment the control server comprises a processor and hosts the user interface visualization code analytics code and the zero or more various databases required to store the data collected by the primary computing network. Note that alternatively the control server can be implemented without the use of a database internal to the control server. In this embodiment what the computing network knows is embodied in the agents and probes themselves is retrieved by traversing the network. In general however a database is preferred even if it only used as a record of states and data or as an integral part of agent tasks.

Regarding authentication and authorization it is noted that in a pure i.e. non hostile environment there is no need for authentication and authorization. If an agent receives a control probe it is not important for it to know where it came from. It could not have even received the probe unless some other part of the system knows where it is and sends it a control probe. This holds true for any probe type.

In a non pure i.e. potentially hostile however this is a different problem because the system must contend with attempts to inject counterfeit probes into the system the attaching of counterfeit agents to a network and the hijacking of agents segments of the network or even a complete takeover of an entire network by a bad actor.

Several well known methods of authentication and authorization can be used with the distributed computing system of the present invention. For example authentication and authorization can be implemented utilizing encrypted lists of agents that define what agents a particular agent is allowed to send control probes to. Alternatively encrypted lists of agents on a primary agent that designate which agents are authorized to issue control probes can also be used. Similar lists of agents that authenticate a working probe are another alternative.

In another embodiment authentication and authorization are implemented by each probe and agent containing a digital wallet with a single crypto currency coin in it. These coins are issued using well known block chain technology and are believed to be impossible to counterfeit. A probe only needs to exchange its coin with the agent that it is visiting. If both the agent and probe exchange valid coins then the transaction is authorized. Preferably the block chain is not managed publicly like Bit Coin but privately behind a hardened firewall.

A diagram illustrating an example hierarchical distributed computing system configuration is shown in . In this example distributed computing network generally referenced the control server agents and primary agents are organized in hierarchical fashion. Typically an operational network is hierarchical but this is not a requirement. Since probes may comprise agents within their payload and agents function to provide control by designation only many other configurations besides a hierarchical configuration are possible. An agent can both control other agents and be a primary agent this being resolved by context in the particular implementation of the invention.

A diagram illustrating an example Turing machine is shown in . As is well known to those skilled in the computer arts a Turing machine is a computer science construct created by Alan Turing as a computation model and is a cornerstone of modern computers. A Turing machine is defined as a read write head containing a program and a tape of symbols in individual cells . The head can read from a cell write to a cell or move one cell left or right. The program contained within the head determines which action is to be taken.

A diagram illustrating an example Turing machine constructed from agents and probes of the resent invention is shown in . The example system generally referenced comprises at least one probe and an agent network . The agent network based network system of the present invention is capable of emulating a Turing machine and can thus be configured to function as a general computing system.

The system of agents and probes of the present invention can be configured for example as shown in to operate as a Turning machine by viewing a probe as the machine head and the agents on the probe s path as the cells of the tape. The payload of the probe comprises the executable code i.e. the program of the Turing machine and each agent in the path comprises the symbol as its fitness metric. The probe reads the fitness metric writes to the fitness metric moves to the next agent in its path or moves to the previous agent in its path

As described supra the distributed computing network mechanism of the present invention is capable of establishing self evolving self organizing networks that change dynamically over time by use of agents and probes. In addition the distributed computing network mechanism of the present invention is capable of generating strictly deterministic logic circuits as well. An advantage of the mechanism of the invention is its ability to create self organizing capabilities while embedding deterministic logic circuits into the system.

A diagram illustrating a first example of logical AND emulation utilizing agents and probes of the present invention is shown in . The example agent comprises two probe queues and agent task that implements the logical AND function. In operation the agent receives two probes and stores them in separate queues. If one of the queues is empty the agent waits to receive a probe in the empty queue. The probe payload may comprise either 0 or 1 . The agent task reads the payload of each probe performs the logical operation destroys the two probes creates a new probe and path writes the result to the new probe payload and dispatches the new probe to the network.

A diagram illustrating a second example of logical AND emulation utilizing agents and probes of the present invention is shown in . The example agent comprises one probe queue and agent task that implements the logical AND function. In operation the agent receives two probes and stores them in the single queue. If more than two probes are in the queue only the first two are processed. If only one probe is in the queue the agent waits for a second probe to arrive. The probe payload may comprise either 0 or 1 . The agent task reads the payload of each probe performs the logical operation destroys the two probes creates a new probe and path writes the result to the new probe payload and dispatches the new probe to the network.

A diagram illustrating a first example of logical OR emulation utilizing agents and probes of the present invention is shown in . The example agent comprises two probe queues and agent task that implements the logical OR function. In operation the agent receives two probes and stores them in separate queues. If one of the queues is empty the agent waits to receive a probe in the empty queue. The probe payload may comprise either 0 or 1 . The agent task reads the payload of each probe performs the logical operation destroys the two probes creates a new probe and path writes the result to the new probe payload and dispatches the new probe to the network.

A diagram illustrating a second example of logical OR emulation utilizing agents and probes of the present invention is shown in . The example agent comprises one probe queue and agent task that implements the logical OR function. In operation the agent receives two probes and stores them in the single queue. If more than two probes are in the queue only the first two are processed. If only one probe is in the queue the agent waits for a second probe to arrive. The probe payload may comprise either 0 or 1 . The agent task reads the payload of each probe performs the logical operation destroys the two probes creates a new probe and path writes the result to the new probe payload and dispatches the new probe to the network.

A diagram illustrating an example of logical NOT emulation utilizing agents and probes of the present invention is shown in . The example agent comprises one probe queue and agent task that implements the logical NOT function. In operation the agent receives a probe and stores it in a single probe queue. The probe payload may comprise either 0 or 1 . The agent task reads the payload of the probe performs the logical NOT operation destroys the probe creates a new probe and path writes the result to the new probe payload and dispatches the new probe to the network.

Note that since the distributed computing mechanism of the present invent is capable of modeling logic gates it is also capable of modeling any combination of logic gates. Therefore a large enough network of agents can model any arbitrary collection of logic gates including but not limited to digital circuits digital memory registers processors instruction queues etc. Further a complete Von Neumann architecture or any other computer architecture can be modeled using the distributed computing mechanism of the present invention.

A diagram illustrating an example computing network configured to emulate digital logic circuits is shown in . The example distributed computing system generally referenced comprises a primary computing network configured to emulate embedded logic circuits i.e. primary network hosts agents independent networks and interacting computing networks . In one embodiment the logic gates of the primary network are implemented by agents. The structure of an example agent is shown comprising one or more probes that provide the input to the emulated logic gate or gate in this example . The output of the gate is a probe that is transmitted to another agent or network. Note that input probes may be received on none one or both inputs of the logic gate in each agent.

A diagram illustrating a first example of a neural network is shown in . The network generally referenced comprises a plurality of nodes including an input layer one or more internal layers and an output layer .

A diagram illustrating a second example of a neural network constructed utilizing agents and probes of the present invention is shown in . The example neural network generally referenced comprises input probes output probes dispatched to one or more agents an agent including a queue host metrics and agent task . In operation the host metrics contain a table of weights for each connection to the next layer in the neural network. In one embodiment the agent task functions to read the weights from the host metrics destroy the incoming probe and create a new probe for each agent in the next neural layer. The payload of each new probe has the weighting applied to the payload of the input probe.

It is noted that an advantage of creating a neural network using the distributed computing mechanism of the present invention is the ability to inject new behavior via control probes. This turns a static neural network into one that is adaptive and dynamic. A neural network can be initialized and trained using well known techniques then embedded into a computing network of the present invention. As the data throughput evolves as occurs in the real world the original neural network is able to evolve with it.

A diagram illustrating an example breakdown of a computation and distribution of tasks to agents in a path is shown in . The example network generally referenced comprises a plurality of agents implemented on host computing devices and a control mechanism . A distributable computation is broken down using well known distributed computing techniques into a plurality of tasks . In this example the computation is broken down into four tasks namely Tasks 1 4 or T. A fifth task Task T is assigned to an agent and is responsible for assembling the results of the four computational tasks T. These tasks are distributed by the control mechanism to the agents that are located in the particular defined ordered path via probes . In this example each probe delivers a particular task to its corresponding agent. Initially the agents are not configured with the task yet as indicated by the No Task block in each agent in the path.

A diagram illustrating an example performance of a computation by the agents in a path is shown in . Once the agents in the defined ordered path are configured with their respective tasks T the computation can be performed. In this example the data for the computation is provided to the control mechanism . This however is not the only way the agents acquire data as one skilled in the art can contemplate numerous other ways for agents to acquire data. For example one or more agents may acquire their own data or acquire it from an external source other than the control mechanism. The data is broken own for each individual task by the control mechanism. The apportioned data for the computation is sent to the agents via probes . Data earmarked for each task is sent via probe to the respective agent. For example data Dfor task Tis delivered to agent implementing task Tvia probe D . Data for the agents implementing task Tare delivered to their respective agents via corresponding probes in similar fashion. Note that in this example the control mechanism does not send any data via a probe to agent .

Once their respective data is received by the agents the computation is performed by executing the particular task previously loaded into each respective agent. Task Tin agent is configured to take the results Rand generate a final result R for the entire computation that is then sent to the control mechanism for output as result to another process.

A flow diagram illustrating an example method of distributing computing is shown in . A plurality of interconnected host computing devices are provided step . A plurality of agents are provided whereby each agent is implemented on a host computing device step . Agents are linked together to form a distributed computing network step . The agents generate receive and process probes which contain data object and or source code step . The probes are sent and received only amongst the agents located on a path which is defined as an ordered sequence of agents step .

A computation is the broken down into multiple tasks to be performed by the agents on a path step . The tasks are distributed to the agents on the path and these agents execute their respective task s and generate one or more results. The results denoted R are returned via a probe s to a suitable entity such as a control mechanism a selected agent in the path or a device external to the path or to the network step .

A control mechanism is provided that is in communication with at least one agent in the network step . Control probes are generated by the control mechanism and injected into the network via an agent that is in communication with the control mechanism step .

Listing 1 presented hereinbelow is a pseudo code listing of an example distributed computing system constructed in accordance with the present invention. This pseudo code can be used in a system that initializes probes and agents passes probes through the network on randomized paths and applies stress to the system by degrading performance of individual agents. In this example system the concept of Fitness Metric and Fitness Function is embodied simply as Stress . Host Metrics are implicit as transit times of agents through the network and not an explicit values extracted from the host. The system as constructed by the inventor is a single instance software application in a synchronous single threaded mode. The system was written is in Java and as such the pseudo code in Listing 1 reflects the object oriented structure of that language. There are three classes in the following listing 

1. AgentManager This class implements the control system. In a full implementation this would be replaced by a control server or servers another computational network or one or more other components.

3. Probe There are no typed probes in this example pseudo code listing. There are no message probes or control probes. All probes are considered working probes and as such the pseudo code does not contain a Type field. Probe ownership is designated by an AgentID field on each probe.

Note that the terminology used in this example pseudo code listing differs slightly from that used supra. For clarity wherever the word stress appears in the listing below it is meant to refer to fitness . Stress is introduced into the network i.e. fitness reduced by degrading the throughput of individual agents. As stress increases i.e. fitness decreases the rate at which an agent dispatches probes is reduced. Probes are docked and launched i.e. received and dispatched . For simplicity probes generate their own path. This does not reflect how the specification is written as it assumes knowledge of the network that in practice cannot be assumed. In a full implementation of the computational system the probe would have its path assigned by the control mechanism. In general mixed case refers to a member or function in the class while ALL CAPS is pseudo code and may or may not refer to an actual field or function in a class. Comments are italicized and follow a double slash or are delineated with . . . . Data types are not specified nor are return values.

It is noted that the listing above does not support the communication layer necessary to connect separate hosts. This is because the communication protocol for each host type can vary and including it in the prototype is not necessary to demonstrate the core functioning. The above listing is a simulation of an agent network that only demonstrates the pathing probe transit agent tasking and fitness aspects. Note however that the communication layer is by design loosely coupled to the core agent probe behaviors.

The agent manager can serve as a good proxy for a control system. It functions to create and initialize probes and agents and manage the state of the system as a whole. But for clarity sake it does not address any difficult issues a real world implementation would have to deal with such as agents being off line authentication and authorization injecting control probes etc. The Agent Manager serves as a good illustration of the flexibility of the control system. The controller only includes the essentials necessary to allow probes to navigate a network and interact with agents. One skilled in the distributed computing art can start with the above model and add complexity to the control system to suit the particular problem space.

Those skilled in the art will recognize that the boundaries between logic and circuit blocks are merely illustrative and that alternative embodiments may merge logic blocks or circuit elements or impose an alternate decomposition of functionality upon various logic blocks or circuit elements. Thus it is to be understood that the architectures depicted herein are merely exemplary and that in fact many other architectures may be implemented which achieve the same functionality.

Any arrangement of components to achieve the same functionality is effectively associated such that the desired functionality is achieved. Hence any two components herein combined to achieve a particular functionality may be seen as associated with each other such that the desired functionality is achieved irrespective of architectures or intermediary components. Likewise any two components so associated can also be viewed as being operably connected or operably coupled to each other to achieve the desired functionality.

Furthermore those skilled in the art will recognize that boundaries between the above described operations merely illustrative. The multiple operations may be combined into a single operation a single operation may be distributed in additional operations and operations may be executed at least partially overlapping in time. Moreover alternative embodiments may include multiple instances of a particular operation and the order of operations may be altered in various other embodiments.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

In the claims any reference signs placed between parentheses shall not be construed as limiting the claim. The use of introductory phrases such as at least one and one or more in the claims should not be construed to imply that the introduction of another claim element by the indefinite articles a or an limits any particular claim containing such introduced claim element to inventions containing only one such element even when the same claim includes the introductory phrases one or more or at least one and indefinite articles such as a or an. The same holds true for the use of definite articles. Unless stated otherwise terms such as first second etc. are used to arbitrarily distinguish between the elements such terms describe. Thus these terms are not necessarily intended to indicate temporal or other prioritization of such elements. The mere fact that certain measures are recited in mutually different claims does not indicate that a combination of these measures cannot be used to advantage.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. As numerous modifications and changes will readily occur to those skilled in the art it is intended that the invention not be limited to the limited number of embodiments described herein. Accordingly it will be appreciated that all suitable variations modifications and equivalents may be resorted to falling within the spirit and scope of the present invention. The embodiments were chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

