---

title: Systems and methods for transferring message data
abstract: Methods, systems, and apparatus, including computer programs encoded on a computer storage medium, are described for providing messages to client devices. In certain examples, a stream of messages is provided to a messaging application on a client device at a desired message feed rate. A message download rate of the stream of messages by the messaging application is monitored. A determination is made that the message download rate is less than the desired message feed rate. In response, the stream of messages is provided to a buffer on the client device at the desired message feed rate, and the stream of messages is sent from the buffer to the messaging application at the message download rate. A determination is made that the message download rate is greater than the desired message feed rate and, in response, a stored quantity of messages on the buffer is allowed to decrease. A determination is made that the stored quantity of messages on the buffer is zero and, in response, the stream of messages is provided to the messaging application at the desired message feed rate.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09608953&OS=09608953&RS=09608953
owner: Machine Zone, Inc.
number: 09608953
owner_city: Palo Alto
owner_country: US
publication_date: 20160629
---
This application is a continuation of and claims priority from U.S. patent application Ser. No. 14 885 034 filed on Oct. 16 2015 the disclosure of which is hereby incorporated by reference in its entirety.

This specification relates to a data communication system and in particular a system that implements real time scalable publish subscribe messaging.

The publish subscribe pattern or PubSub is a data communication messaging arrangement implemented by software systems where so called publishers publish messages to topics and so called subscribers receive the messages pertaining to particular topics that are subscribed to. There can be one or more publishers per topic and publishers generally have no knowledge of what subscribers if any will receive the published messages. Some PubSub systems do not cache messages or have small caches meaning that subscribers may not receive messages that were published before the time of subscription to a particular topic. PubSub systems can be susceptible to performance instability during surges of message publications or as the number of subscribers to a particular topic increases. Further existing Pubsub systems may attempt to process as many events and messages as possible on the client device. This leads to performance degradation when the flow of messages is too high for the client device.

Examples of the systems and methods described herein are used to process messages and other data received at client devices of users. In instances when a messaging application on a client device is unable to keep up with a rate at which messages are received on the client device the messages are diverted to a buffer on the client device. The buffer then forwards the messages to the messaging application preferably in an order in which the messages were received. The buffer stores the message data temporarily and sends the messages to the messaging application at a rate the messaging application is able to handle e.g. a maximum download rate for the messaging application . In general the buffer accumulates message data when the buffer receives messages faster than the messages are forward from the buffer to the messaging application. Likewise the buffer stores fewer messages when the buffer receives messages at a lower rate than the messages are forwarded from the buffer to the messaging application. Accordingly the buffer is able to provide messages to the messaging application at a rate that is suitable for the messaging application such that the messaging device receives messages in a proper order and at a proper rate. This avoids problems associated with prior systems in which a messaging application may receive messages too quickly and as a result may drop certain messages and or crash due to overload.

In general one aspect of the subject matter described in this specification relates to a method. The method includes performing by one or more computers the following steps receiving at a client device a stream of messages from a sender providing the stream of messages to a messaging application on the client device at a desired message feed rate associated with the sender monitoring a message download rate of the stream of messages by the messaging application determining that the message download rate is less than the desired message feed rate and in response providing the stream of messages to a buffer on the client device at the desired message feed rate and sending the stream of messages from the buffer to the messaging application at the message download rate determining that the message download rate is greater than the desired message feed rate and in response allowing a stored quantity of messages on the buffer to decrease and determining that the stored quantity of messages on the buffer is zero and in response providing the stream of messages to the messaging application at the desired message feed rate.

In certain examples the stream of messages corresponds to a single channel in a PubSub system or alternatively to a plurality of channels in a PubSub system. The buffer may include a plurality of buffers and each buffer in the plurality of buffers may correspond to one channel in the plurality of channels. In various instances the sender is or includes an MX node in a PubSub system. The desired message feed rate may correspond to a rate at which messages are published in a PubSub system. In some implementations the download rate corresponds to a maximum rate at which the messaging application is able to download messages. The download rate may depend on for example a desired refresh rate for the client device.

In some examples sending the stream of messages from the buffer to the client device may include sending messages in an order in which the messages were received by the buffer. In general the stored quantity of messages on the buffer increases e.g. message data accumulates on the buffer when the desired message feed rate is greater than the message download rate. In various examples the stored quantity of messages on the buffer decreases when the desired message feed rate is less than the message download rate.

In another aspect the subject matter of this disclosure relates to a system that includes a non transitory computer readable medium having instructions stored thereon. The system also includes a data processing apparatus configured to execute the instructions to perform operations that include receiving at a client device a stream of messages from a sender providing the stream of messages to a messaging application on the client device at a desired message feed rate associated with the sender monitoring a message download rate of the stream of messages by the messaging application determining that the message download rate is less than the desired message feed rate and in response providing the stream of messages to a buffer on the client device at the desired message feed rate and sending the stream of messages from the buffer to the messaging application at the message download rate determining that the message download rate is greater than the desired message feed rate and in response allowing a stored quantity of messages on the buffer to decrease and determining that the stored quantity of messages on the buffer is zero and in response providing the stream of messages to the messaging application at the desired message feed rate.

In certain examples the stream of messages corresponds to a single channel in a PubSub system or alternatively to a plurality of channels in a PubSub system. The buffer may include a plurality of buffers and each buffer in the plurality of buffers may correspond to one channel in the plurality of channels. In various instances the sender is or includes an MX node in a PubSub system. The desired message feed rate may correspond to a rate at which messages are published in a PubSub system. In some implementations the download rate corresponds to a maximum rate at which the messaging application is able to download messages. The download rate may depend on for example a desired refresh rate for the client device.

In some examples sending the stream of messages from the buffer to the client device may include sending messages in an order in which the messages were received by the buffer. In general the stored quantity of messages on the buffer increases e.g. message data accumulates on the buffer when the desired message feed rate is greater than the message download rate. In various examples the stored quantity of messages on the buffer decreases when the desired message feed rate is less than the message download rate.

In another aspect the subject matter described in this specification can be embodied in a computer program product stored in one or more non transitory storage media for controlling a processing mode of a data processing apparatus. The computer program product is executable by the data processing apparatus to cause the data processing apparatus to perform operations including receiving at a client device a stream of messages from a sender providing the stream of messages to a messaging application on the client device at a desired message feed rate associated with the sender monitoring a message download rate of the stream of messages by the messaging application determining that the message download rate is less than the desired message feed rate and in response providing the stream of messages to a buffer on the client device at the desired message feed rate and sending the stream of messages from the buffer to the messaging application at the message download rate determining that the message download rate is greater than the desired message feed rate and in response allowing a stored quantity of messages on the buffer to decrease and determining that the stored quantity of messages on the buffer is zero and in response providing the stream of messages to the messaging application at the desired message feed rate.

In certain examples the stream of messages corresponds to a single channel in a PubSub system or alternatively to a plurality of channels in a PubSub system. The buffer may include a plurality of buffers and each buffer in the plurality of buffers may correspond to one channel in the plurality of channels. In various instances the sender is or includes an MX node in a PubSub system. The desired message feed rate may correspond to a rate at which messages are published in a PubSub system. In some implementations the download rate corresponds to a maximum rate at which the messaging application is able to download messages. The download rate may depend on for example a desired refresh rate for the client device.

In some examples sending the stream of messages from the buffer to the client device may include sending messages in an order in which the messages were received by the buffer. In general the stored quantity of messages on the buffer increases e.g. message data accumulates on the buffer when the desired message feed rate is greater than the message download rate. In various examples the stored quantity of messages on the buffer decreases when the desired message feed rate is less than the message download rate.

The details of one or more embodiments of the subject matter described in this specification are set forth in the accompanying drawings and the description below. Other features aspects and advantages of the subject matter will become apparent from the description the drawings and the claims.

There is no separate operation needed to create a named channel. A channel is created implicitly when the channel is subscribed to or when a message is published to the channel. In some implementations channel names can be qualified by a name space. A name space comprises one or more channel names. Different name spaces can have the same channel names without causing ambiguity. The name space name can be a prefix of a channel name where the name space and channel name are separated by a dot. In some implementations name spaces can be used when specifying channel authorization settings. For instance the messaging system may have app1.foo and app1.system.notifications channels where app1 is the name of the name space. The system can allow clients to subscribe and publish to the app1.foo channel. However clients can only subscribe to but not publish to the app1.system.notifications channel.

The operating system layer comprises the operating system software on the client . In various implementations messages can be sent and received to from the system using persistent or non persistent connections. Persistent connections can be created using for example network sockets. A transport protocol such as TCP IP layer implements the Transport Control Protocol Internet Protocol communication with the system that can be used by the messaging layer to send messages over connections to the system . Other communication protocols are possible including for example User Datagram Protocol UDP . In further implementations an optional Transport Layer Security TLS layer can be employed to ensure the confidentiality of the messages.

In the example messaging system one or more client devices publishers and or subscribers establish respective persistent connections e.g. TCP connections to an MX node e.g. MX . The MX node serves as a termination point for these connections. For instance external messages e.g. between respective client devices and the MX node carried by these connections can be encoded based on an external protocol e.g. JSON . The MX node terminates the external protocol and translates the external messages to internal communication and vice versa. The MX nodes publish and subscribe to streamlets on behalf of clients. In this way an MX node can multiplex and merge requests of client devices subscribing for or publishing to the same channel thus representing multiple client devices as one instead of one by one.

In the example messaging system a Q node e.g. Q node can store one or more streamlets of one or more channel streams. A streamlet is a data buffer for a portion of a channel stream. A streamlet will close to writing when its storage is full. A streamlet will close to reading and writing and be de allocated when its time to live TTL has expired. By way of illustration a streamlet can have a maximum size of 1 MB and a TTL of three minutes. Different channels can have streamlets limited by different TTLs. For instance streamlets in one channel can exist for up to three minutes while streamlets in another channel can exist for up to 10 minutes. In various implementations a streamlet corresponds to a computing process running on a Q node. The computing process can be terminated after the streamlet s TTL has expired thus freeing up computing resources for the streamlet back to the Q node for example.

When receiving a publish request from a client device an MX node e.g. MX makes a request to a channel manager e.g. channel manager to grant access to a streamlet to write the message being published. Note however that if the MX node has already been granted write access to a streamlet for the channel and the channel has not been closed to writing the MX node can write the message to that streamlet without having to request a grant to access the streamlet. Once a message is written to a streamlet for a channel the message can be read by MX nodes and provided to subscribers of that channel.

Similarly when receiving a channel subscription request from a client device an MX node makes a request to a channel manager to grant access to a streamlet for the channel to read messages from. If the MX node has already been granted read access to a streamlet for the channel and the channel s TTL has not been closed to reading the MX node can read messages from the streamlet without having to request a grant to access the streamlet. The read messages can then be forwarded to client devices that have subscribed to the channel. In various implementations messages read from streamlets are cached by MX nodes so that MX nodes can reduce the number of times needed to read from the streamlets.

By way of illustration an MX node can request a grant from the channel manager that allows the MX node to store a block of data into a streamlet on a particular Q node that stores streamlets of the particular channel. Example streamlet grant request and grant data structures are as follows 

The streamletGrantRequest data structure stores the name of the stream channel and a mode indicating whether the MX node intends on reading from or writing to the streamlet. The MX node sends the StreamletGrantRequest to a channel manager node. The channel manager node in response sends the MX node a StreamletGrantResponse data structure. The streamletGrantResponse contains an identifier of the streamlet streamlet id the maximum size of the streamlet limit size the maximum number of messages that the streamlet can store limit msgs the TTL limit life and an identifier of a Q node q node on which the streamlet resides. The streamletGrantRequest and StreamletGrantResponse can also have a position field that points to a position in a streamlet or a position in a channel for reading from the streamlet.

A grant becomes invalid once the streamlet has closed. For example a streamlet is closed to reading and writing once the streamlet s TTL has expired and a streamlet is closed to writing when the streamlet s storage is full. When a grant becomes invalid the MX node can request a new grant from the channel manager to read from or write to a streamlet. The new grant will reference a different streamlet and will refer to the same or a different Q node depending on where the new streamlet resides.

The MX node then sends a prepare publish message with an identifier of a streamlet that the MX node wants to write to the Q node . The streamlet identifier and Q node identifier can be provided by the channel manager in the write grant as described earlier. The Q node hands over the message to a handler process e.g. a computing process running on the Q node for the identified streamlet . The handler process can send to the MX node an acknowledgement . After receiving the acknowledgement the MX node starts writing publishing messages e.g. and to the handler process which in turns stores the received data in the identified streamlet. The handler process can also send acknowledgements to the MX node for the received data. In some implementations acknowledgements can be piggy backed or cumulative. For instance the handler process can send to the MX node an acknowledgement for every predetermined amount of data received e.g. for every 100 messages received or for every predetermined time period e.g. for every one millisecond . Other acknowledgement scheduling algorithms such as Nagle s algorithm can be used.

If the streamlet can no longer accept published data e.g. when the streamlet is full the handler process sends a Negative Acknowledgement NAK message indicating a problem following by an EOF end of file message . In this way the handler process closes the association with the MX node for the publish grant. The MX node can then request a write grant for another streamlet from a channel manager if the MX node has additional messages to store.

The MX node then sends to the Q node a subscribe message with the identifier of the streamlet in the Q node and the position in the streamlet that the MX node wants to read from . The Q node hands over the subscribe message to a handler process for the streamlet . The handler process can send to the MX node an acknowledgement . The handler process then sends messages starting at the position in the streamlet to the MX node. In some implementations the handler process can send all of the messages in the streamlet to the MX node. After sending the last message in a particular streamlet the handler process can send a notification of the last message to the MX node. The MX node can send to the channel manager another request for another streamlet containing a next message in the particular channel.

If the particular streamlet is closed e.g. after its TTL has expired the handler process can send an unsubscribe message followed by an EOF message to close the association with the MX node for the read grant. The MX node can close the association with the handler process when the MX node moves to another streamlet for messages in the particular channel e.g. as instructed by the channel manager . The MX node can also close the association with the handler process if the MX node receives an unsubscribe message from a corresponding client device.

In various implementations a streamlet can be written into and read from at the same time instance. For instance there can be a valid read grant and a valid write grant at the same time instance. In various implementations a streamlet can be read concurrently by multiple read grants e.g. for channels subscribed to by multiple publisher clients . The handler process of the streamlet can order messages from concurrent write grants based on e.g. time of arrival and store the messages based on the order. In this way messages published to a channel from multiple publisher clients can be serialized and stored in a streamlet of the channel.

In the messaging system one or more C nodes e.g. C node can offload data transfers from one or more Q nodes. For instance if there are many MX nodes requesting streamlets from Q nodes for a particular channel the streamlets can be offloaded and cached in one or more C nodes. The MX nodes e.g. as instructed by read grants from a channel manager can read the streamlets from the C nodes instead.

As described above messages for a channel in the messaging system are ordered in a channel stream. A channel manager e.g. channel manager splits the channel stream into fixed sized streamlets that each reside on a respective Q node. In this way storing a channel stream can be shared among many Q nodes each Q node stores a portion one or more streamlets of the channel stream. More particularly a streamlet can be stored in registers and dynamic memory elements associated with a computing process on a Q node thus avoiding the need to access persistent slower storage devices such as hard disks. This results in faster message access. The channel manager can also balance load among Q nodes in the messaging system by monitoring respective workload of the Q nodes and allocating streamlets in a way that avoids overloading any one Q node.

In various implementations a channel manager maintains a list identifying each active streamlet the respective Q node on which the streamlet resides and identification of the position of the first message in the streamlet and whether the streamlet is closed for writing. In some implementations Q nodes notify the channel manager and any MX nodes that are publishing to a streamlet the streamlet is closed due to being full or when the streamlet s TTL has expired. When a streamlet is closed the streamlet remains on the channel manager s list of active streamlets until the streamlet s TTL has expired so that MX nodes can continue to retrieve messages from the streamlet.

When an MX node requests a write grant for a given channel and there is not a streamlet for the channel that can be written to the channel manager allocates a new streamlet on one of the Q nodes and returns the identity of the streamlet and the Q node in the StreamletGrant. Otherwise the channel manager returns the identity of the currently open for writing streamlet and corresponding Q node in the StreamletGrant. MX nodes can publish messages to the streamlet until the streamlet is full or the streamlet s TTL has expired after which a new streamlet can be allocated by the channel manager.

When an MX node requests a read grant for a given channel and there is not a streamlet for the channel that can be read from the channel manager allocates a new streamlet on one of the Q nodes and returns the identity of the streamlet and the Q node in the StreamletGrant. Otherwise the channel manager returns the identity of the streamlet and Q node that contains the position from which the MX node wishes to read. The Q node can then begin sending messages to the MX node from the streamlet beginning at the specified position until there are no more messages in the streamlet to send. When a new message is published to a streamlet MX nodes that have subscribed to that streamlet will receive the new message. If a streamlet s TTL has expired the handler sends EOF message to any MX nodes that are subscribed to the streamlet.

As described earlier in reference to the messaging system can include multiple channel managers e.g. channel managers . Multiple channel managers provide resiliency and prevent single point of failure. For instance one channel manager can replicate lists of streamlets and current grants it maintains to another slave channel manager. As for another example multiple channel managers can coordinate operations between them using distributed consensus protocols such as Paxos or Raft protocols.

In various examples systems and methods are provided for monitoring and controlling the transfer of message data to client devices. When sending a stream of messages to a client device the systems and methods may attempt to send the message stream at a desired message transfer rate which may correspond to for example a desired refresh rate for the client device or a desired number of bytes second. During periods of high message traffic the client device may be unable to receive or download the message stream at the desired message transfer rate. For example a download rate at the client device may be lower than the desired message transfer rate. In such an instance the message stream may be diverted to a buffer which may store or accumulate message data and pass the message data along to the client device preferably in the order in which the buffer received the message data. When the buffer receives message data faster than the buffer transfers message data to the client device e.g. because the desired message feed rate is greater than the download rate at the client device message data accumulates on the buffer. Likewise when the buffer transfers message data to the client device faster than it receives message data e.g. because the download rate at the client device is greater than the desired message feed rate message data is removed from the buffer. When a number of messages stored on the buffer is equal to zero messages may again be sent directly to the client device without first being diverted to the buffer.

In general the sender transfers the message streams to the client device at a desired message feed rate. The desired message feed rate may be or may correspond to for example a rate at which the sender is receiving message data to send to the client device . When the sender receives messages at a higher rate it may attempt to transfer the message streams to the client device at a correspondingly higher rate. In this way the desired message feed rate may fluctuate over time according to a number of messages being processed or handled by the sender .

In certain instances the messaging application is unable to receive or download the message streams at the desired message feed rate. When this happens the sensor which is monitoring the download rate and capabilities of the messaging application instructs the controller to stop sending the messages along the primary path and instead to divert the messages to the buffer along a buffer input path . The messages are then forward from the buffer to the messaging application along a buffer output path . The buffer is able to store or accumulate messages and messages can therefore be sent from the buffer to the messaging application at a rate that is lower than the desired message feed rate. For example the rate at which messages are sent from the buffer to the messaging application referred to herein as a buffer feed rate may be equal to a maximum download rate associated with the messaging application e.g. a maximum rate at which the messaging application is capable of downloading messages . This maximum download rate may be a fixed value e.g. based on a desired refresh rate for the messaging application or the client device or it may vary over time. In some implementations the maximum download rate is monitored and detected by the sensor .

In general a rate at which the buffer accumulates messages is a function of the desired message feed rate and the buffer feed rate. When the desired message feed rate exceeds the buffer feed rate a number of messages stored in the buffer increases. When the desired message feed rate is less than the buffer feed rate the number of messages stored in the buffer decreases.

The messaging application is preferably a software program that a user of a client device uses to view or receive message data. The messaging application may be for example a software program for viewing or receiving text messages email news feeds images music video or combinations thereof. The messaging application may be implemented on any suitable client device including for example smart phones tablet computers personal computers and workstations.

At a later time referring to the controller sends another message M to the messaging application along the primary path but the download rate of the messaging application e.g. as measured by the sensor is less than the desired message feed rate. To allow the sender to continue delivering messages at the desired message feed rate the controller sends a subsequent message M to the buffer along the buffer input path .

At a further instance in time referring to the controller continues to send messages to the buffer along the buffer input path and the messages are in turn forwarded from the buffer to the messaging application along the buffer output path . At this time message M is being sent from the buffer to the messaging application and message M is being sent from the controller to the buffer . The buffer is also storing messages M through M which were sent from the controller and received by the buffer previously. The desired message feed rate at this time is greater than the download rate and the number of messages stored on the buffer is increasing.

At a later time referring to the buffer is no longer storing messages and message M has been sent from the buffer to the messaging application . At this time the desired message feed rate is less than the download rate of the messaging application and the number of messages stored on the buffer has decreased to zero. With the buffer now empty and the messaging application able to download messages at the desired feed rate the controller sends a next message M directly to the messaging application along the primary path as shown in .

In various implementations the desired message feed rate is equal to the rate at which the sender sends and receives messages. The sender which may be an MX node or other PubSub system device receives or obtains a stream of messages and forwards the messages to the client device . The rate at which the sender forwards the messages may be equal to the rate at which the sender receives the messages. The sender preferably forwards messages in an order in which the messages were received.

In some instances when the buffer is full and the messaging application is unable to receive additional messages one or more messages e.g. messages that have been stored by the buffer for the longest period of time may be deleted from the buffer without being sent to the messaging application . Deleting the messages in this manner may avoid buffer bloat.

In certain examples the system utilizes a process control scheme to obtain desired rates of message data transfer from the sender to the messaging application . The sensor monitors the download rate at the messaging application and provides measured download rates to the controller e.g. along the feedback path and or one or more other components of the system . Likewise the desired message feed rate is monitored by the controller and or one or more other components of the system . When the download rate is less than the desired message feed rate i.e. the messaging application is unable to handle a flowrate of messages it is receiving the controller or a process controller used by the system e.g. within the client device diverts messages to the buffer thereby relieving message input demands on the messaging application . The controller continues to monitor the download rate and the desired message feed rate. When the buffer is empty and or no longer required to reduce the flow of messages to the client device the controller may resume sending messages directly to the messaging application along the primary path e.g. without first passing message data through the buffer .

In alternative implementations the system may not include the primary path and may always send messages to the messaging application via the buffer using the buffer input path and the buffer output path . In this arrangement when the desired message feed rate does not exceed the download rate the buffer may not store message data and may instead serve as a conduit through which messages are sent to the messaging application . The buffer may store messages as needed when the desired message feed rate exceeds the download rate as described herein.

Embodiments of the subject matter and the operations described in this specification can be implemented in digital electronic circuitry or in computer software firmware or hardware including the structures disclosed in this specification and their structural equivalents or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs i.e. one or more modules of computer program instructions encoded on computer storage medium for execution by or to control the operation of data processing apparatus. Alternatively or in addition the program instructions can be encoded on an artificially generated propagated signal e.g. a machine generated electrical optical or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. A computer storage medium can be or be included in a computer readable storage device a computer readable storage substrate a random or serial access memory array or device or a combination of one or more of them. Moreover while a computer storage medium is not a propagated signal a computer storage medium can be a source or destination of computer program instructions encoded in an artificially generated propagated signal. The computer storage medium can also be or be included in one or more separate physical components or media e.g. multiple CDs disks or other storage devices .

The operations described in this specification can be implemented as operations performed by a data processing apparatus on data stored on one or more computer readable storage devices or received from other sources.

The term data processing apparatus encompasses all kinds of apparatus devices and machines for processing data including by way of example a programmable processor a computer a system on a chip or multiple ones or combinations of the foregoing The apparatus can include special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit . The apparatus can also include in addition to hardware code that creates an execution environment for the computer program in question e.g. code that constitutes processor firmware a protocol stack a database management system an operating system a cross platform runtime environment a virtual machine or a combination of one or more of them. The apparatus and execution environment can realize various different computing model infrastructures such as web services distributed computing and grid computing infrastructures.

A computer program also known as a program software software application script or code can be written in any form of programming language including compiled or interpreted languages declarative procedural or functional languages and it can be deployed in any form including as a stand alone program or as a module component subroutine object or other unit suitable for use in a computing environment. A computer program may but need not correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data e.g. one or more scripts stored in a markup language resource in a single file dedicated to the program in question or in multiple coordinated files e.g. files that store one or more modules sub programs or portions of code . A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.

The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform actions by operating on input data and generating output. The processes and logic flows can also be performed by and apparatus can also be implemented as special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit .

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processors of any kind of digital computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for performing actions in accordance with instructions and one or more memory devices for storing instructions and data. Generally a computer will also include or be operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. However a computer need not have such devices. Moreover a computer can be embedded in another device e.g. a smart phone a mobile audio or video player a game console a Global Positioning System GPS receiver or a portable storage device e.g. a universal serial bus USB flash drive to name just a few. Devices suitable for storing computer program instructions and data include all forms of non volatile memory media and memory devices including by way of example semiconductor memory devices e.g. EPROM EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory can be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user embodiments of the subject matter described in this specification can be implemented on a computer having a display device e.g. a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input. In addition a computer can interact with a user by sending resources to and receiving resources from a device that is used by the user for example by sending web pages to a web browser on a user s client device in response to requests received from the web browser.

Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification or any combination of one or more such back end middleware or front end components. The components of the system can be interconnected by any form or medium of digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN and a wide area network WAN an inter network e.g. the Internet and peer to peer networks e.g. ad hoc peer to peer networks .

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other. In some embodiments a server transmits data e.g. an HTML page to a client device e.g. for purposes of displaying data to and receiving user input from a user interacting with the client device . Data generated at the client device e.g. a result of the user interaction can be received from the client device at the server.

A system of one or more computers can be configured to perform particular operations or actions by virtue of having software firmware hardware or a combination of them installed on the system that in operation causes or cause the system to perform the actions. One or more computer programs can be configured to perform particular operations or actions by virtue of including instructions that when executed by data processing apparatus cause the apparatus to perform the actions.

While this specification contains many specific implementation details these should not be construed as limitations on the scope of any inventions or of what may be claimed but rather as descriptions of features specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover although features may be described above as acting in certain combinations and even initially claimed as such one or more features from a claimed combination can in some cases be excised from the combination and the claimed combination may be directed to a subcombination or variation of a subcombination.

Similarly while operations are depicted in the drawings in a particular order this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order or that all illustrated operations be performed to achieve desirable results. In certain circumstances multitasking and parallel processing may be advantageous. Moreover the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.

Thus particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. In some cases the actions recited in the claims can be performed in a different order and still achieve desirable results. In addition the processes depicted in the accompanying figures do not necessarily require the particular order shown or sequential order to achieve desirable results. In certain implementations multitasking and parallel processing may be advantageous.

